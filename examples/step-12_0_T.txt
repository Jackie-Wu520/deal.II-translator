 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15] 

 [2.x.3]  

[1.x.16] 

[1.x.17] [1.x.18] [1.x.19] 


[1.x.20][1.x.21]。


本例专门介绍了[2.x.4]非连续Galerkin方法[2.x.5]，简称为DG方法。它包括以下主题。 2.x.6] [2.x.7] 用DG方法对线性平流方程进行离散化。   [2.x.8] 使用FEInterfaceValues组装跳跃项和单元间界面的其他表达。   [2.x.9] 使用[2.x.10] [2.x.11] 汇编系统矩阵。 

本程序特别关注的是DG方法的循环。这些问题变得特别复杂，主要是因为对于面的条款，我们必须分别区分边界、规则的内部面和有悬挂节点的内部面的情况。[2.x.12]处理了单元和面迭代的复杂性，并允许为不同的单元和面项指定 "工作者"。面条款本身的整合，包括对自适应细化面的整合，是通过FEInterfaceValues类完成的。

[1.x.22][1.x.23] 。


本例中解决的模型问题是线性平流方程[1.x.24]，受域的边界[2.x.14]的流入部分的边界条件[1.x.25]的制约。 这里，[2.x.15]表示一个矢量场，[2.x.16]是（标量）解函数，[2.x.17]是边界值函数，[1.x.26]是域的边界的流入部分，[2.x.18]表示边界的单位外向法线[2.x.19] 。该方程是本教程[2.x.20]中已经考虑的平流方程的保守版本。


在每个单元[2.x.21]上，我们从左边乘以一个测试函数[2.x.22]，然后通过部分积分得到。[1.x.27] 当在所有单元格[2.x.23]上求和时，边界积分是在所有内部和外部面上进行的，因此有三种情况。 [2.x.24] [2.x.25] 流入的外部边界（我们用给定的[2.x.27]替换[2.x.26]）。   [2.x.28] [2.x.29] 流出的外部边界。   [2.x.30] [2.x.31]内面（两边的积分变成了跳跃，我们使用上风速度）。   [2.x.32] [2.x.33]。 

这里，跳跃被定义为[2.x.34] ，其中上标指的是面的左（'+'）和右（'-'）值。如果[2.x.37]，上风值[2.x.35]被定义为[2.x.36]，否则[2.x.38]。

因此，依赖于网格的弱形式为。[1.x.28] 这里，[2.x.39]是三角形的所有活动单元的集合，[2.x.40]是所有活动内部面的集合。这个公式被称为上风非连续Galerkin方法。

为了实现这种双线性形式，我们需要用通常的方法计算单元项（第一个和）来实现单元上的积分，用FEInterfaceValues计算界面项（第二个和），以及边界项（其他两个和）。所有这些的求和是由[2.x.41]完成的。 




[1.x.29][1.x.30] 。


我们在[2.x.42]上求解平流方程，[2.x.43]代表一个圆形的逆时针流场，[2.x.44]代表[2.x.45]，[2.x.46]代表[2.x.47] 。

我们通过估计每个单元的梯度规范，自适应地细化网格，在一连串的网格上求解。在每个网格上求解后，我们以vtk格式输出解，并计算解的[2.x.48]规范。由于精确的解是0或1，我们可以用这个来衡量数值解的过冲程度。[1.x.31] [1.x.32]。

前面几个文件已经在前面的例子中讲过了，因此不再进一步评论。

[1.x.33] 



这里定义了不连续的有限元。它们的使用方式与所有其他有限元相同，不过--正如你在以前的教程程序中所看到的--用户与有限元类的交互并不多：它们被传递给[2.x.49]和[2.x.50]对象，就这些了。

[1.x.34] 



FEInterfaceValues需要这个头来计算界面上的积分。

[1.x.35] 



我们将使用最简单的求解器，称为Richardson迭代，它代表了一个简单的缺陷修正。这与一个块状SSOR预处理器（定义在precondition_block.h中）相结合，该预处理器使用DG离散化产生的系统矩阵的特殊块状结构。

[1.x.36] 



我们将使用梯度作为细化指标。

[1.x.37] 



最后，新的包含文件用于使用MeshWorker框架中的Mesh_loop。

[1.x.38] 



就像所有的程序一样，我们在这一节结束时包括了所需的C++头文件，并声明我们要使用dealii命名空间中的对象，不含前缀。

[1.x.39] 




[1.x.40][1.x.41] 。   


首先，我们定义一个描述不均匀边界数据的类。由于只使用它的值，我们实现value_list()，但不定义Function的所有其他函数。

[1.x.42] 



考虑到流动方向，单元格[2.x.51]的流入边界是右边界和下边界。我们在x轴上规定了不连续的边界值1和0，在右边界上规定了值0。这个函数在流出边界上的值将不会在DG方案中使用。

[1.x.43] 



最后，一个计算并返回风场的函数 [2.x.52] 。正如介绍中所解释的，在2D中我们将使用一个围绕原点的旋转场。在3D中，我们只是不设置[2.x.53]分量（即为零），而该函数在目前的实现中不能用于1D。

[1.x.44] 




[1.x.45][1.x.46] 。   


以下对象是我们在调用[2.x.54]时使用的抓取和复制对象。新对象是FEInterfaceValues对象，其工作原理类似于FEValues或FEFacesValues，只是它作用于两个单元格之间的接口，并允许我们以我们的弱形式组装接口项。







[1.x.47] 




[1.x.48][1.x.49] 。   


在这些准备工作之后，我们继续进行这个程序的主类，称为AdvectionProblem。   


这一切对你来说应该是非常熟悉的。有趣的细节只有在实现集合函数的时候才会出现。

[1.x.50] 



此外，我们要使用DG元素。

[1.x.51] 



接下来的四个成员代表要解决的线性系统。 [2.x.55] 是由 [2.x.56] 生成的，在 [2.x.57] 中计算的，用于确定 [2.x.58] 中非零元素的位置 。

[1.x.52] 



我们从构造函数开始。[2.x.59]的构造器调用中的1是多项式的度数。

[1.x.53] 



在设置通常的有限元数据结构的函数中，我们首先需要分配DoF。

[1.x.54] 



我们从生成稀疏模式开始。为此，我们首先用系统中出现的耦合物填充一个动态稀疏模式（DynamicSparsityPattern）类型的中间对象。在建立模式之后，这个对象被复制到[2.x.60]，可以被丢弃。




为了建立DG离散的稀疏模式，我们可以调用与[2.x.61]类似的函数，该函数被称为[2.x.62]。 

[1.x.55] 



最后，我们设置了线性系统的所有组成部分的结构。

[1.x.56] 




[1.x.57][1.x.58] 。




在这里我们看到了与手工组装的主要区别。我们不需要在单元格和面上写循环，而是将逻辑包含在对[2.x.63]的调用中，我们只需要指定在每个单元格、每个边界面和每个内部面应该发生什么。这三个任务是由下面的函数里面的lambda函数处理的。







[1.x.59] 



这是将对每个单元格执行的函数。

[1.x.60] 



我们求解的是一个同质方程，因此在单元项中没有显示出右手。 剩下的是对矩阵项的积分。

[1.x.61] 



这是为边界面调用的函数，由使用FEFaceValues的正常积分组成。新的逻辑是决定该项是进入系统矩阵（流出）还是进入右手边（流入）。

[1.x.62] 



这是在内部面调用的函数。参数指定了单元格、面和子面指数（用于自适应细化）。我们只是将它们传递给FEInterfaceValues的reinit()函数。

[1.x.63] 



下面的lambda函数将处理从单元和面组件中复制数据到全局矩阵和右手边。     


虽然我们不需要AffineConstraints对象，因为在DG离散中没有悬空节点约束，但我们在这里使用一个空对象，因为这允许我们使用它的`copy_local_to_global`功能。

[1.x.64] 



在这里，我们最后处理装配。我们传入ScratchData和CopyData对象，以及上面的lambda函数，并指定我们要对内部面进行一次组装。

[1.x.65] 




[1.x.66] [1.x.67]    


对于这个简单的问题，我们使用最简单的求解器，称为Richardson迭代，它代表了一个简单的缺陷修正。这与一个块状SSOR预调节器相结合，该预调节器使用由DG离散化产生的系统矩阵的特殊块状结构。这些块的大小是每个单元的DoF数量。这里，我们使用SSOR预处理，因为我们没有根据流场对DoFs进行重新编号。如果在流的下游方向对DoFs进行重新编号，那么块状高斯-赛德尔预处理（见PreconditionBlockSOR类，放松=1）会做得更好。

[1.x.68] 



这里我们创建了预处理程序。

[1.x.69] 



然后将矩阵分配给它并设置正确的块大小。

[1.x.70] 



在这些准备工作之后，我们就可以启动线性求解器了。

[1.x.71] 



我们根据一个非常简单的细化标准来细化网格，即对解的梯度的近似。由于这里我们考虑的是DG(1)方法（即我们使用片状双线性形状函数），我们可以简单地计算每个单元上的梯度。但是我们并不希望我们的细化指标只建立在每个单元的梯度上，而是希望同时建立在相邻单元之间的不连续解函数的跳跃上。最简单的方法是通过差分商计算近似梯度，包括考虑中的单元和其相邻的单元。这是由[2.x.64]类完成的，它计算近似梯度的方式类似于本教程[2.x.66]中描述的[2.x.65]。事实上，[2.x.67]类是在[2.x.69]的[2.x.68]类之后开发的。与 [2.x.70] 中的讨论相关，这里我们考虑 [2.x.71] 。此外，我们注意到，我们不考虑近似的二次导数，因为线性平流方程的解一般不在[2.x.72]中，而只在[2.x.73]中（或者，更准确地说：在[2.x.74]中，即在方向[2.x.75]中的导数是可平方整除的函数空间）。

[1.x.72] 



[2.x.76]类计算梯度的精度为浮点。这就足够了，因为它们是近似的，只作为细化指标。

[1.x.73] 



现在，近似梯度被计算出来了 

[1.x.74] 



并将它们按单元格的系数[2.x.77]进行缩放。 

[1.x.75] 



最后，它们作为细化指标。

[1.x.76] 



该程序的输出包括一个自适应细化网格和数值解的vtk文件。最后，我们还用[2.x.78]计算了解的L-无穷大规范。 

[1.x.77] 



下面的[2.x.79]函数与之前的例子类似。

[1.x.78] 



下面的[2.x.80]函数与之前的例子也类似，不需要评论。

[1.x.79] 

[1.x.80][1.x.81] 。




这个程序的输出包括控制台的输出和vtk格式的解决方案。

[1.x.82] 



我们展示了初始网格的解决方案，以及经过两个和五个自适应细化步骤后的网格。

 [2.X.81] [2.X.82] [2.X.83] 。 

最后我们展示一个三维计算的图。

 [2.x.84]  


[1.x.83] [1.x.84][1.x.85] 。


在这个程序中，我们使用了不连续的元素。这是一个合理的问题，为什么不简单地使用正常的、连续的。当然，对于每个有数值方法背景的人来说，答案是显而易见的：连续Galerkin（cG）方法对于传输方程是不稳定的，除非特别增加稳定项。然而，DG方法[1.x.86]则是稳定的。用目前的程序来说明这一点并不十分困难；事实上，只需要做以下几个小的修改就可以了。

- 将元素改为FE_Q而不是FE_DGQ。

- 以与 [2.x.85] 完全相同的方式增加对悬挂节点约束的处理。

- 我们需要一个不同的求解器；[2.x.86]中的直接求解器是一个方便的选择。一个有经验的deal.II用户将能够在10分钟内完成这个工作。

虽然上面已经展示了2d解，在界面上包含了一些小的尖峰，然而在网格细化下高度稳定，当使用连续元素时，结果看起来大不相同。

 [2.x.87]  

在细化迭代5中，图像不能再以合理的方式绘制成三维图。因此，我们展示了一个范围为[2.x.88]的彩色图（当然，精确解的解值位于[2.x.89]，）。在任何情况下，很明显，连续Galerkin解表现出振荡行为，随着网格的细化越来越差。

如果人们出于某种原因想使用连续元素，有许多策略可以稳定cG方法。讨论这些方法超出了本教程程序的范围；例如，感兴趣的读者可以看看 [2.x.90] 。




[1.x.87] [1.x.88][1.x.89] 。


鉴于在这种情况下确切的解决方案是已知的，进一步扩展的一个有趣途径是确认这个程序的收敛顺序。在目前的情况下，解是非光滑的，因此我们不能期望得到特别高的收敛阶数，即使我们使用高阶元素。但即使解[1.x.90]光滑，该方程也不是椭圆的，因此，我们应该获得等于最优插值估计的收敛阶数，这一点并不明显（例如，我们通过使用二次元可以获得[2.x.91]在[2.x.92]规范下的收敛）。

事实上，对于双曲方程来说，理论预测常常表明，最好的希望是低于内插估计值二分之一的阶。例如，对于流线扩散法（此处用于稳定传输方程解的DG法的一种替代方法），可以证明对于度数为[2.x.93]的元素，在任意网格上的收敛阶数为[2.x.94]。虽然在均匀细化的网格上观察到的顺序经常是[2.x.95]，但人们可以构建所谓的彼得森网格，在该网格上实际上达到了更差的理论约束。这应该是比较简单的验证，例如使用[2.x.96]函数。

一个不同的方向是观察运输问题的解决经常有不连续性，因此我们[1.x.91]每个坐标方向的每个单元的网格可能不是最佳的。相反，一个更好的策略是只在平行于不连续的方向上切割单元。这被称为 [1.x.92] ，是 [2.x.97] 的主题。[1.x.93] [1.x.94] [2.x.98] 。 

 [2.x.99] 
