 [2.x.0] [2.x.1] 。 

本教程取决于 [2.x.2] , [2.x.3] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14 ][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28] 

[1.x.29] 

 [2.x.4]  

[1.x.30] [1.x.31][1.x.32]。


[1.x.33][1.x.34]。


本教程的目的是为斯托克斯方程创建一个高效的线性求解器，并将其与其他方法进行比较。 在这里，我们将使用带有几何多网格的FGMRES作为预处理速度块，我们将在结果部分表明，这比[2.x.5]中使用的线性求解器（包括 "可能的扩展 "中描述的方案）从根本上来说是一种更好的方法。 从根本上说，这是因为只有使用多网格才有可能得到[2.x.6]的求解时间，其中[2.x.7]是线性系统的未知数的数量。使用Timer类，我们收集一些统计数据来比较设置时间、求解时间和迭代次数。我们还计算误差以确保我们所实现的是正确的。

让 [2.x.8] 和 [2.x.9] . 斯托克斯方程在非维度化形式下读作如下。

[1.x.35] 



请注意，我们使用的是变形张量，而不是[2.x.10]（关于两者之间的区别的详细描述可以在[2.x.11]中找到，但总的来说，变形张量的物理性更强，也更昂贵）。

[1.x.36][1.x.37] 


离散方程的弱形式自然导致了以下速度和压力场的节点值的线性系统。[1.x.38] 



我们的目标是比较几种解决方法。 虽然[2.x.12]使用 "Schur补数法 "分两步解决线性系统，但我们本着[2.x.13]"结果 "一节中概述的方法，使用带有高效预处理程序的FMGRES一次性解决该块系统。其思路如下：如果我们找到一个块状预处理器[2.x.14]，使矩阵 

[1.x.39] 



是简单的，那么使用该预处理程序的迭代求解器将在几次迭代中收敛。注意，我们在这里做的是正确的预处理。 使用舒尔补码[2.x.15]，我们发现 

[1.x.40] 



是一个不错的选择。让[2.x.16]是[2.x.17]的近似值，[2.x.18]是[2.x.19]的近似值，我们看到[1.x.41]。



由于[2.x.20]的目的只是作为一个预处理程序，我们将在上式中使用右边的近似值。

正如在[2.x.21]、[2.x.22]中所讨论的，其中[2.x.23]是压力质量矩阵，通过使用CG与ILU作为预处理程序进行近似求解，而[2.x.24 ]是通过多种方法之一得到的：用CG和ILU作为预处理程序求解线性系统，仅仅使用ILU的一次应用，用CG和GMG（如[2.x.25]中描述的几何多网格）作为预处理程序求解线性系统，或者仅仅执行GMG的一个V-循环。

作为比较，我们还在整个系统上使用了直接求解器UMFPACK来比较我们的结果，而不是FGMRES。 如果你想使用直接求解器（如UMFPACK），系统需要是可逆的。为了避免恒定压力给定的一维无效空间，我们将第一个压力未知数固定为零。这对迭代求解器来说是没有必要的。


[1.x.42][1.x.43] 。


测试问题是一个 "制造的解决方案"（详见[2.x.26]），我们选择[2.x.27]和[2.x.28] 。我们在域的整个边界上对速度应用迪里切特边界条件 [2.x.29] 。为了执行边界条件，我们可以直接使用我们的参考解。

如果你在deal.II手册中查找创建一个从[2.x.30]派生的类所需的内容，你会发现这个类有许多[2.x.31]函数，包括[2.x.32] [2.x.33] [2.x.34]等等，所有这些都可以被重载。 deal.II的不同部分将需要这些特定函数中的不同部分。这在一开始会让人感到困惑，但幸运的是，你真正需要实现的只有[2.x.35]，函数类中的其他虚函数在里面有默认的实现，会默认调用你对[2.x.36]的实现。

请注意，我们的参考方案满足了 [2.x.37] 。此外，压力被选择为平均值为零。 对于[2.x.38]的 "制造解决方案的方法"，我们需要找到[2.x.39]，以便。

[1.x.44] 



使用上面的参考解，我们得到。

[1.x.45] 



[1.x.46][1.x.47] 。


因为我们在线性系统中没有强制要求平均压力为零，所以我们需要在求解后对解决方案进行后处理。为了做到这一点，我们使用[2.x.40]函数来计算压力的平均值，以便从压力中减去它。


[1.x.48][1.x.49] 。


我们在这里实现几何多网格的方式只在速度变量（即上面描述的[2.x.41]矩阵）上执行，而不是压力。我们可以用不同的方式来实现这一点，包括将所有的粗网格操作视为作用于[2.x.42]块系统，我们只考虑左上角的块。另外，我们也可以通过真正只考虑整个有限元离散化的速度部分的线性系统来实现。后者是我们在这里想要使用的方式。

为了实现这一点，我们需要能够提出诸如 "我可以只拥有DoFHandler的一部分吗？"之类的问题。在编写这个程序的时候，这是不可能的，所以为了满足我们的需求，我们只是为速度创建一个单独的、第二个DoFHandler。然后，我们只基于这个第二DoFHandler为多网格预处理程序建立线性系统，并简单地将第一块（整体）向量转移到整个第二DoFHandler的对应向量中。为了实现这一目标，我们必须保证两个DoFHandler对象中的（速度）自由度排序的[1.x.50]是相同的。事实上，首先在两个对象上分配自由度，然后在两个对象上使用相同的DoFRenumbering操作序列，就可以做到这一点。


[1.x.51][1.x.52] 


[2.x.43]和[2.x.44]之间的主要区别是，我们使用块状求解器而不是[2.x.45]中使用的Schur Complement方法。这种方法的细节可以在[2.x.46]的 "可能的扩展 "部分的 "块状Schur补码预处理 "小节中找到。对于速度块的预处理，我们从[1.x.53]中借用了一个名为[2.x.47]的类，该类可以选择求解[2.x.48]的逆，或者只对其应用一个预处理扫频，这分别为我们提供了一种昂贵和廉价的方法。[1.x.54] [1.x.55]。


[1.x.56][1.x.57] 。







[1.x.58] 



我们需要包括以下文件来做计时。

[1.x.59] 



这包括我们使用几何多网格所需的文件 

[1.x.60] 



为了方便在使用的不同求解器之间进行切换，我们声明一个枚举，可以作为参数传递给主类的构造函数。

[1.x.61] 




[1.x.62] [1.x.63]    


类Solution是用来定义边界条件和计算数值解的误差的。请注意，我们需要定义值和梯度，以便计算L2和H1误差。在这里，我们决定使用模板的特殊化来分离2D和3D的实现。   


请注意，前几个昏暗分量是速度分量，最后一个是压力。

[1.x.64] 



请注意，对于梯度，我们需要返回一个Tensor<1,dim>。

[1.x.65] 



[2.x.49] 的实现。更多信息请参见介绍。

[1.x.66] 




[1.x.67] [1.x.68] ．




在下文中，我们将实现一个预处理程序，它扩展了 [2.x.50] 的结果部分所讨论的想法。具体来说，我们1.使用一个上块三角的预处理器，因为我们想使用右预处理。2.可选择允许使用速度块的内部求解器，而不是单一的预处理程序应用。3.不使用InverseMatrix，而是明确地调用SolverCG。这种方法也用于ASPECT代码（见https://aspect.geodynamics.org），该代码在模拟地幔对流的背景下求解斯托克斯方程，该代码已被用于解决成千上万个处理器上的问题。   


构造函数中的bool标志[2.x.51]允许我们对速度块应用一次预处理，或者使用内部迭代求解器来代替更精确的近似。   


注意我们是如何跟踪内部迭代的总和（预处理程序的应用）的。

[1.x.69] 



首先用S的近似值求解 

[1.x.70] 



其次，应用右上角的块（B^T）。

[1.x.71] 



最后，要么用左上角的块求解，要么只应用一个预处理程序扫频。

[1.x.72] 




[1.x.73][1.x.74] 。   


这是该问题的主要类别。

[1.x.75] 



只针对速度的有限元。

[1.x.76] 



整个系统的有限元。

[1.x.77] 




[1.x.78] [1.x.79] 




该函数设置了DoFHandler、矩阵、向量和Multigrid结构（如果需要）。

[1.x.80] 



主DoFHandler只需要活动的DoF，所以我们不在这里调用distribution_mg_dofs() 

[1.x.81] 



这个块结构将dim速度分量与压力分量（用于重新排序）分开。注意，我们有2个而不是像[2.x.52]中的dim+1块，因为我们的FESystem是嵌套的，dim速度分量作为一个块出现。

[1.x.82] 



速度从分量0开始。

[1.x.83] 



如果我们应用重新排序来减少填充，ILU的表现会更好。对于其他求解器来说，这样做并没有什么好处。

[1.x.84] 



这确保了所有的速度DoF在压力未知数之前被列举出来。这允许我们使用块来处理向量和矩阵，并允许我们为dof_handler和velocity_dof_handler获得相同的DoF编号。

[1.x.85] 



这将速度空间的主动道次和多网格道次分布在一个单独的DoFHandler中，如介绍中所述。

[1.x.86] 



下面的代码块初始化了MGConstrainedDofs（使用速度的边界条件），以及每个层次的稀疏模式和矩阵。MGLevelObject<T>的resize()函数将销毁所有现有的包含对象。

[1.x.87] 



下面利用分量掩码，只对速度的边界值进行插值，这在矢量值dealii[2.x.53]教程中进一步解释。

[1.x.88] 



正如介绍中所讨论的，我们需要固定压力变量的一个自由度以确保问题的可解性。我们在这里通过标记第一个压力自由度来做到这一点，该自由度的索引为n_u，是一个受约束的自由度。

[1.x.89] 




[1.x.90][1.x.91] 。




在这个函数中，系统矩阵被组装起来。我们在(1,1)块中装配压力质量矩阵（如果需要），并在此函数结束时将其移出该位置。

[1.x.92] 



如果为真，我们将在(1,1)块中装配压力质量矩阵。

[1.x.93] 




[1.x.94] [1.x.95] 




在这里，就像在[2.x.54]中一样，我们有一个函数来组装多网格预处理程序所需的水平和界面矩阵。

[1.x.96] 



这个迭代器覆盖了所有的单元（不仅仅是活动的）。

[1.x.97] 




[1.x.98] [1.x.99] 




这个函数根据你是想使用ILU还是GMG作为预处理程序来设置不同的东西。 这两种方法共享相同的求解器（FGMRES），但需要初始化不同的预处理器。在这里，我们不仅对整个求解函数进行计时，而且对预调节器的设置以及求解本身分别进行计时。

[1.x.100] 



这里我们必须确保以 "足够好 "的精度求解残差。

[1.x.101] 



这是用来传递我们是否要在预处理程序中求解A。 我们可以把它改为false，看看是否仍有收敛性，如果有，程序会不会运行得更快或更慢。

[1.x.102] 



在各级之间转移运算符 

[1.x.103] 



设置粗略的网格解算器 

[1.x.104] 



多网格作为CG的预处理程序时，需要是一个对称算子，所以平滑器必须是对称的。

[1.x.105] 



现在，我们准备设置V型循环算子和多级预处理器。

[1.x.106] 




[1.x.107] [1.x.108]。




这个函数计算解的L2和H1误差。为此，我们需要确保压力的平均值为零。

[1.x.109] 



计算平均压力[2.x.55]，然后从每个压力系数中减去它。这将导致压力的平均值为零。这里我们利用了压力是分量[2.x.56]和有限元空间是节点的事实。

[1.x.110] 




[1.x.111] [1.x.112]。




这个函数生成图形输出，就像在 [2.x.57] 中所做的那样。

[1.x.113] 




[1.x.114] [1.x.115] ．




斯托克斯类的最后一步是，像往常一样，生成初始网格的函数，并按各自的顺序调用其他函数。

[1.x.116] 




[1.x.117][1.x.118] 。

[1.x.119] 



SolverType的选项。umfpack fgmres_ilu fgmres_gmg 

[1.x.120] 

[1.x.121][1.x.122]。


[1.x.123][1.x.124]。


我们首先运行代码，确认有限元解以混合有限元问题的误差分析所预测的正确速率收敛。给定足够平滑的精确解[2.x.58]和[2.x.59]，Taylor-Hood元素[2.x.60]的误差应该是 

[1.x.125] 

例如，见Ern/Guermond "有限元的理论与实践"，第4.2.5节第195页。这确实是我们观察到的，以[2.x.61]元素为例（这就是代码中的做法，但在[2.x.62]中很容易改变）。

 [2.x.63]  

[1.x.126][1.x.127] 。


让我们比较一下使用UMFPACK的直接求解方法和我们选择[2.x.64]和[2.x.65]的两种方法，用CG求解[2.x.66]的线性系统。然后CG的预处理程序是ILU或GMG。下表总结了求解器的迭代、时间和虚拟内存（VM）的峰值使用。

 [2.x.67]  

从表中可以看出。

1. UMFPACK使用了大量的内存，特别是在3D中。另外，UMFPACK的时序并不随问题大小而变化。

2. 因为我们对[2.x.68]和[2.x.69]使用内部求解器，ILU和GMG需要相同数量的外部迭代。

3. 3. 对于ILU来说，[2.x.70]的（内部）迭代次数随着细化而增加，导致求解时间的线性扩展性较差。相比之下，[2.x.71]的内部迭代次数在GMG中保持不变，导致求解时间几乎完美的缩放。

4. GMG需要比ILU多一点的内存来存储水平和界面矩阵。

[1.x.128][1.x.129] 。


[1.x.130][1.x.131] 。


用更高阶的稳定FE对进行实验，并检查你是否观察到正确的收敛率。

[1.x.132][1.x.133] 。


介绍中还概述了另一种对整个系统进行预处理的方案，即我们不选择上表中的[2.x.72]，而是在[2.x.73]中只分别使用GMG或ILU的单一预处理程序。

这实际上是在代码中实现的。目前，布尔值[2.x.74]被设置为[2.x.75] 上面提到的选项是通过设置为[2.x.76]得到的。 

你会发现的是，如果你这样使用GMG，FGMRES的迭代次数在细化中保持不变。这意味着多重网格是最优的，并且不受 [2.x.77] 的影响。[1.x.134] [1.x.135] [2.x.78] 。 

 [2.x.79] 
