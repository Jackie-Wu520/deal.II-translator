 [2.x.0][2.x.1] 。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15 ][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29] 

 [2.x.3]  

[1.x.30] [2.x.4]  


[1.X.31] [1.X.32] [1.X.33] 


[1.x.34][1.x.35]。


这个程序涉及到一个非线性椭圆偏微分方程的例子，即最小表面方程。你可以想象这个方程的解描述一个肥皂膜所跨越的表面，这个肥皂膜被一个封闭的金属环所包围。我们想象金属丝不只是一个平面的环，实际上是弯曲的。肥皂膜的表面张力将使该表面变成最小表面。最小表面方程的解描述了这个形状，电线的垂直位移是一个边界条件。为了简单起见，我们在这里假设表面可以写成图形[2.x.5]，尽管很明显，构建这样的情况并不难，即钢丝弯曲的方式使得表面只能在局部构建成图形，而不是全局。

因为这个方程是非线性的，我们不能直接解决它。相反，我们必须使用牛顿方法来迭代计算解决方案。

 [2.x.6] （ [2.x.7] ）。 




[1.x.36][1.x.37] 。


在经典的意义上，该问题以如下形式给出。


  [1.x.38] 



 [2.x.8]是我们通过将导线的位置投射到[2.x.9]空间得到的域。在这个例子中，我们选择[2.x.10]作为单位盘。

如上所述，我们用牛顿方法来解决这个方程，我们从[2.x.12]的第[2.x.13]个近似解计算出[2.x.11]个近似解，并使用阻尼参数[2.x.14]来获得更好的全局收敛行为。  [1.x.39] 

用[1.x.40]和[2.x.15]的F的导数在[2.x.16]的方向：[1.x.41] 

通过运动找出[2.x.17]是什么，我们发现我们必须在每一个牛顿步骤中解决一个线性椭圆PDE，[2.x.18]是以下的解。

  [1.x.42] 

为了解决最小表面方程，我们必须重复解决这个方程，每个牛顿步骤一次。为了解决这个问题，我们必须看一下这个问题的边界条件。假设[2.x.19]已经有了正确的边界值，那么牛顿更新[2.x.20]的边界条件应该为零，这样才能在加入两者之后有正确的边界条件。 在第一个牛顿步骤中，我们从解[2.x.21]开始，牛顿更新仍然需要为解[2.x.22]提供正确的边界条件。


总而言之，我们必须在第一步用边界条件[2.x.23]来解决上面的PDE，在接下来的所有步骤中用[2.x.24]来解决。


[1.x.43][1.x.44] 。


从上面的强公式开始，我们通过将PDE的两边都乘以测试函数[2.x.25]并对两边进行部分积分，得到弱公式。  [1.x.45] 这里的解[2.x.26]是[2.x.27]中的一个函数，受制于上面讨论的边界条件。将这一空间还原为具有基础[2.x.28]的有限维空间，我们可以写出解。

[1.x.46] 

使用基函数作为测试函数并定义[2.x.29]，我们可以重写弱的表述。

[1.x.47] 

其中解[2.x.30]是由系数[2.x.31]给出的。这个线性方程组可以改写为。

[1.x.48] 

其中矩阵[2.x.32]的条目由以下方式给出。

[1.x.49] 

右手边[2.x.33]由以下公式给出。

[1.x.50] 


[1.x.51][1.x.52] 。


与上述牛顿步骤相对应的矩阵可以重新表述，以更好地显示其结构。稍微重写一下，我们得到它的形式是[1.x.53]，其中矩阵[2.x.34]（在[2.x.36]空间维度中大小为[2.x.35]）由以下表达式给出。[1.x.54] 从这个表达式中可以看出，[2.x.37]是对称的，所以[2.x.38]也是对称的。另一方面，[2.x.39]也是正定的，这使[2.x.40]也具有同样的属性。这可以通过注意到向量[2.x.41]是[2.x.42]的特征向量，其特征值为[2.x.43]，而所有与[2.x.45]相互垂直的向量[2.x.44]都是特征向量，其特征值为[2.x.46] 。因为所有的特征值都是正的，所以[2.x.47]是正定的，[2.x.48]也是。因此我们可以使用CG方法来解决牛顿步骤。矩阵[2.x.49]是对称和正定的这一事实不应该令人惊讶。它是由取一个能量函数的导数而产生的算子的结果：最小表面方程只是最小化了一些非二次元的能量。因此，牛顿矩阵，作为标量能量的二阶导数矩阵，必须是对称的，因为与[2.x.50]th和[2.x.51]th自由度有关的导数应该明显地相互交换。同样，如果能量函数是凸的，那么第二导数的矩阵必须是正定的，上面的直接计算只是重申了这一点。) 

然而，值得注意的是，在[2.x.52]变得很大的问题上，正定性会退化。换句话说，如果我们简单地将所有边界值乘以2，那么一阶[2.x.53]和[2.x.54]也将被乘以2，但结果是[2.x.55]的最小特征值将变小，矩阵将变得更加涣散。更具体地说，对于[2.x.56]，我们有[2.x.57]而[2.x.58]；因此，[2.x.59]的条件数，也就是[2.x.60]的条件数的一个乘法因子，会像[2.x.61]那样增长）。用目前的程序简单地验证一下，确实将目前程序中使用的边界值乘以越来越大的数值，导致问题最终不再能用我们这里使用的简单的预设条件的CG方法解决。


[1.x.55][1.x.56] 


如上所述，牛顿方法的工作原理是计算一个方向[2.x.62]，然后以步长[2.x.64]执行更新[2.x.63] 。一般来说，对于强非线性模型，如果我们总是选择[2.x.65]，牛顿方法就不会收敛，除非从初始猜测[2.x.66]开始，足够接近非线性问题的解[2.x.67]。在实践中，我们并不总是有这样的初始猜测，因此采取完整的牛顿步骤（即使用[2.x.68]）往往是不可行的。

因此，一个常见的策略是，当迭代[2.x.69]离解[2.x.70]还很远时，在前几步使用较小的步长，当我们越来越接近时，使用较大的[2.x.71]值，直到最后我们可以开始使用全步[2.x.72]，因为我们已经足够接近解。当然，问题是如何选择[2.x.73]。基本上有两种广泛使用的方法：直线搜索和信任区域方法。

在这个程序中，我们简单地总是选择步长等于0.1。这确保了在手头的测试案例中，我们确实得到了收敛，尽管很明显，由于最终没有恢复到全步长，我们放弃了使牛顿方法如此吸引人的快速、二次收敛的方法。很明显，如果这个程序是为了解决更多的现实问题，我们最终必须解决这个问题。我们将在[1.x.57]中对这个问题作一些评论。


[1.x.58][1.x.59] 


总的来说，我们这里的程序在许多方面与[2.x.74]并无不同。主类的布局基本上是一样的。另一方面，[2.x.75]函数中的驱动算法是不同的，工作原理如下。 [2.x.76] [2.x.77] 从函数[2.x.78]开始，以这样的方式修改它，使[2.x.79]的值沿边界等于正确的边界值[2.x.80]（这发生在[2.x.81]）。设[2.x.82] .  [2.x.83]  

 [2.x.84] 通过在[2.x.87]上解决带有边界条件[2.x.86]的系统[2.x.85]来计算牛顿更新。 [2.x.88]  

 [2.x.89] 计算一个步长 [2.x.90] 。在这个程序中，我们总是设置 [2.x.91] 。为了便于以后的扩展，这发生在一个自己的函数中，即在 [2.x.92] .  [2.x.93]  

 [2.x.94] 解决方案的新近似值由 [2.x.95] .  [2.x.96]  

 [2.x.97] 如果[2.x.98]是5的倍数，那么细化网格，将解[2.x.99]转移到新的网格中，并设置[2.x.100]的值，以便沿边界有[2.x.101]（同样在[2.x.102]）。请注意，这并不是自动保证的，即使在网格细化之前我们已经有了[2.x.103]，因为网格细化会在网格中增加新的节点，当我们把旧的解决方案带到新的网格时，必须把旧的解决方案插值到新的节点。我们通过插值选择的数值可能接近于精确的边界条件，但一般来说，并不是正确的数值。 [2.x.104]  

 [2.x.105] 设置[2.x.106]并转到第二步。 [2.x.107] [2.x.108]。 

我们解决的测试案例选择如下。我们寻求在单位盘[2.x.109]上找到最小曲面的解决方案，其中曲面沿边界达到[2.x.110]的值。[1.x.60] [1.x.61]。


[1.x.62] [1.x.63]。




前面几个文件已经在前面的例子中讲过了，因此不再进一步评论。

[1.x.64] 



我们将在牛顿迭代之间使用自适应网格细化。要做到这一点，我们需要能够在新的网格上工作，尽管它是在旧的网格上计算出来的。SolutionTransfer类将解从旧网格转移到新网格。







[1.x.65] 



然后我们为这个程序打开一个命名空间，并从dealii命名空间导入所有的东西，就像以前的程序一样。

[1.x.66] 




[1.x.67] [1.x.68] 




类模板与 [2.x.111] 中的基本相同。 增加了三个内容。

- 有两个解决方案向量，一个用于牛顿更新 [2.x.112] ，另一个用于当前迭代 [2.x.113] 。

- [2.x.114]函数需要一个参数，表示这是否是第一次被调用。不同的是，第一次我们需要分配自由度并将[2.x.115]的解向量设置为正确的大小。接下来的几次，这个函数是在我们已经做了这些步骤之后，作为细化网格的一部分，在[2.x.116]中调用的。

- 然后我们还需要新的函数。 [2.x.117]负责正确设置解向量上的边界值，这在介绍的最后已经讨论过了。 [2.x.118] 是一个计算非线性（离散）残差规范的函数。我们用这个函数来监测牛顿迭代的收敛性。该函数以步长[2.x.119]为参数来计算[2.x.120]的残差。这是人们通常需要的步长控制，尽管我们在这里不会使用这个功能。最后，[2.x.121]计算每个牛顿迭代中的步长[2.x.122]。正如介绍中所讨论的，我们在这里使用一个固定的步长，并把实现一个更好的策略作为一个练习。







[1.x.69] 




[1.x.70] [1.x.71] 




边界条件的实现就像在 [2.x.123] 中一样。 它被选择为 [2.x.124] 。







[1.x.72] 




[1.x.73] [1.x.74] 。





[1.x.75] [1.x.76] 。




该类的构造函数和析构函数与前几篇教程中的相同。







[1.x.77] 




[1.x.78] [1.x.79] 




和以往一样，在setup-system函数中，我们设置有限元方法的变量。与[2.x.125]有相同的区别，因为在那里我们在每个细化周期中都要从头开始求解PDE，而在这里我们需要把以前的网格的解放到当前的网格上。因此，我们不能只是重设解向量。因此，传递给这个函数的参数表明我们是否可以分布自由度（加上计算约束）并将解向量设置为零，或者这在其他地方已经发生过了（特别是在[2.x.126]）。







[1.x.80] 



该函数的其余部分与 [2.x.127] 中相同。







[1.x.81] 




[1.x.82] [1.x.83] 。




这个函数的作用与前面的教程相同，当然，现在矩阵和右手边的函数取决于前一次迭代的解。正如介绍中所讨论的，我们需要使用牛顿更新的零边界值；我们在这个函数的末尾计算它们。   


该函数的顶部包含通常的模板代码，设置允许我们在正交点评估形状函数的对象，以及本地矩阵和向量的临时存储位置，以及在正交点的上一次解的梯度。然后我们开始在所有单元格上循环。

[1.x.84] 



对于线性系统的组装，我们必须获得前一个解在正交点的梯度值。有一个标准的方法：[2.x.128]函数接收一个代表定义在DoFHandler上的有限元场的向量，并评估这个场在FEValues对象最后被重新初始化的单元的正交点的梯度。然后将所有正交点的梯度值写入第二个参数中。

[1.x.85] 



有了这个，我们就可以对所有的正交点和形状函数进行积分循环。 在计算了正交点上旧解的梯度后，我们就可以计算这些点上的系数[2.x.129]。 然后，系统本身的组装看起来与我们一贯所做的相似，除了非线性项之外，将局部对象的结果复制到全局对象中也是如此。

[1.x.86] 



最后，我们从系统中移除挂起的节点，并对定义牛顿更新的线性系统应用零边界值 [2.x.130] 。

[1.x.87] 




[1.x.88] [1.x.89] 。




求解函数和以往一样。在求解过程结束时，我们通过设置[2.x.131] 更新当前的解决方案。

[1.x.90] 




[1.x.91] [1.x.92] 。




这个函数的第一部分与[2.x.132]中的内容相同 ... 然而，在细化网格后，我们必须将旧的解决方案转移到新的解决方案中，我们在SolutionTransfer类的帮助下完成这个工作。这个过程稍微有点复杂，所以让我们详细描述一下。

[1.x.93] 



然后我们需要一个额外的步骤：比如说，如果你标记了一个比它的邻居更细化的单元，而这个邻居没有被标记为细化，我们最终会在一个单元界面上跳过两个细化级别。 为了避免这些情况，库将默默地也要对邻居单元进行一次精炼。它通过在实际进行细化和粗化之前调用[2.x.133]函数来实现。 这个函数标志着一组额外的单元格进行细化或粗化，以执行像单悬节点规则这样的规则。 调用此函数后，被标记为细化和粗化的单元格正是那些将被实际细化或粗化的单元格。通常情况下，你不需要手工操作[2.x.134]为你做这个）。) 然而，我们需要初始化SolutionTransfer类，它需要知道最终将被粗化或细化的单元集，以便存储旧网格的数据并转移到新网格。因此，我们用手调用这个函数。

[1.x.94] 



有了这个方法，我们用现在的DoFHandler初始化一个SolutionTransfer对象，并将求解向量附加到它上面，然后在新网格上进行实际的细化和自由度的分配 

[1.x.95] 



最后，我们检索出插值到新网格上的旧解。由于SolutionTransfer函数实际上并不存储旧的解决方案的值，而是索引，我们需要保留旧的解决方案向量，直到我们得到新的内插值。因此，我们将新的数值写入一个临时的向量中，之后才将它们写入解决方案向量对象中。一旦我们有了这个解决方案，我们必须确保我们现在拥有的[2.x.135]实际上具有正确的边界值。正如在介绍的最后所解释的那样，即使细化前的解具有正确的边界值，也不会自动出现这种情况，因此我们必须明确地确保它现在具有。

[1.x.96] 



在新的网格上，有不同的悬挂节点，我们必须再次计算。为了确保对象中没有旧网格的悬挂节点，首先要清除它。 为了安全起见，我们还要确保当前解决方案的向量条目满足悬挂节点的约束条件（参见SolutionTransfer类文档中的讨论，了解为什么必须这样做）。

[1.x.97] 



我们通过更新所有剩余的数据结构来结束这个函数，向[2.x.136]表明这不是第一次了，它需要保留解向量的内容。

[1.x.98] 




[1.x.99] [1.x.100]。




下一个函数确保解向量的条目尊重我们问题的边界值。 在细化网格后（或刚开始计算），边界上可能会出现新的节点。这些节点的数值只是从之前的网格中插值出来的（或者只是零），而不是正确的边界值。这可以通过将所有的边界节点明确设置为正确的值来解决。

[1.x.101] 




[1.x.102] [1.x.103] 。




为了监测收敛性，我们需要一种方法来计算（离散）残差的规范，即在介绍中讨论的向量[2.x.137]与[2.x.138]的规范。事实证明，（尽管我们在当前版本的程序中没有使用这个功能）在确定最佳步长时需要计算残差[2.x.139]，因此这就是我们在这里实现的：该函数将步长[2.x.140]作为一个参数。当然，原始的功能是通过传递一个零作为参数得到的。   


在下面的函数中，我们首先为残差设置一个向量，然后为评估点设置一个向量 [2.x.141] 。接下来是我们用于所有积分操作的模板代码。

[1.x.104] 



实际的计算与 [2.x.142] 中的计算差不多。我们首先评估[2.x.143]在正交点的梯度，然后计算系数[2.x.144]，然后将其全部插入残差公式中。

[1.x.105] 



在这个函数的最后，我们还必须处理悬挂节点的约束和边界值的问题。关于后者，我们必须将残差向量中对应于位于边界的自由度的所有条目的元素设置为零。原因是，由于那里的解的值是固定的，它们当然不是 "真正的 "自由度，因此，严格来说，我们不应该在残差向量中为它们集合条目。然而，正如我们一直所做的那样，我们想在每个单元上做完全相同的事情，因此我们并不想在上面的积分中处理某个自由度是否位于边界的问题。相反，我们将简单地在事后将这些条目设置为零。为此，我们需要确定哪些自由度实际上属于边界，然后在所有这些自由度上进行循环，并将剩余条目设置为零。这发生在以下几行中，我们已经在[2.x.145]中看到了使用DoFTools命名空间的适当函数。

[1.x.106] 



在函数的最后，我们返回残差的常数。

[1.x.107] 




[1.x.108] [1.x.109] 




正如介绍中所讨论的，如果我们总是采取完整的步骤，即计算[2.x.146]，牛顿的方法经常不收敛。相反，我们需要一个阻尼参数（步长） [2.x.147] 并设置 [2.x.148] 。这个函数是用来计算 [2.x.149] 的。   


在这里，我们简单地总是返回0.1。这当然是一个次优的选择：理想情况下，人们想要的是，当我们越来越接近解的时候，步长变成1，这样我们就可以享受牛顿方法的快速二次收敛。我们将在下面的结果部分讨论更好的策略。

[1.x.110] 




[1.x.111][1.x.112] 。




这个从`run()`调用的最后一个函数以图形形式输出当前的解（和牛顿更新），作为VTU文件。它与之前教程中使用的完全相同。

[1.x.113] 




[1.x.114][1.x.115] 。




在运行函数中，我们建立第一个网格，然后有牛顿迭代的顶层逻辑。   


正如介绍中所描述的，领域是围绕原点的单位圆盘，创建方式与 [2.x.150] 中所示相同。网格被全局细化了两次，后来又进行了几次自适应循环。   


在开始牛顿循环之前，我们还需要做一些设置工作。我们需要创建基本的数据结构，并确保第一个牛顿迭代已经有了正确的边界值，这在介绍中已经讨论过了。

[1.x.116] 



牛顿迭代接下来开始。我们一直迭代到上一次迭代结束时计算的残差（规范）小于[2.x.151]，正如在 "do { ... } while "循环的末尾进行检查。因为我们没有一个合理的值来初始化这个变量，我们只是使用可以表示为 "双 "的最大值。

[1.x.117] 



在每个网格上，我们正好做了五个牛顿步骤。我们在这里打印初始残差，然后在这个网格上开始迭代。         


在每个牛顿步骤中，首先要计算系统矩阵和右手边，然后我们存储右手边的准则作为残差，以便在决定是否停止迭代时进行检查。然后我们求解线性系统（该函数也会更新[2.x.152]），并在这个牛顿步骤结束时输出残差的规范。         


在这个循环结束后，我们还以图形的形式输出当前网格上的解，并增加网格细化循环的计数器。

[1.x.118] 




[1.x.119][1.x.120] 。




最后是主函数。这遵循所有其他主函数的方案。

[1.x.121] 

[1.x.122][1.x.123]。




该程序的输出看起来如下。

[1.x.124] 



很明显，该方案收敛了，即使不是非常快。我们将在下面再来讨论加速该方法的策略。

我们可以在每一组五次牛顿迭代之后，即在我们近似求解的每个网格上，直观地看到求解。这就产生了以下一组图像。

 [2.x.153]  

可以清楚地看到，在每次细化之后，解决方案都会使表面最小化。解决方案收敛于人们想象中的肥皂泡，它位于一个像边界一样弯曲的线环内。同样可以看出，每次细化后，边界是如何被平滑化的。在粗略的网格上，边界看起来并不像正弦，而网格越细越像。

网格主要是在边界附近被细化的，在那里解的增加或减少很强烈，而在域的内部被粗化，在那里没有什么有趣的事情发生，因为解没有什么变化。这里显示的是第九个解和网格。

 [2.x.154]  




[1.x.125] [1.x.126][1.x.127]。


该程序显示了一个非线性静止问题的求解器的基本结构。然而，它的收敛速度不是特别快，这是有原因的。

- 该程序总是采取0.1的步长。这就排除了快速的二次收敛，而牛顿方法通常就是为这种收敛而选择的。

- 它没有将非线性迭代与网格细化迭代联系起来。

很明显，一个更好的程序必须解决这两点。我们将在下文中讨论它们。


[1.x.128][1.x.129] 


牛顿方法有两个众所周知的特性。

- 它不可能从任意选择的起点收敛。相反，一个起点必须足够接近解决方案以保证收敛。然而，我们可以通过使用[1.x.130] 0<[2.x.155]的阻尼迭代来扩大牛顿方法的收敛区域。

- 如果(i)步长选择为[2.x.156]，它就会表现出快速的二次收敛，(ii)事实上在选择步长的情况下它确实收敛了。

这两个观察的结果是，一个成功的策略是在初始迭代中选择[2.x.157]，直到迭代接近到可以用全步长收敛，此时我们要切换到[2.x.158] 。问题是如何以自动方式选择[2.x.159]，以满足这些标准。

我们不想在这里回顾关于这个问题的文献，只是简单地提到，有两种基本的方法来解决这个问题：回溯线搜索和信任区域方法。前者更广泛地应用于偏微分方程，基本上做了以下工作。

- 计算一个搜索方向 

- 看[2.x.160]与[2.x.161]产生的残差是否比[2.x.162]单独产生的残差 "大大缩小"。

- 如果是，那么就采取[2.x.163] 。

- 如果不是，试试用[2.x.164]的残差是否 "大大减少"。

- 如果是，那么就采取[2.x.165]。

- 如果不是，则尝试用[2.x.166]来测试残差是否 "大大减少"。

- 诸如此类。当然，我们可以选择其他因素[2.x.167]，而不是上面选择的[2.x.168]，为[2.x.169] 。很明显，"回溯 "一词的来源是：我们尝试一个长的步骤，但如果这不起作用，我们就尝试一个更短的步骤，并且越来越短，等等。函数[2.x.170]的编写方式正是为了支持这种用例。

我们是否接受一个特定的步长[2.x.171]取决于我们如何定义 "相当小"。有许多方法可以做到这一点，但在不详细说明的情况下，我们只提一下，最常见的是使用沃尔夫和阿米约-戈尔德斯坦条件。对于这些，人们可以证明如下。

- 总是有一个满足条件的步长[2.x.172]，也就是说，只要问题是凸的，迭代就不会卡住。

- 如果我们足够接近解决方案，那么条件就允许[2.x.173]，从而实现二次收敛。

我们在此不再赘述，而是将这种算法的实现作为一个练习。然而，我们注意到，如果实施得当，大多数合理的非线性问题可以在5到15次牛顿迭代中解决，达到工程精度&mdash；比我们目前版本的程序所需要的要少得多，这是一个普遍现象。

关于全局化方法的更多细节，包括回溯，可以在 [2.x.174] 和 [2.x.175] 中找到。

然而，非常值得一提的是，在实践中，高效非线性求解器的实现与高效有限元方法的实现一样复杂。我们不应该试图通过自己实现所有的必要步骤来重新发明车轮。相反，就像在deal.II等库上建立有限元求解器一样，人们应该在[SUNDIALS](https://computing.llnl.gov/projects/sundials)等库上建立非线性求解器。事实上，deal.II有与SUNDIALS的接口，特别是通过[2.x.176]类与它的非线性求解器子包KINSOL的接口。将目前的问题建立在该接口上并不是很困难。




[1.x.131][1.x.132] 


我们目前在每个网格上正好做5次迭代。但这是最优的吗？人们可以提出以下问题。

- 也许在初始网格上做更多的迭代是值得的，因为那里的计算很便宜。

- 另一方面，我们不希望在每个网格上做太多的迭代：是的，我们可以在每个网格上将残差赶到零，但这只意味着非线性迭代误差远远小于离散化误差。

- 我们应该用更高或更低的精度来解决每个牛顿步骤中的线性系统吗？

最终，这归结为我们需要将当前网格上的离散化误差与我们希望在特定网格上通过牛顿迭代实现的非线性残差，以及我们希望在每个牛顿迭代中通过CG方法实现的线性迭代结合起来。

如何做到这一点，同样也不是完全微不足道的，我们再次把它作为一个未来的练习。[1.x.133][1.x.134][2.x.177]  

 [2.x.178] 
