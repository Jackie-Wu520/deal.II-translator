 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15] 

 [2.x.3]  

[1.x.16] 

[1.x.17] [1.x.18] [1.x.19] 


无矩阵算子评估使高阶多项式基的离散化得到非常有效的实现，这是由于一种叫做和因子化的方法。这个概念已经在[2.x.4]和[2.x.5]的教程程序中介绍过。在这个教程程序中，我们将这些概念扩展到包括面积分的非连续Galerkin（DG）方案，这是一类高阶特别普遍的方法。

无矩阵评估的基本思想与连续元素的评估相同。迭代求解器或多网格平滑器中出现的矩阵-向量乘积不是由经典的稀疏矩阵核来实现的，而是通过对底层积分的实时评估来隐含应用。对于用张量积正交规则集成的张量积形状函数，通过使用和因子化技术，这种评估特别有效，它将最初的[2.x.6]插值操作分解为[2.x.9]维中涉及[2.x.8]度的相关形状函数的[2.x.10]正交点的[2.x.11]一维操作，每个成本[2.x.12]。在三维中，这将复杂度降低了 [2.x.13] 的两个次方。当以每个自由度的复杂度来衡量时，复杂度是[2.x.14]的多项式程度。由于DG中存在面积分，也由于对正交点的操作涉及更多的内存传输，两者的规模都是[2.x.15]，观察到的复杂度往往是中等[2.x.16]的常数。这意味着高阶方法可以用每秒自由度的相同吞吐量来评估低阶方法。

关于算法的更多信息可参见Martin Kronbichler和Katharina Kormann的预印本[2.x.17] [1.x.20]，arXiv:1711.03590。

[1.x.21][1.x.22] 。


在本教程中，我们以无矩阵的DG框架为例，对拉普拉斯进行内部惩罚离散化，即与[2.x.18]教程中使用的方案相同。拉普拉斯的离散化是由以下弱形式给出的 

[1.x.23] 

其中[2.x.19]表示数量[2.x.20]从两个相关单元[2.x.21]和[2.x.22]的定向跳跃，[2.x.23]是两边的平均值。

方程中的项代表分项积分后的单元积分，由于分项积分和插入平均通量而在元素界面产生的原始一致性项，为恢复基础矩阵的对称性而添加的邻接一致性项，以及系数为[2.x.24]的惩罚项，其大小等于单元在面的法线方向上的长度乘以[2.x.25]，见[2.x.26] 。惩罚项的选择是为了使逆估计成立，并且最终的弱形式是强制性的，即在离散设置中是正定的。邻接一致性项和惩罚项涉及元素界面上的跳跃[2.x.27]，这在解析解中消失了[2.x.28] 。因此，这些条款与原始PDE是一致的，确保该方法可以保留最佳收敛顺序。

在下面的实现中，我们通过将法向量[2.x.29]从跳跃项移到导数上，形成[1.x.24]形式的导数[2.x.30]来实现上述的弱形式。这使得在正交点上的实现稍微有效一些，因为我们只需要处理标量项而不是张量，而且在数学上是等价的。

对于边界条件，我们使用所谓的镜像原理，通过从内部解[2.x.32]结合给定的边界数据进行外推来定义[1.x.25]外部值[2.x.31]，在迪里希特边界设置[2.x.33]和[2.x.34]，在纽曼边界设置[2.x.35]和[2.x.36]，对于给定的迪里希特值[2.x.37] 和纽曼值[2.x.38] 。然后将这些表达式插入上述弱形式中。涉及已知量[2.x.39]和[2.x.40]的贡献最终被移到右手边，而未知值[2.x.41]被保留在左手边，对矩阵项的贡献与内部面类似。经过这些操作，得到了与[2.x.42]中相同的弱形式。

[1.x.26][1.x.27] 


deal.II的无矩阵框架为实现上述离散化方程的作用提供了必要的基础设施。相对于我们在[2.x.44]和[2.x.45]中使用的[2.x.43]，我们现在用[2.x.46]建立一个代码，它需要三个函数指针，一个用于单元积分，一个用于内面积分，一个用于边界面积分（与[2.x.47]教程程序中使用的MeshWorker的设计相类似）。在这三个函数中的每一个，我们都会在正交点上实现各自的条款。对于向量项与正交点上的数值和梯度之间的插值，我们使用FEEvaluation类来处理单元贡献，FEFaceEvaluation类来处理面贡献。这些函数的基本用法已经在[2.x.48]教程程序中得到了广泛的讨论。

在[2.x.49]中，所有的内部面都正好被访问一次，所以必须确保计算测试函数[2.x.50]和[2.x.51]的贡献。考虑到两边的测试函数确实是独立的，上面的弱形式实际上意味着我们在用测试函数的法向导数进行测试时，向名为`phi_inner`和`phi_outer`的FEFaceEvaluation对象提交相同的贡献，而在用测试函数的值进行测试时，则提交相反符号的值，因为后者由于跳跃项而涉及相反符号。对于不同细化程度的单元之间的面，从细化的一侧进行整合，FEFaceEvaluation自动执行内插到粗略一侧的子面。因此，一个悬挂的节点永远不会明确地出现在用户实现的弱形式中。

每个面被精确访问一次的事实也适用于那些在不同处理器之间的子域边界的面，当用MPI并行化时，一个单元属于一个处理器，一个属于另一个。在[2.x.52]中的设置将面分成了两边，最终只报告了[2.x.53]和[2.x.54]中分别实际处理的面。注意，与[2.x.55]中讨论的单元积分相类似，deal.II在几个面上应用矢量化，以使用SIMD，在我们称之为[1.x.28]的东西上工作，只需一条指令。面的批次与单元的批次是独立的，尽管处理面的积分的时间与处理各自单元的积分的时间保持一致，以提高数据的定位性。

这个程序的另一个新特点是，我们不再像[2.x.56]或[2.x.57]那样将向量访问从求值和积分步骤中分离出来，而是分别调用组合函数[2.x.58]和[2.x.59]。这对面积分很有用，因为根据面的评估内容，并非所有单元的向量项都必须首先被触及。例如，考虑到节点元素FE_DGQ的情况，其节点点在元素表面。如果我们对面的形状函数值感兴趣，只有[2.x.60]个自由度以非微不足道的方式对它们有贡献（用更专业的方式来说，只有[2.x.61]个形状函数在面有非零支持，并且对[2.x.62]个自由度返回真值。 当与单元的[2.x.63]个自由度相比，这要少一个幂。

现在我们当然不只对函数值感兴趣，还对单元格上的导数感兴趣。幸运的是，在deal.II中，有一个元素将这种减少访问的特性也扩展到面的导数上，即FE_DGQHermite元素。

[1.x.29][1.x.30] 。


FE_DGQHermite元素属于FE_DGQ元素家族，即其形状函数是一维多项式的张量乘积，该元素是完全不连续的。与通常的FE_DGQ元素中的节点特征相反，FE_DGQHermite元素是一个基于Hermite-like概念的节点贡献和导数贡献的混合物。基础多项式类是[2.x.64]，可以总结如下。对于三次多项式，我们用两个多项式来表示单位区间左端的函数值和第一次导数， [2.x.65] ，用两个多项式来表示函数值和第一次导数以及单位区间的右端， [2.x.66] 。在相反的两端，形状函数的值和一阶导数都是零，确保四个基础函数中只有两个对各自端部的值和导数有贡献。然而，我们偏离了经典的Hermite内插法，没有严格地为值和一导数指定一个自由度，而是允许一导数是第一和第二形状函数的线性组合。这样做是为了改善插值的调节。另外，当度数超过三时，我们以类似拉格朗日的方式在元素内部增加节点点，并在[2.x.67]和[2.x.68]这两个点上结合双零。这些额外节点的位置是由一些雅可比多项式的零点决定的，在类的描述中已经解释过 [2.x.69] 。 

使用这个元素，我们只需要访问[2.x.70]的自由度来计算一个面上的值和导数。检查是否满足Hermite属性是在[2.x.71]和[2.x.72]中透明地完成的，这些检查基础的类型并尽可能地减少对数据的访问。显然，如果我们将[2.x.73]与[2.x.74]分开，这将是不可能的，因为我们需要读取的条目数量取决于导数的类型（只有值，一阶导数，等等），因此必须交给`read_dof_values()`。

这种优化不仅对计算面积分有用，而且对MPI鬼层交换也有用。在一个天真的交换中，如果一个单元负责计算面的贡献，我们就需要将该单元的所有自由度发送给另一个处理器。由于我们知道在用FEFaceEvaluation进行的评估中只有部分自由度被触及，所以自然只交换相关的自由度。当与[2.x.76]结合时，[2.x.75]函数支持选定的数据交换。为了实现这一点，我们需要告诉循环我们要对脸部做什么样的评价，使用[2.x.77]类型的参数，正如在下面[2.x.78]的实现中可以看到。在这种情况下，数据交换的方式如下。矢量中的幽灵层数据仍然假装代表所有的自由度，这样，FEFaceEvaluation可以继续读取数值，就像单元格是本地拥有的一样。数据交换例程负责将数据打包和解包成这种格式的任务。虽然这听起来很复杂，但我们将在下面的结果部分显示，通过与不指定面孔上的数据访问的基线代码进行性能比较，这确实是值得的。

[1.x.31][1.x.32] 。


按照[2.x.79]程序的传统，我们再次用共轭梯度求解器内的几何多网格预处理器来解决泊松问题。在这个教程程序中，我们没有计算对角线并使用基本的PreconditionChebyshev作为平滑器，而是选择了一种不同的策略。我们实现了一个块状Jacobi预处理程序，其中块状指的是一个单元上的所有自由度。我们没有在预处理程序中建立完整的单元格矩阵并应用其LU因子化（或逆），这种操作将受到严重的内存带宽限制，因此速度相当慢；我们通过一种特殊的技术，即快速对角线化方法，对块的逆进行近似。

该方法的理念是利用单元矩阵的结构。对于在笛卡尔网格上离散的恒定系数的拉普拉斯，单元矩阵[2.x.80]可以写为 

[1.x.33] 

在二维和 

[1.x.34] 

在三维中可以写成[1.x.34]。矩阵[2.x.81]和[2.x.82]表示一维拉普拉斯矩阵（包括与当前单元值[2.x.83]和[2.x.84]相关的单元和面项），[2.x.85]和[2.x.86]是质量矩阵。请注意，一旦单元上有非恒定系数或几何形状不再恒定，这种简单的张量乘积结构就会消失。我们提到，类似的设置也可以用来用这个最终的张量积形式的矩阵来替代计算的积分，这将把算子评估的操作减少到一半以下。然而，考虑到这只适用于直角坐标单元和恒定系数，这是一个相当狭窄的情况，我们避免继续探讨这个想法。

有趣的是，由于1964年[1.x.35]引入的方法，矩阵[2.x.87]的精确逆值可以通过张量积找到。

[1.x.36] 

其中[2.x.88]是给定张量方向上广义特征值问题的特征向量矩阵 [2.x.89] 。

[1.x.37] 

和 [2.x.90] 是代表广义特征值的对角线矩阵 [2.x.91] 。请注意，向量[2.x.92]是这样的：它们同时对角化[2.x.93]和[2.x.94]，即[2.x.95]和[2.x.96]。

deal.II库实现了一个使用这个概念的类，叫做TensorProductMatrixSymmetricSum。

在本程序中，我们坚持使用常数系数和笛卡尔网格，尽管基于张量积的近似版本对于更普遍的网格仍然是可能的，而且算子评估本身当然也是通用的。另外，我们也不关心自适应网格，因为多网格算法需要获取不同细化边缘的通量矩阵，如[2.x.97]中所解释的。然而，我们所做的一件事是仍然将我们的块状Jacobi预处理程序包裹在PreconditionChebyshev中。这个类使我们不必寻找适当的松弛参数（对于块-雅各比平滑器来说，二维的松弛参数约为0.7，三维的松弛参数约为0.5），并且通常比普通的雅各比平滑器增加了一些平滑效率，因为当设置切比雪夫多项式的度数为1或2时，它可以降低解的时间。

请注意，块状雅可比平滑法有一个额外的好处：快速对角线化方法也可以解释为从FE_DGQHermite的Hermite-like多项式转变为一个单元拉普拉斯是对角线的基础。因此，它抵消了基础的影响，无论我们使用FE_DGQHermite还是FE_DGQ，都会得到相同的迭代次数。这与使用只有对角线的PreconditionChebyshev类（点-Jacobi方案）形成了对比，在这种情况下，FE_DGQ和FE_DGQHermite的表现确实不同，FE_DGQ需要的迭代次数比FE_DGQHermite少2-5次，尽管对类似Hermite的形状函数做了修改以确保良好的条件。[1.x.38][1.x.39] 。

包含文件与[2.x.98]中的文件基本相同，只是用FE_DGQHermite类代替了FE_Q。所有关于面积分的无矩阵计算功能已经包含在`fe_evaluation.h`中。

[1.x.40] 



与[2.x.99]一样，为了简单起见，我们将维数和多项式程度作为常数收集在程序的顶部。与[2.x.100]不同的是，这次我们选择了一个真正的高阶方法，度数为8，任何不使用和因式分解的实现都会变得非常慢，而使用MatrixFree的实现则提供了与度数为2或3时基本相同的效率。此外，本教程程序中的所有类都是模板化的，因此，通过在`main()`函数中添加适当度数的实例，可以很容易地在运行时从输入文件或命令行参数中选择度数。







[1.x.41] 




[1.x.42][1.x.43] 。




与[2.x.101]相类似，我们定义了一个分析解，并试图用我们的离散化来重现。由于本教程的目的是展示无矩阵方法，我们选择了一个最简单的可能性，即一个余弦函数，其导数对我们来说足够简单，可以通过分析计算。再往下看，我们在这里选择的波数2.4将与[2.x.102]-方向的域范围即2.5相匹配，这样我们在[2.x.103]包括[2.x.104]或余弦的三个整波旋转处得到一个周期解。第一个函数定义了解和它的梯度，分别用于表达Dirichlet和Neumann边界条件的解析解。此外，一个代表解的负拉普拉斯的类被用来表示右手边（强制）函数，我们用它来匹配离散化版本中的给定分析解（制造解）。







[1.x.44] 




[1.x.45][1.x.46] 。




LaplaceOperator "类与 [2.x.105] 中的相应类类似。一个重要的区别是，我们没有从[2.x.106]中派生出这个类，因为我们想呈现[2.x.107]的一些额外特性，这些特性在通用类[2.x.108]中是没有的。 我们从Subscriptor类中派生出这个类，以便能够在Chebyshev预处理程序中使用该运算器，因为该预处理程序通过SmartPointer存储底层矩阵。   


鉴于我们手工实现了一个完整的矩阵接口，我们需要添加一个`initialize()`函数，一个`m()`函数，一个`vmult()`函数，以及一个`Tvmult()`函数，这些都是之前由 [2.x.109] 我们的LaplaceOperator还包含一个成员函数`get_penalty_factor()`，根据 [2.x.110] 集中选择对称内部惩罚方法中的惩罚参数 。







[1.x.47] 



`%PreconditionBlockJacobi`类定义了我们对这个问题的自定义预处理程序。与基于矩阵对角线的[2.x.111]相反，我们在这里通过使用介绍中讨论的所谓快速对角线化方法，计算出非连续Galerkin方法中对角线块的近似反演。







[1.x.48] 



这个独立的函数在 "LaplaceOperator "和"%PreconditionBlockJacobi "类中都被用来调整重影范围。这个函数是必要的，因为`vmult()`函数所提供的一些向量没有用包括正确的鬼魂条目布局的[2.x.112]来正确初始化，而是来自MGTransferMatrixFree类，该类对无矩阵类的鬼魂选择没有概念。为了避免索引混乱，我们必须在对这些向量进行实际操作之前调整鬼域。由于向量在多网格平滑器和传输类中被保留下来，一个曾经被调整过重影范围的向量在对象的整个生命周期中都会保持这种状态，所以我们可以在函数的开始使用一个快捷方式来查看分布式向量的分区器对象（以共享指针的形式存储）是否与MatrixFree所期望的布局相同，它存储在一个通过[2.x.113]访问的数据结构中 ]，其中的0表示从中提取的DoFHandler编号；我们在MatrixFree中只使用一个DoFHandler，所以这里唯一有效的编号是0。







[1.x.49] 



接下来的五个函数用于清除和初始化`LaplaceOperator`类，返回持有MatrixFree数据容器的共享指针，以及正确初始化向量和运算符的大小，与[2.x.114]或者说[2.x.115]的内容相同。 

[1.x.50] 



这个函数在向量`src`上实现了LaplaceOperator的动作，并将结果存储在向量`dst`中。与[2.x.116]相比，这个调用有四个新特性。   


第一个新特征是上面提到的 "adjust_ghost_range_if_necessary "函数，该函数是为了使向量符合单元和面函数中FEEvaluation和FEFaceEvaluation所期望的布局。   


第二个新特征是我们没有像[2.x.117]中那样实现`vmult_add()`函数（通过虚拟函数[2.x.118]，而是直接实现`vmult()`功能。由于单元和面的积分都将和到目的向量中，我们当然必须在某处将向量归零。对于DG元素，我们有两个选择&ndash；一个是在下面的`apply_cell`函数中使用[2.x.119]而不是[2.x.120]。这是因为MatrixFree中的循环布局是这样的：单元积分总是在面积分之前触及给定的矢量条目。然而，这实际上只适用于完全不连续的基数，其中每个单元都有自己的自由度，不与邻近的结果共享。另一种设置，即这里选择的设置，是让[2.x.121]来处理向量的归零问题。这可以被认为是简单地在代码中调用`dst = 0;`。对于像[2.x.122]这样的支持性向量来说，实现起来就比较麻烦了，因为我们的目标是不要一次就把整个向量清零。在足够小的几千个向量项上进行归零操作的好处是，在[2.x.123]和[2.x.124]中再次访问之前，被归零的向量项会保留在缓存中，因为无矩阵运算符的评估真的很快，仅仅归零一个大的向量就会相当于运算符评估时间的25%，而我们显然希望避免这种代价。这种将向量归零的选项也可用于[2.x.125]和连续基数，尽管在[2.x.126]或[2.x.127]的教程程序中没有使用它。   


第三个新特征是我们提供在单元格、内面和边界面计算的函数的方式。MatrixFree类有一个叫做`loop'的函数，它接收三个函数指针，分别指向三种情况，允许分开实现不同的东西。正如在[2.x.128]中所解释的，这些函数指针可以是[2.x.129]对象或类的成员函数。在这种情况下，我们使用成员函数的指针。   


最后一个新特性是可以给[2.x.130]类型的最后两个参数，这个类将面积分的数据访问类型传递给并行向量的MPI数据交换例程[2.x.132]和[2.x.133]。其目的是不发送相邻元素的所有自由度，而是将数据量减少到手头计算真正需要的程度。数据交换是一个真正的瓶颈，特别是对于高自由度的DG方法来说，因此一个更严格的交换方式往往是有益的。枚举字段[2.x.134]可以取值`none`，这意味着根本不做面的积分，这与[2.x.135]的值`values`类似，意味着只在面上使用形状函数值（但不使用导数），而值`gradients`则意味着除了值之外还访问面的一导数。值 "未指定 "意味着所有自由度将被交换给位于处理器边界的面，并指定在本地处理器上进行处理。   


为了了解如何减少数据，想想节点元素FE_DGQ的情况，节点点在元素表面，在一个单元的[2.x.139]自由度中，只有[2.x.136]自由度对一个面的多项式[2.x.137]空间维度的值有贡献。类似的减少也可以用于内部惩罚方法，该方法对面的数值和一阶导数进行评估。当在一维中使用类似Hermite的基时，最多只有两个基函数对值和导数有贡献。FE_DGQHermite类实现了这一概念的张量乘积，在介绍中已经讨论过。因此，每个面只需交换[2.x.140]个自由度，一旦[2.x.141]个自由度大于4或5个，这显然是一种胜利。请注意，FE_DGQHermite的这种减少的交换在具有弯曲边界的网格上也是有效的，因为导数是在参考元素上取的，而几何体只在内部混合它们。因此，这与试图用连续的Hermite型形状函数获得[2.x.142]的连续性是不同的，在这种情况下，非笛卡尔的情况会大大改变情况。显然，在非笛卡尔网格上，导数还包括超出法向导数的形状函数的切向导数，但这些也只需要元素表面的函数值。如果元素不提供任何压缩，循环会自动交换受影响单元的所有条目。







[1.x.51] 



由于拉普拉斯是对称的，`Tvmult()`（多网格平滑界面需要）操作被简单地转发给`vmult()`的情况。







[1.x.52] 



单元操作与 [2.x.143] 非常相似。不过我们在这里不使用系数。第二个区别是，我们用一个单一的函数调用[2.x.146]代替了[2.x.144]后面的两个步骤，该函数内部调用了两个单独方法的序列。同样，[2.x.147]实现了[2.x.148]之后的[2.x.149]的序列。 在这种情况下，这些新函数只是节省了两行代码。然而，我们用它们来与FEFaceEvaluation进行类比，在那里它们更重要，如下所述。







[1.x.53] 



面部操作实现了与[2.x.150]相类似的内部惩罚方法的条款，正如在介绍中所解释的。我们需要两个评估器对象来完成这个任务，一个用于处理来自内部面的两边之一的单元格的解，另一个用于处理来自另一边的解。面积分的评价器被称为FEFaceEvaluation，并在构造函数的第二个槽中接受一个布尔参数，以指示评价器应属于两边中的哪一边。在FEFaceEvaluation和MatrixFree中，我们称两边中的一边为 "内部"，另一边为 "外部"。`外部'这个名字是指两边的评价器将返回相同的法向量。对于 "内部 "一侧，法向量指向外部，而另一侧则指向内部，并且与该单元的外部法向量相对应。除了新的类名之外，我们再次得到了一系列的项目，与[2.x.151]中讨论的类似，但在这种情况下是针对内部面的。请注意，MatrixFree的数据结构形成了面的批次，类似于单元积分的单元批次。一批中的所有面涉及不同的单元格编号，但在参考单元格中具有相同的面编号，具有相同的细化配置（无细化或相同的子面）和相同的方向，以保持SIMD操作的简单和高效。   


请注意，除了法线方向的逻辑决定外，内部与外部没有任何隐含的意义，这在内部是相当随机的。我们绝对不能依赖分配内部与外部标志的某种模式，因为这个决定是为了MatrixFree设置例程中的访问规则性和统一性而做出的。由于大多数正常的DG方法都是保守的，也就是说，通量在接口的两边看起来都是一样的，所以如果内部/外部标志被调换，法向量得到相反的符号，那么数学是不会改变的。







[1.x.54] 



在给定的一批面，我们首先更新指向当前面的指针，然后访问向量。如上所述，我们将向量访问与评估结合起来。在面积分的情况下，对于FE_DGQHermite基础的特殊情况，可以减少对向量的数据访问，正如上面解释的数据交换。由于[2.x.153]单元自由度中只有[2.x.152]被非零值或形状函数的导数所乘，这种结构可以被用于评估，大大减少了数据访问。减少数据访问不仅是有益的，因为它减少了飞行中的数据，从而有助于缓存，而且当从单元格索引列表中相距较远的单元格中收集数值时，对面的数据访问往往比对单元格积分更不规则。

[1.x.55] 



接下来的两条语句是计算内部惩罚法的惩罚参数。正如介绍中所解释的，我们希望有一个像[2.x.154]那样的长度[2.x.155]的法线的缩放。对于一般的非笛卡尔网格，这个长度必须由反雅各布系数乘以实坐标的法向量的乘积来计算。从这个 "dim "分量的向量中，我们必须最终挑选出与参考单元的法线方向一致的分量。在MatrixFree中存储的几何数据中，雅各布式中的分量被应用，使得后一个方向总是最后一个分量`dim-1`（这很有利，因为参考单元的导数排序可以与面的方向无关）。这意味着我们可以简单地访问最后一个分量`dim-1`，而不必在`data.get_face_info(face).internal_face_no`和`data.get_face_info(face).exterior_face_no`中查找本地面数。最后，我们还必须取这些因素的绝对值，因为法线可能指向正或负的方向。

[1.x.56] 



在正交点的循环中，我们最终计算了对内部惩罚方案的所有贡献。根据介绍中的公式，测试函数的值被乘以解决方案中的跳跃乘以惩罚参数和实空间中的法线导数的平均值的差值。由于内侧和外侧的两个评估器由于跳跃而得到不同的符号，我们在这里用不同的符号传递结果。测试函数的正态导数会被内侧和外侧的解决方案中的负跳跃所乘。这个术语，被称为邻接一致性术语，根据其与原始一致性术语的关系，在代码中还必须包括[2.x.156]的因子，由于测试函数槽中的平均数，它得到了二分之一的因子。

[1.x.57] 



一旦我们完成了正交点的循环，我们就可以对面的积分循环进行和因数化操作，并使用`integrate_scatter`函数，将结果加到结果向量中。`scatter'这个名字反映了使用与`gather_evaluate'相同的模式将矢量数据分布到矢量中的分散位置。像以前一样，整合+写操作的组合允许我们减少数据访问。

[1.x.58] 



边界面函数大体上沿用了内部面函数。唯一的区别是，我们没有一个单独的FEFaceEvaluation对象为我们提供外部值 [2.x.157] ，但我们必须从边界条件和内部值中定义它们 [2.x.158] 。正如介绍中所解释的，我们在Dirichlet边界上使用[2.x.159]和[2.x.160]，在Neumann边界上使用[2.x.161] 和[2.x.162]。由于这个操作实现了同质部分，即矩阵-向量乘积，我们必须在这里忽略边界函数[2.x.163]和[2.x.164]，并在[2.x.165]中把它们加到右手边 注意，由于通过[2.x.167]把解[2.x.166]扩展到外部，我们可以保持所有因子[2.x.168]与内表面函数相同，也请看[2.x.169]中的讨论。   


在这一点上，有一个陷阱。下面的实现使用一个布尔变量`is_dirichlet`来切换Dirichlet和Neumann情况。然而，我们解决的问题是，我们还想在一些边界上施加周期性的边界条件，即沿着[2.x.170]方向的边界。人们可能会问，这里应该如何处理这些条件。答案是MatrixFree会自动将周期性边界视为技术上的边界，即两个相邻单元的解值相遇的内面，必须用适当的数值通量来处理。因此，周期性边界上的所有面将出现在`apply_face()`函数中，而不是这个函数中。







[1.x.59] 



接下来我们转向预处理程序的初始化。正如介绍中所解释的，我们想从一维质量和拉普拉斯矩阵的乘积中构造一个（近似的）单元矩阵的逆。我们的首要任务是计算一维矩阵，我们通过首先创建一个一维有限元来实现。在这里，我们没有预见到FE_DGQHermite<1>，而是从DoFHandler获得有限元的名称，用1替换[2.x.171]参数（2或3）来创建一个一维名称，并通过使用FETools来构造一维元素。







[1.x.60] 



至于在单元元素上计算一维矩阵，我们简单地写下在矩阵的行和列以及正交点上的典型装配程序会做什么。我们一劳永逸地选择相同的拉普拉斯矩阵，对内部面使用系数0.5（但可能由于网格的原因，在不同方向上的缩放比例不同）。因此，我们在Dirichlet边界（正确的系数应该是导数项为1，惩罚项为2，见[2.x.172]）或在Neumann边界（系数应该为0）犯了一个小错误。由于我们只在多网格方案中使用这个类作为平滑器，这个错误不会有任何重大影响，只是影响了平滑的质量。

[1.x.61] 



接下来的两个语句所集合的左右边界项似乎有一些任意的符号，但这些都是正确的，可以通过查看[2.x.173]并在一维情况下为法向量插入值-1和1来验证。

[1.x.62] 



接下来，我们通过单元格，将缩放后的矩阵传递给TensorProductMatrixSymmetricSum，以实际计算代表逆的广义特征值问题。由于矩阵近似的构造为[2.x.174]，并且每个元素的权重是恒定的，我们可以在拉普拉斯矩阵上应用所有的权重，并且简单地保持质量矩阵不被缩放。在单元格的循环中，我们要利用MatrixFree类提供的几何体压缩，并检查当前的几何体是否与上一批单元格上的几何体相同，在这种情况下就没有什么可做的。一旦调用了`reinit()`，就可以通过[2.x.175]访问这种压缩。     


一旦我们通过FEEvaluation访问函数访问了反Jacobian（我们取第4个正交点的那个，因为它们在笛卡尔单元的所有正交点上都应该是一样的），我们检查它是对角线的，然后提取原始Jacobian的行列式，即反Jacobian的行列式的逆值，并根据1D Laplacian乘以质量矩阵的[2.x.177]拷贝，设置权重为[2.x.176] 。

[1.x.63] 



一旦我们知道了拉普拉斯矩阵的比例系数，我们就将这个权重应用于未被缩放的DG拉普拉斯矩阵，并将数组发送到TensorProductMatrixSymmetricSum类，以计算介绍中提到的广义特征值问题。







[1.x.64] 



在DG背景下，用于近似块状Jacobi预处理的vmult函数非常简单。我们只需要读取当前单元格批次的值，对张量积矩阵阵列中的给定条目进行逆运算，并将结果写回去。在这个循环中，我们覆盖了`dst`中的内容，而不是首先将条目设置为零。这对于DG方法来说是合法的，因为每个单元都有独立的自由度。此外，我们手动写出所有单元批的循环，而不是通过 [2.x.178] 我们这样做是因为我们知道我们在这里不需要通过MPI网络进行数据交换，因为所有的计算都是在每个处理器上的本地单元上完成的。







[1.x.65] 



LaplaceProblem类的定义与 [2.x.179] 非常相似。一个区别是我们将元素度作为模板参数添加到类中，这将允许我们通过在`main()`函数中创建不同的实例，更容易在同一个程序中包含多个度。第二个区别是选择了FE_DGQHermite这个元素，它是专门用于这种方程的。







[1.x.66] 



设置函数在两个方面与 [2.x.180] 不同。第一个方面是我们不需要为不连续的Ansatz空间插值任何约束，而只是将一个假的AffineConstraints对象传递给[2.x.181]。 第二个变化是因为我们需要告诉MatrixFree也初始化面的数据结构。我们通过为内部面和边界面分别设置更新标志来做到这一点。在边界面，我们需要函数值、它们的梯度、JxW值（用于积分）、法向量和正交点（用于边界条件的评估），而对于内部面，我们只需要形状函数值、梯度、JxW值和法向量。只要`mapping_update_flags_inner_faces`或`mapping_update_flags_boundary_faces`中的一个与UpdateFlags的默认值`update_default`不同，MatrixFree中的面数据结构就总是被建立起来。







[1.x.67] 



右手边的计算比 [2.x.182] 中更复杂一些。现在的单元项包括分析解的负拉普拉斯，`RightHandSide'，为此我们需要首先将VectorizedArray字段的Point，即一批点，通过分别评估VectorizedArray中的所有车道，分割成一个点。请记住，通道的数量取决于硬件；对于不提供矢量化的系统（或deal.II没有本征），它可能是1，但在最近英特尔架构的AVX-512上也可能是8或16。

[1.x.68] 



其次，我们还需要应用Dirichlet和Neumann边界条件。一旦Dirichlet边界上的外部求解值[2.x.184]和[2.x.185]以及Neumann边界上的[2.x.186]和[2.x.187]被插入并以边界函数[2.x.188]和[2.x.189]展开，这个函数就是到函数[2.x.183]的遗漏部分。有一点需要记住的是，我们把边界条件移到右手边，所以符号与我们在求解部分施加的相反。     


我们本可以通过[2.x.190]部分发出单元格和边界部分，但我们选择手动写出所有面的完整循环，以了解面指数的索引布局在MatrixFree中是如何设置的：内部面和边界面都共享索引范围，所有批次的内部面的数字都比批次的边界单元格低。两种变体的单一索引使我们可以很容易地在两种情况下使用相同的数据结构FEFaceEvaluation，它附着在同一个数据域上，只是位置不同。内层面的批次（其中一个批次是由于几个面合并成一个面进行矢量化）的数量由[2.x.191]给出，而边界面的批次数量由[2.x.192]给出。 

[1.x.69] 



MatrixFree类让我们查询当前面批的边界_id。请记住，MatrixFree为矢量化设置了批次，使一个批次中的所有面孔都有相同的属性，其中包括它们的 "边界_id"。因此，我们可以在这里查询当前面的索引`face`的id，并在Dirichlet情况下（我们在函数值上添加一些东西）或Neumann情况下（我们在法向导数上添加一些东西）施加。

[1.x.70] 



由于我们在单元上手动运行循环，而不是使用[2.x.193]，我们一定不要忘记与MPI进行数据交换--或者说，实际上我们在这里不需要对DG元素进行数据交换，因为每个单元都有自己的自由度，而且单元和边界积分只对本地拥有的单元的量进行评估。与相邻子域的耦合只通过内表面积分来实现，我们在这里没有做这个。也就是说，在这里调用这个函数并没有什么坏处，所以我们这样做是为了提醒大家里面发生了什么[2.x.194] 。 

[1.x.71] 



`solve()`函数几乎是逐字复制自 [2.x.195] 。我们设置了相同的多网格成分，即水平转移、平滑器和粗略的网格求解器。唯一不同的是，我们没有使用拉普拉斯的对角线作为用于平滑的切比雪夫迭代的预处理，而是使用我们新解决的类`%PreconditionBlockJacobi`。不过，机制是一样的。

[1.x.72] 



由于我们已经解决了一个有分析解的问题，我们想通过计算数值结果与分析解的L2误差来验证我们实现的正确性。







[1.x.73] 



`run()`函数设置了初始网格，然后以常规方式运行多网格程序。作为一个域，我们选择一个矩形，在[2.x.196]方向上有周期性的边界条件，在[2.x.197]方向上的正面（即索引号为2的面，边界id等于0）有一个Dirichlet条件，在背面以及[2.x.198]方向上的两个面有Neumann条件（边界id等于1）的三维情况。与[2.x.200]和[2.x.201]方向相比，[2.x.199]方向的域的范围有点不同（鉴于 "解决方案 "的定义，我们想在这里实现周期性的解决方案）。







[1.x.74] 



`main()`函数中没有任何意外。我们通过`MPI_Init()`类调用`MPI_InitFinalize`，传入文件顶部设置的关于维度和度的两个参数，然后运行拉普拉斯问题。







[1.x.75] 

[1.x.76][1.x.77]。


[1.x.78][1.x.79]。


与[2.x.202]中一样，我们以运行时间来评估多网格求解器。 在两个空间维度的8度元素中，可能的输出看起来如下。

[1.x.80] 



与[2.x.203]一样，随着问题大小的增加，CG的迭代次数保持不变。迭代次数稍高，这是因为我们使用的切比雪夫多项式的度数较低（[2.x.204]中为2比5），而且内部惩罚离散化的特征值分布较大。尽管如此，13次迭代将残差减少了12个数量级，或者说每次迭代几乎是9个系数，这表明总体上是一个非常有效的方法。特别是，当使用12个核心时，我们可以在5秒内解决一个具有2100万自由度的系统，这是一个非常好的效率。当然，在二维中，我们很好地进入了8级多项式的四舍五入体系；事实上，大约83000个自由度或0.025秒就足以完全收敛这个（简单的）分析解。

如果我们在三个空间维度上运行这个程序，并没有什么变化，只是我们现在用做更高的多项式度和越来越大的网格尺寸来做一些更有用的事情，因为舍入误差只在最细的网格上得到。尽管如此，令人瞩目的是，我们可以在一台12核的机器上非常容易地解决一个具有三个周期的波浪的三维拉普拉斯问题，达到四舍五入的精度--对于24m DoFs的第二至最大的情况，总共使用约3.5GB的内存，花费不超过8秒。最大的案例使用了30GB的内存，有1.91亿个DoFs。

[1.x.81] 



[1.x.82][1.x.83] 。


在介绍和代码内的评论中，多次提到用FEEvaluation和FEFaceEvaluation评估器可以非常有效地处理高阶。现在，我们想通过观察三维多网格求解器在不同多项式程度下的吞吐量来证实这些说法。我们收集的时间如下。我们首先在问题大小接近一千万的情况下运行求解器，如表前四行所示，并记录时间。然后，我们通过记录每秒解决的百万自由度数（MDoFs/s）来规范吞吐量，以便能够比较不同程度的效率，计算方法是自由度数除以求解器时间。

 [2.x.205]  

我们清楚地看到每个自由度的效率最初是如何提高的，直到它达到多项式程度的最大值 [2.x.206] 。这种效果是令人惊讶的，不仅是因为较高的多项式度数通常会产生一个好得多的解决方案，而且特别是在考虑到基于矩阵的方案时，较高度数的密集耦合会导致吞吐量单调地下降（在三维中是急剧的，[2.x.207]比[2.x.208]慢10倍以上！）。对于更高的度数，吞吐量减少了一些，这既是由于迭代次数的增加（从[2.x.209]的12次增加到[2.x.210]的19次），也是由于算子评估的[2.x.211]复杂性。尽管如此，对于更高的多项式度数来说，作为求解时间的效率仍然会更好，因为它们有更好的收敛率（至少对于像这个问题这样简单的问题来说）。对于[2.x.212]，我们在100万个DoFs的情况下已经达到了舍入精度（求解时间不到一秒），而对于[2.x.213]，我们需要2400万个DoFs和8秒。对于[2.x.214]，误差约为[2.x.215]，有5700万个DoFs，因此，尽管花了16秒，仍然离舍入很远。

请注意，上述数字有点悲观，因为它们包括切比雪夫平滑器计算特征值估计的时间，这大约是求解器时间的10%。如果系统被多次求解（例如在流体力学中很常见），这个特征值的成本只需支付一次，更快的时间就可以得到。

[1.x.84][1.x.85] 。


最后，我们来看一下本教程程序中提出的一些特殊成分，即特别是FE_DGQHermite基础和[2.x.216]的规范。 在下表中，第三行显示了上述优化的求解器，第四行显示了仅将[2.x.217 ]设置为 "未指定 "而不是最优的 "网格"，最后一行是用基本的FE_DGQ元素代替FE_DGQHermite，其中MPI交换的费用更高，而由[2.x.218]和[2.x.219]完成的操作  

 [2.x.220]  

表中的数据显示，对于较高的多项式度数，不使用[2.x.221]会增加10%左右的成本。对于较低的度数，差异显然没有那么明显，因为体积与表面的比例更有利，需要交换的数据更少。如果只看矩阵-向量乘积，而不是这里显示的完整的多网格求解器，差异会更大，仅仅因为MPI通信，时间就会差20%左右。

对于[2.x.222]和[2.x.223]，类似Hermite的基函数显然没有真正发挥作用（事实上，对于[2.x.224]，多项式与FE_DGQ完全相同），其结果与FE_DGQ基类似。然而，对于从三开始的度数，我们看到FE_DGQHermite的优势越来越大，显示了这些基函数的有效性。

[1.x.86][1.x.87] 。


正如介绍中提到的，快速对角线化方法与具有恒定系数的直角坐标网相联系。如果我们想解决可变系数的问题，我们就需要在平滑参数的设计上投入更多的时间，选择适当的泛函（例如在最近的箱形元素上近似反演）。

另一种扩展程序的方式是包括对自适应网格的支持，对于这种支持，不同细化水平的边缘的界面操作是必要的，正如在 [2.x.225] 中所讨论的那样。[1.x.88] [1.x.89] [2.x.226] 。 

 [2.x.227] 
