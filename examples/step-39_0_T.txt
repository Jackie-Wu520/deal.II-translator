 [2.x.0] [2.x.1]。 

本教程取决于[2.x.2] b. 

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9] 

[1.x.10] 

在这个程序中，我们使用内部惩罚方法和Nitsche的弱边界条件来解决Poisson方程。我们在局部细化的网格上使用多网格方法，这些网格的生成使用了一个批量准则和一个基于单元和面残差的标准误差估计器。所有的操作都是通过MeshWorker接口实现的。

像[2.x.3]一样，离散化依赖于有限元空间，它在网格单元内部是多项式的[2.x.4]，但在单元之间没有连续性。由于这种函数在每个内部面[2.x.5]上有两个值，每边一个，我们定义均值和跳跃算子如下：让[1.x.11]<sub>1</sub>和[1.x.12]<sub>2</sub>是共享一个面的两个单元，让函数的轨迹[1.x.13]和外法向量[1.x.14][1.x.15] 被相应地标记。然后，在这个面上，我们让[1.x.16] 

注意，如果这样的表达式包含一个法向量，平均运算符就会变成一个跳跃。问题[1.x.17]的内部惩罚方法变成[1.x.18] 。



这里，[2.x.6]是惩罚参数，其选择如下：对于单元格[1.x.20]的一个面[1.x.19]，计算值[1.x.21]，其中[1.x.22]是有限元函数的多项式程度，[2.x.7]和[2.x.8]表示相应对象的[2.x.9]和[2.x.10]维的豪斯多尔夫度。如果面在边界上，选择[2.x.11] 。对于一个内部的面，我们取这个面的两个值的平均值。

在我们的有限元程序中，我们区分了三种不同的积分，分别对应于上面的单元格、内部面和边界面的总和。由于[2.x.12]为我们组织了这些和，我们只需要实现每个网格元素的积分。下面的MatrixIntegrator类有这三个函数用于公式的左边，RHSIntegrator类用于右边。

正如我们将在下面看到的，即使是误差估计也是同样的结构，因为它可以写为 

[1.x.23] 



因此，下面用于组装矩阵、右手和误差估计的函数展示了这些循环都是通用的，可以用同样的方式进行编程。

这个程序与[2.x.13]b有关，因为它使用MeshWorker和不连续Galerkin方法。在那里，我们解决的是一个平流问题，而这里是一个扩散问题。在这里，我们还使用了多网格预处理和一个理论上合理的误差估计器，见Karakashian和Pascal（2003）。Kanschat (2004)详细讨论了多层次方案。Hoppe, Kanschat, and Warburton (2009)讨论了自适应迭代及其收敛性（对于三角形网格）。[1.x.24] [1.x.25]。

用于线性代数的include文件。一个常规的SparseMatrix，它又将包括SparsityPattern和Vector类的必要文件。

[1.x.26] 



用于设置网格的包含文件 

[1.x.27] 



包含FiniteElement类和DoFHandler的文件。

[1.x.28] 



使用MeshWorker框架的包含文件 

[1.x.29] 



与Laplacian相关的局部积分器的包含文件 

[1.x.30] 



对多网格方法的支持 

[1.x.31] 



最后，我们从库中取出我们的精确解，以及正交和附加工具。

[1.x.32] 



deal.II库的所有类都在dealii的命名空间中。为了节省打字，我们告诉编译器也要在那里搜索名字。

[1.x.33] 



这是我们用来设置边界值的函数，也是我们比较的精确解。

[1.x.34] 




[1.x.35] [1.x.36] 




MeshWorker将局部积分与单元格和面的循环分开。因此，我们必须编写局部积分类来生成矩阵、右手边和误差估计器。




所有这些类都有相同的三个函数，分别用于对单元、边界面和内部面的积分。局部积分所需的所有信息都由[2.x.14]提供。请注意，函数的签名不能改变，因为这是[2.x.15]所期望的。 




定义局部积分器的第一类负责计算单元和面矩阵。它被用来组装全局矩阵以及水平矩阵。

[1.x.37] 



在每个单元上，我们对Dirichlet形式进行积分。我们使用LocalIntegrators中现成的积分库来避免自己编写这些循环。同样地，我们实现了Nitsche边界条件和单元间的内部惩罚通量。   


边界和通量项需要一个惩罚参数，这个参数应该根据单元的大小和多项式的程度进行调整。在[2.x.16]中可以找到这个参数对常数系数的安全选择，我们在下面使用这个参数。

[1.x.38] 



内部面使用内部惩罚方法 

[1.x.39] 



第二个局部积分器建立了右手边。在我们的例子中，右手边的函数为零，这样，这里只设置了弱形式的边界条件。

[1.x.40] 



第三个局部积分器负责对误差估计的贡献。这是由Karakashian和Pascal（2003）提出的标准能量估计器。

[1.x.41] 



单元的贡献是离散解的拉普拉斯，因为右手边是零。

[1.x.42] 



在边界，我们简单地使用边界残差的加权形式，即有限元解和正确边界条件之间的差值的规范。

[1.x.43] 



最后，在内部面，估计器由解的跳跃和它的法向导数组成，并适当地加权。

[1.x.44] 



最后，我们有一个误差的积分器。由于非连续Galerkin问题的能量准则不仅涉及到单元内部的梯度差，还涉及到跨面和边界的跳跃项，所以我们不能仅仅使用[2.x.17] 而是使用MeshWorker接口来计算误差。




有几种不同的方法来定义这个能量准则，但是所有的方法都是随着网格大小的变化而等价的（有些不是随着多项式程度的变化而等价）。这里，我们选择[1.x.45] 







[1.x.46] 



这里我们在单元格上进行积分。目前MeshWorker中还没有好的接口可以让我们访问正交点的正则函数值。因此，我们必须在单元格积分器中为精确的函数值和梯度创建向量。之后，一切都和以前一样，我们只需将差值的平方加起来。




除了计算能量准则的误差外，我们还利用网格工作者的能力同时计算两个函数，并在同一循环中计算[1.x.47]的误差。很明显，这个函数没有任何跳跃项，只出现在单元格的积分中。

[1.x.48] 




[1.x.49] [1.x.50]。




这个类做主要的工作，就像前面的例子一样。关于这里声明的函数的描述，请参考下面的实现。

[1.x.51] 



与离散化有关的成员对象在这里。

[1.x.52] 



然后，我们有与全局离散系统相关的矩阵和向量。

[1.x.53] 



最后，我们有一组与多级预处理程序相关的稀疏模式和稀疏矩阵。 首先，我们有一个水平矩阵和它的稀疏性模式。

[1.x.54] 



当我们在局部细化的网格上进行局部平滑的多网格时，需要额外的矩阵；见Kanschat（2004）。这里是这些边缘矩阵的稀疏性模式。我们只需要一个，因为上矩阵的模式是下矩阵的转置。实际上，我们并不太关心这些细节，因为MeshWorker正在填充这些矩阵。

[1.x.55] 



精细化边缘的通量矩阵，将精细级的自由度与粗略级的自由度进行耦合。

[1.x.56] 



细化边缘的通量矩阵的转置，将粗级自由度耦合到细级。

[1.x.57] 



构造函数简单地设置了粗略的网格和DoFHandler。有限元素被作为参数提供，以实现灵活性。

[1.x.58] 



在这个函数中，我们设置了线性系统的维度和全局矩阵以及水平矩阵的稀疏模式。

[1.x.59] 



首先，我们使用有限元将自由度分布在网格上并对其进行编号。

[1.x.60] 



然后，我们已经知道代表有限元函数的向量的大小。

[1.x.61] 



接下来，我们设置全局矩阵的稀疏性模式。由于我们事先不知道行的大小，我们首先填充一个临时的DynamicSparsityPattern对象，一旦完成，就把它复制到常规的SparsityPattern。

[1.x.62] 



全局系统已经设置好了，现在我们来处理水平矩阵。我们调整所有的矩阵对象的大小，以便每层容纳一个矩阵。

[1.x.63] 



在为级别矩阵调用<tt>clear()</tt>之后，更新稀疏模式是很重要的，因为矩阵通过SmartPointer和Subscriptor机制锁定稀疏模式。

[1.x.64] 



现在，所有的对象都准备好了，每个级别持有一个稀疏模式或矩阵。剩下的就是在每个层次上设置稀疏模式了。

[1.x.65] 



这与上面的全局矩阵的行数大致相同，现在是为每一层设置。

[1.x.66] 



此外，我们需要初始化各层之间细化边缘的转移矩阵。它们被存储在指代两个索引中较细的索引处，因此在第0层没有这样的对象。

[1.x.67] 



在这个函数中，我们组装全局系统矩阵，这里的全局是指我们所求解的离散系统的矩阵，它覆盖整个网格。

[1.x.68] 



首先，我们需要建立一个提供积分值的对象。这个对象包含所有需要的FEValues和FEFaceValues对象，并且自动维护它们，使它们总是指向当前单元。为此，我们首先需要告诉它，在哪里计算，计算什么。由于我们没有做任何花哨的事情，我们可以依靠他们对正交规则的标准选择。     


由于他们的默认更新标志是最小的，我们额外添加我们需要的东西，即所有对象（单元、边界和内部面）上的形状函数的值和梯度。之后，我们准备初始化容器，它将创建所有必要的FEValuesBase对象进行整合。

[1.x.69] 



这是我们整合本地数据的对象。它由MatrixIntegrator中的局部整合例程填充，然后由汇编器用来将信息分配到全局矩阵中。

[1.x.70] 



此外，我们还需要一个将局部矩阵装配到全局矩阵的对象。这些装配器对象拥有目标对象结构的所有知识，在这种情况下是稀疏矩阵，可能的约束和网格结构。

[1.x.71] 



现在是我们自己编码的部分，局部积分器。这是唯一与问题有关的部分。

[1.x.72] 



现在，我们把所有的东西都扔到一个[2.x.18]中，这个[2.x.18]遍历了网格的所有活动单元，计算单元和面的矩阵，并把它们组合成全局矩阵。我们在这里使用变量<tt>dof_handler</tt>，以便使用全局自由度的编号。

[1.x.73] 



现在，我们对水平矩阵做同样的处理。不太令人惊讶的是，这个函数看起来像前一个函数的孪生兄弟。事实上，只有两个小的区别。

[1.x.74] 



很明显，需要用一个填充水平矩阵的汇编器来代替。请注意，它也会自动填充边缘矩阵。

[1.x.75] 



这里是与前一个函数的另一个区别：我们在所有的单元格上运行，而不仅仅是活动单元格。而且我们使用以[2.x.19]结尾的函数，因为我们需要每一层的自由度，而不是全局的编号。

[1.x.76] 



这里我们有另一个assemble函数的克隆。与组装系统矩阵的区别在于，我们在这里组装了一个向量。

[1.x.77] 



由于这个装配器允许我们填充多个向量，因此界面比上面的要复杂一些。向量的指针必须存储在一个AnyData对象中。虽然这在这里似乎造成了两行额外的代码，但实际上在更复杂的应用中它是很方便的。

[1.x.78] 



现在我们已经编码了构建离散线性系统的所有函数，现在是我们实际解决它的时候了。

[1.x.79] 



所选择的求解器是共轭梯度。

[1.x.80] 



现在，我们正在设置多级预处理器的组件。首先，我们需要在网格层之间进行转移。我们在这里使用的对象为这些转移生成了稀疏矩阵。

[1.x.81] 



然后，我们需要一个最粗层的矩阵的精确解算器。

[1.x.82] 



虽然转移和粗网格求解器基本是通用的，但为平滑器提供了更多灵活性。首先，我们选择Gauss-Seidel作为我们的平滑方法。

[1.x.83] 



在每个层次上做两个平滑步骤。

[1.x.84] 



由于SOR方法不是对称的，但我们在下面使用共轭梯度迭代，这里有一个技巧，使多级预处理器成为对称算子，即使是非对称的平滑器。

[1.x.85] 



平滑器类可以选择实现可变的V型循环，我们在这里不希望这样。

[1.x.86] 



最后，我们必须将我们的矩阵包裹在一个具有所需乘法函数的对象中。

[1.x.87] 



现在，我们已经准备好设置V型循环算子和多级预处理程序。

[1.x.88] 



我们不要忘记由于自适应细化而需要的边缘矩阵。

[1.x.89] 



在所有准备工作完成后，将多网格对象包裹到另一个对象中，该对象可作为常规预处理程序使用。

[1.x.90] 



并使用它来解决系统。

[1.x.91] 



另一个集合函数的克隆。与之前的函数最大的不同是，这里我们也有一个输入向量。

[1.x.92] 



估算器的结果被存储在一个每个单元格有一个条目的向量中。由于deal.II中的单元格没有编号，我们必须建立自己的编号，以便使用这个向量。对于下面使用的汇编器来说，结果存储在向量的哪个分量中的信息是由每个单元的user_index变量传送的。我们需要在这里设置这个编号。     


另一方面，有人可能已经使用了用户指数。所以，让我们做个好公民，在篡改它们之前保存它们。

[1.x.93] 



这就像以前一样开始了。

[1.x.94] 



但现在我们需要通知信息框我们要在正交点上评估的有限元函数。首先，我们用这个向量创建一个AnyData对象，它是我们刚刚计算的解决方案。

[1.x.95] 



然后，我们告诉单元格的[2.x.20]，我们需要这个解的二阶导数（用来计算拉普拉斯的）。因此，选择函数值和一阶导数的布尔参数为假，只有选择二阶导数的最后一个参数为真。

[1.x.96] 



在内部和边界面，我们需要函数值和第一导数，但不需要第二导数。

[1.x.97] 



我们继续像以前一样，除了默认的更新标志已经被调整为我们上面要求的值和导数之外。

[1.x.98] 



汇编器在每个单元格中存储一个数字，否则这与计算右手边的情况相同。

[1.x.99] 



就在我们返回误差估计的结果之前，我们恢复了旧的用户索引。

[1.x.100] 



这里我们将我们的有限元解与（已知的）精确解进行比较，计算梯度和函数本身的平均二次误差。这个函数是上面那个估计函数的克隆。




由于我们分别计算能量和[1.x.101]-norm的误差，我们的块向量在这里需要两个块。

[1.x.102] 



创建图形输出。我们通过整理其各个组成部分的名称来产生文件名，包括我们用两位数输出的细化周期。

[1.x.103] 



最后是自适应循环，或多或少与前面的例子一样。

[1.x.104] 

[1.x.105][1.x.106] 。


[1.x.107][1.x.108]。

首先，该程序产生通常的日志文件，在这里存储在<tt>deallog</tt>。它的内容是（省略了中间的步骤 

[1.x.109] 



例如，这个日志显示共轭梯度迭代步骤的数量恒定在大约15个。

[1.x.110][1.x.111] 。


 [2.x.21] 使用perl脚本<tt>postprocess.pl</tt>，我们将相关数据提取到<tt>output.dat</tt>，可以用<tt>gnuplot</tt>绘制图表。例如，上面的图是用gnuplot脚本<tt>plot_errors.gpl</tt>制作的，通过 

[1.x.112] 



参考数据可以在<tt>output.reference.dat</tt>中找到。[1.x.113] [1.x.114] [2.x.22] 。 

 [2.x.23] 
