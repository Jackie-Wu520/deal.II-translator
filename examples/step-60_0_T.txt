 [2.x.0][2.x.1] 。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21] 

 [2.x.3]  

[1.x.22] 

 [2.x.4]  


[1.x.23] [1.x.24] 


[1.x.25][1.x.26]。




在本教程中，我们考虑两个域的情况，[2.x.5]在[2.x.6]中，[2.x.7]在[2.x.8]中，其中[2.x.9]被嵌入[2.x.10]中（[2.x.11] ）。我们想在[2.x.12]上解决一个偏微分方程，对问题的解决*在嵌入域*[2.x.13]上强制执行一些条件。

有两种有趣的情况。

- 嵌入域[2.x.14]的几何维度`dim`与域[2.x.15]相同（`spacedim`），即[2.x.16]的spacedim维度不为零，或 

- 嵌入域[2.x.17]的内在维度`dim`小于[2.x.18]（`spacedim`），因此其间隔维度为零；例如，它是一条嵌入二维域的曲线，或一个嵌入三维域的面。

在这两种情况下，定义限制算子[2.x.19]为算子，给定[2.x.20]上的连续函数，返回其在[2.x.21]上的（连续）限制，即：。

[1.x.27] 

众所周知，当[2.x.26]的内在维度与[2.x.27]相同时，算子[2.x.22]可以扩展为[2.x.23]上的连续算子，将[2.x.24]中的函数映射到[2.x.25]中的函数。

当[2.x.29]的维度相对于[2.x.30]少一个，且[2.x.31]没有边界时，在一个不太规则的范围空间（即[2.x.28]）中也是如此。在这第二种情况下，算子[2.x.32]也被称为*轨迹算子，对于嵌入[2.x.34]中的Lipschitz同维一曲线和曲面[2.x.33]，它是很好的定义（关于轨迹算子的进一步细节请阅读[1.x.28]）。

共二维的情况要复杂一些，一般来说，不可能构造一个连续的跟踪算子，甚至不可能从[2.x.35]到[2.x.36]，当[2.x.37]的维度在二维和三维中分别为零或一的时候。

在本教程中，我们对[2.x.38]的进一步细节不感兴趣：我们认为扩展[2.x.39]是理所当然的，假设嵌入域的尺寸（`dim`）总是比嵌入域的尺寸[2.x.40]（`spacedim`）小一或相等。

我们将解决以下微分问题：给定[2.x.41]上的一个足够规则的函数[2.x.42]，找到[2.x.43]的解。

[1.x.29] 



这是一个约束问题，我们要寻找一个在[2.x.45]上满足同质边界条件的谐波函数[2.x.44]，在约束条件[2.x.46]下使用拉格朗日乘法器。

这个问题有一个物理解释：谐波函数，即满足拉普拉斯方程的函数，可以被认为是边界值被规定的膜的位移。那么，目前的情况相当于找到一个膜的形状，对它来说，不仅边界上的位移，而且[2.x.47]上的位移也是规定的。例如，如果[2.x.48]是二维空间的封闭曲线，那么这将是一个肥皂膜的模型，它被沿[2.x.49]的线环和沿[2.x.50]的第二个线环固定住。在[2.x.51]是整个区域的情况下，你可以把它看作是在障碍物上伸展的膜，其中[2.x.52]是接触区域。(如果接触面积不知道，我们有一个不同的问题--称为 "障碍物问题"--在[2.x.53]中建模) 。

作为第一个例子，我们研究[2.x.54]上的零Dirichlet边界条件。如果我们在[2.x.55]上应用零Neumann边界条件或两者的混合，也适用同样的方程。

通过引入两个无限维空间[2.x.56]和[2.x.57]，可以得出变分公式，分别用于解[2.x.58]和拉格朗日乘子[2.x.59]。

将第一个方程乘以[2.x.60]，第二个方程乘以[2.x.61]，在可能的情况下进行部分积分，并利用[2.x.62]的边界条件，我们得到以下变分问题。

给定[2.x.64]上的一个足够规则的函数[2.x.63]，找到[1.x.30]的解[2.x.65]。



其中[2.x.66]和[2.x.67]分别代表[2.x.68]中的标量积和[2.x.70]。

对变量公式的检查告诉我们，空间[2.x.71]可以被看作是[2.x.72] 。空间[2.x.73]，在同维度为零的情况下，应取为[2.x.74]，而在同维度为一的情况下应取为[2.x.75]。

因此函数[2.x.76]应该在[2.x.77]（共维度为零的情况）或[2.x.78]（共维度为一的情况）。这使得我们在[2.x.80]中有一个拉格朗日乘数[2.x.79]，它是[2.x.81]或[2.x.82] 。

对于上述问题的离散化，有两种选择。可以选择匹配的离散化，即[2.x.83]的三角化与[2.x.84]的三角化一致，也可以选择以完全独立的方式离散化这两个域。

对于我们上面提出的简单问题，第一种选择显然更有意义：对[2.x.85]使用单一的三角法就可以了，然后根据[2.x.86]施加某些约束。这种方法的一个例子是在[2.x.87]中研究的，其中解决方案必须保持在一个障碍物之上，这是在[2.x.88]上施加约束实现的。

为了解决更复杂的问题，例如域[2.x.89]与时间有关的问题，第二种方法可能是更可行的解决方案。处理不对齐的网格本身就很复杂：为了说明如何做，我们研究一个简单的问题。

我们在这里描述的技术在文献中使用了许多名称之一：[1.x.31]、[1.x.32]、[1.x.33]等。其主要原理是两个网格和两个有限元空间的离散化保持完全独立。这种技术对于模拟流固耦合问题特别有效，其中嵌入结构的配置是问题本身的一部分，人们要解决一个（可能是非线性的）弹性问题来确定[2.x.90]的（与时间有关的）配置，以及[2.x.91]的（可能是非线性的）流动问题，加上流体和固体之间界面上的耦合条件。

在这个教程程序中，我们把事情弄得简单一些，我们假设嵌入域的配置是以两种可能的方式之一给出的。

- 变形映射 [2.x.92] ，定义在 [2.x.93] 上的连续有限维空间上，对于任何点 [2.x.94] ，其坐标 [2.x.95] 在 [2.x.96] 中表示。

- 作为[2.x.98]的位移映射[2.x.97]，代表任何点[2.x.99]的位移矢量，以使[2.x.100]变形为其实际配置[2.x.101]。

我们定义嵌入式参考域[2.x.102] `embedded_grid`：在这个三角形上，我们构建一个有限维空间（`embedded_configuration_dh`），通过FE_Q对象的有限元系统（`embedded_configuration_fe`）描述变形或位移。这个有限维度空间仅用于插值用户提供的函数（`embedded_configuration_function`），代表[2.x.103]（如果参数`use_displacement`被设置为[2.x.104]）或[2.x.105]（如果参数`use_displacement`被设置为[2.x.106] ）。 

拉格朗日乘数[2.x.107]和用户提供的函数[2.x.108]是通过另一个有限维空间`embedded_dh`和另一个有限元`embedded_fe`定义的，使用相同的参考域。为了考虑到域的变形，MappingFEField或MappingQEulerian对象被初始化为`embedded_configuration`向量。

在嵌入空间中，一个标准的有限维空间`space_dh`被构建在嵌入网格`space_grid`上，使用有限元素`space_fe`，几乎逐字逐句地遵循 [2.x.109] 中的方法。

我们分别用[1.x.34]和[1.x.35]表示空间[2.x.110]和[2.x.111]的离散化，其中[2.x.112]是`space_dh`的尺寸，[2.x.113]是`embedded_dh`的尺寸。

一旦所有的有限维空间都被定义，上述问题的变异性表述给我们留下了以下有限维方程组。

[1.x.36] 

其中 

[1.x.37] 



虽然矩阵[2.x.114]是[2.x.115]上泊松问题的标准刚度矩阵，矢量[2.x.116]是[2.x.118]上带有强制项[2.x.117]的有限元问题的标准右手矢量（例如，见[2.x.119]），但矩阵[2.x.120]或其转置[2.x.121]是非标准的，因为它们将两个非匹配网格的信息结合在一起。

特别是，在计算[2.x.122]的一个条目时出现的积分，是在[2.x.123]上计算的。在有限元中，我们通常将这个积分分成来自用于离散化[2.x.124]的三角形的所有单元的贡献，我们将[2.x.125]上的积分转换为参考元素[2.x.126]上的积分，其中[2.x.127]是从[2.x.128]到[2.x.129]的映射，并使用正交公式计算[2.x.130]上的积分。

[1.x.38] 

计算这个总和是不容易的，因为我们必须评估 [2.x.131] 。一般来说，如果[2.x.132]和[2.x.133]没有对齐，那么[2.x.134]这个点相对于[2.x.135]来说是完全任意的，除非我们想出办法将[2.x.136]的所有基函数插值在[2.x.137]上的任意点，否则我们无法计算矩阵[2.x.138]的一个条目所需的积分。

为了评估[2.x.139]，需要采取以下步骤（如下图所示）。

- 对于[2.x.141]中的给定单元[2.x.140]，计算实点[2.x.142]，其中[2.x.143]是用于对[2.x.144]进行积分的正交点之一。

- 找到[2.x.145]的单元，[2.x.146]位于其中。我们将称这个单元为 [2.x.147] 。

- 为了评估基函数，使用映射[2.x.148]的逆映射，将参考元素[2.x.149]转换为元素[2.x.150] : [2.x.151] 。

 [2.x.152]  

上面的三个步骤可以通过依次调用来计算。

- [2.x.153] 然后是 

- [2.x.154] 然后我们 

- 构建一个自定义正交公式，包含参考单元格中的点，然后 

- 构建一个FEValues对象，使用给定的正交公式，并以第一步获得的单元格进行初始化。

这就是deal.II函数[2.x.155]在任意点上评估有限元场（而不仅仅是单个形状函数）时的做法；但在这种情况下，这将是低效的。

一个更好的解决方案是使用一个方便的包装器在一个点的集合上执行前三个步骤。 [2.x.156] 如果人们实际上对计算完整的耦合矩阵感兴趣，那么可以调用方法[2.x.157]，该方法以有效的方式执行上述步骤，重复使用所有可能的数据结构，并将昂贵的步骤聚集在一起。这就是我们在本教程后面要使用的函数。

我们通过迭代求解器来解决最终的鞍点问题，应用于Schur补数[2.x.158]（其构造例如在[2.x.159]中描述），我们使用LinearOperator类构造[2.x.160]。


[1.x.39][1.x.40] 


我们在这里解决的问题与[2.x.161]相同，不同的是我们对一个嵌入域[2.x.162]施加了一些约束。本教程是以独立于维度的方式编写的，在结果部分我们展示了如何改变`dim`和`spacedim`。

本教程是在`dim`等于1，`spacedim`等于2的情况下编译的。如果你想在嵌入维度`spacedim`等于3的情况下运行程序，你很可能想改变[2.x.163]的参考域，例如，你从文件中读到的东西，或者你后来变形为更有趣的封闭球体。

在默认情况下，[2.x.164]的同维度为1，本教程的程序实现了虚构边界法。事实证明，同样的技术也用在了变量沉浸式有限元方法中，上面定义的耦合算子[2.x.165]在几乎所有这些非匹配方法中都是一样的。

嵌入域被假定包括在[2.x.166]中，我们把它当作单位平方[2.x.167] 。虚域[2.x.168]的定义可以通过参数文件修改，可以给出从参考区间[2.x.169]到[2.x.170]中的一条曲线的映射。

如果该曲线是封闭的，那么结果将类似于在边界为[2.x.171]的网格上运行相同的问题。在非封闭的[2.x.172]上，程序也会很高兴地运行，尽管在这些情况下，问题的数学表述更加困难，因为[2.x.173]本身就有一个边界，相对于域[2.x.174]而言，它具有二维。


[1.x.41][1.x.42] 。


 [2.x.175] [2.x.176] Glowinski, R., T.-W. Pan, T.I. Hesla, and D.D. Joseph. 1999. "分布式拉格朗日乘数/虚构域方法用于颗粒物流动"。  International Journal of Multiphase Flow 25 (5). Pergamon: 755-94. 

 [2.x.177] Boffi, D., L. Gastaldi, L. Heltai, and C.S. Peskin. 2008. "论沉浸边界法的超弹性公式"。应用力学和工程中的计算机方法197（25-28）。

 [2.x.178] Heltai, L., and F. Costanzo. 2012. "浸没式有限元方法的变量实现"。应用力学和工程中的计算机方法》229-232。 [2.x.179] [1.x.43] [1.x.44] 。


[1.x.45] [1.x.46] 其中大部分已在其他地方介绍过，我们只对新的进行评论。







[1.x.47] 



参数接受器类是本教程程序的第一个新颖之处：一般来说，参数文件是用来在运行时引导程序的执行。虽然即使是简单的方法也能节省编译时间，因为同一个可执行文件可以用不同的参数设置来运行，但要同时处理数以百计的参数并保持不同程序之间的兼容性会变得很困难。这就是ParameterAcceptor类证明有用的地方。




这个类用来定义一个公共接口，供那些想使用一个全局ParameterHandler来处理参数的类使用。该类提供了一个静态的ParameterHandler成员，即[2.x.180]，并实现了 "命令设计模式"（例如，见E. Gamma, R. Helm, R. Johnson, J. Vlissides, 设计模式。Elements of Reusable Object-Oriented Software, Addison-Wesley Professional, 1994. https://goo.gl/FNYByc）。) 




ParameterAcceptor提供了一个全局订阅机制。每当一个从ParameterAcceptor派生出来的类的对象被构造出来，一个指向该派生类型的对象的指针就会被注册，同时在参数文件中也有一个部分条目。这种注册表在调用单一函数[2.x.181]时被遍历，该函数反过来确保所有存储在全局注册表中的类都声明它们将使用的参数，在声明了这些参数后，它读取`file.prm`的内容来解析实际参数。




如果你为你想在代码中使用的每个参数调用方法[2.x.182]，你就不需要做其他事情了。如果你使用的是一个已经存在的类，它提供了`declare_parameters`和`parse_parameters`这两个函数，你仍然可以使用ParameterAcceptor，方法是将现有的类封装成ParameterAcceptorProxy类。




在这个例子中，我们将使用这两种策略，为deal.II类使用ParameterAcceptorProxy，并直接从ParameterAcceptor派生我们自己的参数类。

[1.x.48] 



另一个新的包含文件是包含[2.x.183]类的文件。deal.II的结构和许多现代数值库一样，是按照有向无环图（DAG）组织的。DAG是一个具有拓扑顺序的有向图：每个节点在结构上代表一个对象，并通过一条（或多条）有向边与非根节点相连，从父节点到子节点。这种结构最重要的例子是Triangulation和它的[2.x.184]结构。从Triangulation（主节点），我们可以访问每个单元（三角形的子节点）。从单元本身，我们可以访问单元的所有顶点。在这个简单的例子中，DAG结构可以表示为三种节点类型（三角结构、单元格迭代器和顶点），由从三角结构到单元格迭代器，以及从单元格迭代器到顶点的定向边连接。这有几个优点，但它本质上造成了 "不对称"，使某些操作变得很快，而它们的逆操作却很慢：寻找一个单元的顶点的计算成本很低，可以通过简单地遍历DAG来完成，而寻找所有共享一个顶点的单元则需要进行非难事的计算，除非添加一个新的DAG数据结构来表示逆搜索。




由于在有限元代码中通常不需要逆向操作，所以在GridTools中实现了这些操作，而没有使用与Triangulation相关的额外数据结构，这将使它们的速度大大加快。例如，这样的数据结构是一个从三角结构的顶点到共享这些顶点的所有单元的映射，这将减少回答前面问题所需的计算。




一些方法，例如[2.x.185]大量使用了这些非标准的操作。如果你需要多次调用这些方法，那么将这些数据结构存储在某个地方就变得很方便。 [2.x.186]正是这样做的，让你可以访问以前计算过的对象，或者在飞行中计算它们（然后将它们存储在类中供以后使用），并确保每当三角测量被更新时，相关的数据结构也被重新计算。

[1.x.49] 



在这个例子中，我们将使用一个参考域来描述一个嵌入的Triangulation，通过一个有限元矢量场进行变形。




接下来的两个包含文件包含了在这些情况下可以使用的两个类的定义。MappingQEulerian允许人们通过一个*位移*场来描述一个域，基于FESystem[FE_Q(p)^spacedim]有限元空间。第二种是比较通用的，它允许你使用任意的矢量有限元空间，只要它们能对你的领域进行*连续的描述。在这种情况下，描述是通过实际的*变形*场，而不是*位移*场完成的。




使用哪一个取决于用户想如何指定参考域，和/或实际配置。我们将提供这两个选项，并在本教程程序的结果部分做一些实验。

[1.x.50] 



解析的函数类是另一个新条目。它允许人们创建一个函数对象，从参数文件中的一个字符串开始，参数文件被解析成一个对象，你可以在deal.II接受函数的任何地方使用（例如，用于插值、边界条件等）。

[1.x.51] 



这是本教程程序的最后一个新条目。命名空间NonMatching包含一些方法，当在非匹配网格上进行计算时，或者在不与底层网格对齐的曲线上进行计算时，这些方法非常有用。




我们将在后面的 "setup_coupling "方法中详细讨论其用途。

[1.x.52] 




[1.x.53] [1.x.54]    


在DistributedLagrangeProblem中，我们需要两个参数来描述域[2.x.187]（`dim`）和域[2.x.188]（`spacedim`）的尺寸。   


这些参数将被用来初始化Triangulation<dim,spacedim>（用于[2.x.189]）和Triangulation<spacedim,spacedim>（用于[2.x.190]）。   


与其他教程程序相比，一个新奇之处在于大量使用了 [2.x.191] 这些指针的行为与经典指针一样，其优点是可以进行自动的内部管理：一旦unique_ptr超出范围，所包含的对象就会被自动销毁，即使它在一个容器内或者有一个例外。此外，它不允许有重复的指针，这可以防止所有权问题。我们这样做，是因为我们希望能够 i) 构建问题，ii) 读取参数，iii) 根据参数文件中指定的内容初始化所有对象。   


我们在派生于ParameterAcceptor的内部类`Parameters`中构建问题的参数。DistributedLagrangeProblem "类需要一个指向 "Parameters "对象的常量引用，因此不可能从DistributedLagrangeProblem类本身修改参数。   


我们可以先初始化参数，然后将参数传递给DistributedLagrangeProblem，假设所有条目都设置为所需的值，但这有两个缺点。

   




- 我们不应该对用户如何初始化一个不受我们直接控制的类做出假设。如果用户未能初始化该类，我们应该注意到并抛出一个异常。

   




- 当我们构造参数时，并不是所有需要从参数文件中读取参数的对象都可以使用；对于复杂的程序，有多种物理现象，或者我们在一些外部类中重复使用现有的代码，往往是这样的情况。我们通过将一些 "复杂 "的对象，如ParsedFunction对象，保留在`DistributedLagrangeProblem`内而不是`Parameters`内来模拟这一点。   


这里我们假设在构建时，构建我们问题的类还不能使用。解析参数文件是确保我们有所有的成分来建立我们的类，我们的设计是，如果解析失败，或者没有被执行，运行就会被中止。







[1.x.55] 



`Parameters`类派生于ParameterAcceptor。这使得我们可以在其构造函数中使用[2.x.192]方法。     


这个函数的成员都是非常量的，但是`DistributedLagrangeProblem`类需要一个对`Parameters`对象的常量引用：这确保参数不会从`DistributedLagrangeProblem`类中被修改。

[1.x.56] 



现在描述的参数都可以用参数文件在外部设置：如果运行可执行文件时没有参数文件，程序将用这里定义的默认值创建一个 "参数.prm "文件，然后中止，让用户有机会修改参数.prm文件。




嵌入网格的初始细化，对应于域[2.x.193] 。

[1.x.57] 



嵌入网格[2.x.194]和嵌入网格[2.x.195]之间的交互是通过[2.x.196]的计算来处理的，这涉及到[2.x.197]的所有单元与[2.x.198]的部分重叠：对这些单元的更高细化可能会提高我们的计算质量。为此，我们定义了 "delta_refinement"：如果它大于零，那么我们将空间网格中包含嵌入网格顶点的每个单元及其邻居标记出来，执行细化，并重复这个过程 "delta_refinement "次。

[1.x.58] 



开始细化嵌入网格，对应于域 [2.x.199] 。

[1.x.59] 



边界id的列表，在这里我们施加同质Dirichlet边界条件。在其余的边界id上（如果有的话），我们施加同质的Neumann边界条件。作为一个默认的问题，我们在[2.x.200]上设置了零迪里希特边界条件。 

[1.x.60] 



嵌入空间的有限元素程度。 [2.x.201]  

[1.x.61] 



嵌入空间的有限元度。 [2.x.202]  

[1.x.62] 



用于描述嵌入域的变形的空间的有限元度 

[1.x.63] 



用于积分耦合的正交公式的阶数 

[1.x.64] 



如果设置为 "真"，则嵌入配置函数被解释为位移函数 

[1.x.65] 



输出中使用的粗略程度 

[1.x.66] 



跟踪我们是否被初始化的一个标志。

[1.x.67] 



分布式拉格朗日问题的入口点 

[1.x.68] 



包含实际参数的对象 

[1.x.69] 



下面的函数与其他所有的教程程序相似，不同的是我们现在需要为两个不同系列的对象设置东西，即与*嵌入*网格有关的对象，以及与*嵌入*有关的对象。







[1.x.70] 



我们这里唯一的非常规函数是`setup_coupling()`方法，用于生成耦合矩阵的稀疏性模式 [2.x.203] 。







[1.x.71] 



首先，我们收集所有与嵌入空间几何学有关的对象 







[1.x.72] 



然后是与嵌入网格有关的对象，与拉格朗日乘法器`lambda`相关的DoFHandler 







[1.x.73] 



最后，所有需要*变形*的嵌入三角形的东西 

[1.x.74] 



ParameterAcceptorProxy类是一个 "透明 "的包装器，它源自ParameterAcceptor和作为其模板参数传递的类型。在构造时，参数被分成两部分：第一个参数是转发给ParameterAcceptor类的[2.x.204]，并包含应该用于这个类的部分的名称，而所有其余的参数都被转发给模板类型的构造器，在这里是转发给[2.x.205]构造器。     


这个类允许你结合ParameterAcceptor注册机制使用现有的类，只要这些类有`declare_parameters()`和`parse_parameters()`成员。     


这里就是这种情况，使得利用[2.x.206]类相当容易：不要求用户在代码中为RHS、边界函数等创建新的Function对象（就像在其他大多数教程中那样），这里我们允许用户使用deal.II接口到muParser（http://muparser.beltoforion.de），其中函数的规范不是在编译时完成，而是在运行时，使用一个字符串，被解析成一个实际的Function对象。     


在这种情况下，`embedded_configuration_function`是一个向量值的Function，根据`parameters.use_displacement`的布尔值，可以被解释为*变形*或*位移*。分量的数量将在后面的结构中指定。







[1.x.75] 



我们做同样的事情来指定函数的值 [2.x.207] ，这就是我们希望我们的解决方案在嵌入空间中的值。在这种情况下，该函数是一个标量函数。

[1.x.76] 



与我们对[2.x.208]类所做的类似，我们对ReductionControl类重复同样的做法，允许我们为我们稍后使用的Schur complement迭代求解器指定所有可能的停止标准。

[1.x.77] 



接下来，我们收集所有我们需要的SparsityPattern、SparseMatrix和Vector对象 

[1.x.78] 



TimerOutput类被用来提供一些关于我们程序性能的统计数据。

[1.x.79] 




[1.x.80] [1.x.81]    


在构造时，我们也要初始化ParameterAcceptor类，用我们希望我们的问题在解析参数文件时使用的章节名称。   


参数文件可以被组织成section/subsection/etc.：这样做的好处是，当共享同一section/subsection/etc.时，定义的对象可以共享参数。ParameterAcceptor允许使用Unix约定的路径来指定部分名称。如果部分名称以斜线（"/"）开头，那么该部分将被解释为*绝对路径*，ParameterAcceptor为路径中的每个目录输入一个小节，使用它遇到的最后一个名称作为当前类的登陆小节。   


例如，如果你使用`ParameterAcceptor("/first/second/third/My Class")`构建你的类，参数将被组织如下。   


 [2.x.209]     


在内部，存储在ParameterAcceptor中的*当前路径现在被认为是"/first/second/third/"，也就是说，当你指定一个绝对路径时，ParameterAcceptor*改变*当前的部分为当前路径，也就是改变*最后*"/"之前的部分名称的路径。   


你现在可以使用相对路径（例如，`ParameterAcceptor("My Other Class")`）而不是绝对路径（例如，`ParameterAcceptor("/first/second/third/My Other Class")`）来构造从ParameterAcceptor派生的另一个类，获取。 [2.x.210]     


如果部分名称*以斜线结尾，那么后续的类将把它解释为全路径：例如，与上面类似，如果我们有两个类，一个用`ParameterAcceptor("/first/second/third/My Class/")`初始化，另一个用`ParameterAcceptor("My Other Class")`，那么得到的参数文件将看起来像。   


 [2.x.211]     


我们将利用这一点，使我们的`Parameters`成为所有后续构建的类的*父类。由于大多数其他类都是`DistributedLagrangeProblem'的成员，这允许，例如，为两个不同的维度构建两个`DistributedLagrangeProblem'，而不会在这两个问题的参数中出现冲突。

[1.x.85] 



[2.x.212]函数做了几件事。

     




- 向ParameterAcceptor输入在构造时指定的分节。

     




- 调用[2.x.213]函数 

     




- 调用你可能附加到[2.x.214]的任何信号  

     




- 离开该小节      


反过来，[2.x.215]也是如此。 

     




- 声明给定变量的参数处理程序中的一个条目。

     




- 获取该变量的当前值 

     




- 将其转换为字符串，作为参数文件的默认值使用 

     




- 在[2.x.216]中附加一个*动作，当文件被解析时，或者当一个条目被设置时，它会更新传递给`add_parameter()`的变量的值，将其设置为输入文件中指定的值（当然，是在输入文件被解析并将文本表示转换为变量的类型之后）。

[1.x.86] 



一旦参数文件被解析，那么参数就可以使用了。将内部变量`initialized`设置为true。

[1.x.87] 



构造函数是非常标准的，除了前面解释的`ParameterAcceptorProxy`对象之外。

[1.x.88] 



这里有一种为使用ParameterAcceptorProxy构造的ParameterAcceptor类设置默认值的方法。     


在这种情况下，我们将嵌入式网格的默认变形设置为半径为[2.x.217]、中心为[2.x.218]的圆，我们将embedded_value_function的默认值设置为常数，并为SolverControl对象指定一些合理的值。     


嵌入[2.x.219]是最基本的：从[2.x.220]的定义可以看出，如果[2.x.221]，矩阵[2.x.222]的某些行将是零。这将是一个问题，因为舒尔补码法要求[2.x.223]具有全列秩。

[1.x.89] 




[1.x.90] [1.x.91]。   


函数[2.x.224]是用来设置有限元空间的。注意[2.x.225]是如何用来创建包裹在[2.x.226]对象内的对象的。

[1.x.92] 



初始化[2.x.227]：构造三角形并将其包裹到[2.x.228]对象中。

[1.x.93] 



接下来，我们使用[2.x.229]实际创建三角形，最后一个参数被设置为true：这激活了着色（即为边界的不同部分分配不同的边界指标），我们用它来分配Dirichlet和Neumann条件。

[1.x.94] 



一旦我们构建了一个三角形，我们就根据参数文件中的规格对其进行全局细化，并用它构建一个[2.x.230]。

[1.x.95] 



嵌入网格也是这样做的。由于嵌入式网格是变形的，我们首先需要设置变形映射。我们在下面几行中这样做。

[1.x.96] 



一旦我们为变形定义了一个有限维度的空间，我们就对参数文件中定义的`embedded_configuration_function`进行插值。

[1.x.97] 



现在我们可以根据用户在参数文件中指定的内容来解释它：作为位移，在这种情况下，我们构建一个映射，将我们配置有限元空间的每个支撑点的位置在相应的配置矢量上*移开指定的量，或者作为赦免位置。     


在第一种情况下，MappingQEulerian类提供其服务，而在第二种情况下，我们将使用MappingFEField类。它们实际上是非常相似的。MappingQEulerian只适用于FE_Q有限元空间系统，其中位移矢量存储在FES系统的第一个`spacedim`分量中，并且在构造时作为参数给出的度数必须与第一个`spacedim`分量的度数一致。     


MappingFEField类稍显一般，因为它允许你在构造近似时选择任意的FiniteElement类型。当然，根据你选择的FiniteElement的类型，一些选择可能（也可能没有）意义。MappingFEField实现了纯粹的等参量概念，例如，可以通过与FE_Bernstein有限元类结合，在deal.II中实现等参量分析代码。在这个例子中，我们将考虑到一个配置将是一个 "位移"，而另一个将是一个绝对的 "变形 "场，从而将两者互换使用。







[1.x.98] 



在这个教程程序中，我们不仅对[2.x.231]进行全局细化，还允许根据[2.x.232]的位置进行局部细化，根据`parameters.delta_refinement`的值，我们用来决定我们应该对[2.x.233]进行多少轮局部细化，对应于[2.x.234]的位置。     


有了这个映射，现在就可以通过调用方法[2.x.235]来查询与`嵌入式_dh'相关的所有支持点的位置。      


这个方法有两个变体。一种是不接受Mapping，另一种是接受Mapping。如果你使用第二种类型，就像我们在这个案例中做的那样，支持点是通过指定的映射来计算的，它可以相应地处理它们。     


这正是`embedded_mapping`的作用。

[1.x.99] 



一旦我们有了嵌入有限元空间的支持点，我们就想确定嵌入空间的哪些单元包含哪些支持点，以便有机会在必要的地方，即嵌入网格的地方细化嵌入网格。这可以手动完成，通过循环每个支持点，然后为嵌入空间的每个单元调用方法[2.x.236]，直到我们找到一个返回单位参考单元中的点，或者可以用更智能的方式完成。     


[2.x.237]是一个可能的选择，它以更便宜的方式执行上述任务，首先确定嵌入三角的最接近目标点的顶点，然后只对那些共享找到的顶点的单元格调用[2.x.238]。     


事实上，在GridTools命名空间中，有一些算法利用[2.x.239]对象，可能还有KDTree对象来尽可能地加快这些操作。     


利用最大速度的最简单的方法是调用一个专门的方法，[2.x.240]，它将在第一个点的搜索过程中存储大量有用的信息和数据结构，然后在后续的点中重复使用所有这些信息。     


 [2.x.241]返回一个元组，其中第一个元素是一个包含输入点的单元格向量，在这里是support_points。对于细化来说，这是我们唯一需要的信息，而这正是现在所发生的。     


然而，当我们需要组装一个耦合矩阵时，我们还需要每个点的参考位置来评估嵌入空间的基础函数。由[2.x.242]返回的元组的其他元素允许你重建，对于每个点，什么单元包含它，以及什么是给定点的参考单元的位置。由于这些信息最好被分组到单元格中，那么这就是算法返回的内容：一个元组，包含所有单元格中至少有一个点的向量，以及所有参考点的列表和它们在原始向量中的相应索引。     


在下面的循环中，我们将忽略所有返回的对象，除了第一个，确定所有单元格至少包含一个嵌入空间的支持点。这允许一个简单的自适应细化策略：细化这些单元和它们的邻居。     


请注意，我们需要做一些理智的检查，在这个意义上，我们希望有一个嵌入网格，它在嵌入网格周围被很好地细化，但其中两个连续的支持点要么位于同一个单元，要么位于邻居嵌入单元。     


只有当我们确保嵌入网格的最小单元尺寸仍然大于嵌入网格的最大单元尺寸时，这才有可能。由于用户可以修改细化水平，以及他们想要的嵌入网格周围的局部细化量，我们要确保所得到的网格满足我们的要求，如果不是这样，我们就用一个例外来保释。

[1.x.100] 



为了构造一个良好的耦合插值算子[2.x.243]，对嵌入域和被嵌入域之间的网格的相对尺寸有一些约束。耦合算子[2.x.244]和空间[2.x.245]和[2.x.246]必须满足一个inf-sup条件，以使问题有一个解决方案。事实证明，只要空间[2.x.248]和[2.x.249]之间相互兼容，非匹配[2.x.247]投影就满足这样的inf-sup条件（例如，只要它们被选为引言中描述的那些）。     


然而，*离散*的inf-sup条件也必须成立。这里没有出现复杂的情况，但事实证明，当非匹配网格的局部直径离得太远时，离散的inf-sup常数会恶化。特别是，事实证明，如果你选择一个相对于嵌入网格而言*细的嵌入网格，那么inf-sup常数的恶化程度要比让嵌入网格更细的情况下大得多。     


为了避免问题，在本教程中，如果用户选择的参数使嵌入网格的最大直径大于嵌入网格的最小直径，我们将抛出一个异常。     


这种选择保证了几乎每个嵌入网格的单元都不超过两个嵌入网格的单元，只有一些罕见的例外，这些例外在结果的inf-sup方面可以忽略不计。

[1.x.101] 



 [2.x.250]已被完善，我们现在可以设置它的DoF了 

[1.x.102] 



我们现在设置[2.x.251]和[2.x.252]的DoF：因为它们基本上是独立的（除了[2.x.253]的网格在[2.x.254]周围更加精细之外），这个过程是标准的。

[1.x.103] 



根据定义，刚度矩阵只涉及[2.x.255]的DoF。

[1.x.104] 



根据定义，我们要解决的系统的Rhs只涉及一个零矢量和[2.x.256]，它只用[2.x.257]的DoF来计算。

[1.x.105] 



创建耦合稀疏模式是一个复杂的操作，但可以使用[2.x.258]轻松完成，它需要两个DoFHandler对象，耦合的正交点，一个DynamicSparsityPattern（然后需要像往常一样复制到稀疏模式中），嵌入和嵌入三角的分量掩码（我们留空）以及嵌入和嵌入三角的映射关系。

[1.x.106] 




[1.x.107] [1.x.108]    


以下函数创建矩阵：如前所述，计算刚度矩阵和rhs是一个标准程序。

[1.x.109] 



嵌入刚度矩阵 [2.x.259] ，以及右手边 [2.x.260] 。

[1.x.110] 



为了计算耦合矩阵，我们使用[2.x.261]工具，其工作原理与[2.x.262]类似。 

[1.x.111] 




[1.x.112] [1.x.113]。   


所有部件都已组装完毕：我们使用舒尔补数法解决该系统 

[1.x.114] 



首先创建反刚度矩阵 

[1.x.115] 



初始化算子，如介绍中所述 

[1.x.116] 



使用舒尔补码法 

[1.x.117] 



下面的函数只是在两个独立的文件上生成标准结果输出，每个网格一个。

[1.x.118] 



这两个输出例程的唯一区别是，在第二种情况下，我们希望输出当前配置的数据，而不是参考配置的数据。这可以通过将实际的embedded_mapping传递给[2.x.263]函数来实现。该映射将负责输出实际变形配置的结果。







[1.x.119] 



与所有其他教程程序类似，`run()`函数只是按照正确的顺序调用所有其他方法。没有什么特别需要注意的，只是在我们实际尝试运行我们的程序之前，我们检查是否完成了解析。

[1.x.120] 



与其他教程程序中的情况不同，这里我们使用ParameterAcceptor风格的初始化，即首先构造所有对象，然后对静态方法[2.x.264]发出一次调用，以填充从ParameterAcceptor派生的类的所有参数。       


我们检查用户是否在程序启动时指定了一个参数文件名来使用。如果是，就尝试读取该参数文件，否则就尝试读取文件 "parameters.prm"。       


如果指定的参数文件（隐式或显式）不存在，[2.x.265] 将为你创建一个，并退出程序。







[1.x.121] 

[1.x.122][1.x.123] 。


运行该程序的目录默认不包含参数文件。另一方面，这个程序想从一个叫做parameters.prm的文件中读取它的参数 -- 因此，当你第一次执行它时，你会得到一个异常，即找不到这样的文件。

[1.x.124] 



然而，正如错误信息已经指出的那样，触发该异常的代码也将生成一个参数.prm文件，该文件只包含该程序所关心的所有参数的默认值。通过对参数文件的检查，我们看到以下内容。

[1.x.125] 



如果你现在运行这个程序，你会得到一个叫做`used_parameters.prm`的文件，其中包含上述参数的一个较短版本（没有注释和文档），记录了运行程序时使用的所有参数。

[1.x.126] 



首先创建`parameters.prm`文件（第一次运行程序），然后创建`used_parameters.prm`（每隔一段时间运行程序），其理由是你可能想让大多数参数保持其默认值，而只修改少数几个参数。

例如，你可以在这个教程程序中使用以下（完全有效的）参数文件。

[1.x.127] 



你会得到与下面测试案例1完全相同的结果。

[1.x.128][1.x.129] 。


对于默认问题，[2.x.266]在[2.x.267]上的值被设置为常数[2.x.268]：这就像在[2.x.269]上施加一个常数迪里切特边界条件，被视为[2.x.270]在[2.x.271]内的部分的边界。同样，在[2.x.272]上我们有零迪里希特边界条件。


 [2.x.273]  

该程序的输出结果将如下。

[1.x.130] 



你可能会注意到，就CPU时间而言，组装耦合系统的成本是组装标准泊松系统的两倍，尽管矩阵更小。这是由于离散化的非匹配性造成的。这是否可以接受，取决于应用。

如果问题被设置在三维环境中，并且浸入式网格是随时间变化的，那么在每一步重新创建网格要比使用我们这里介绍的技术要昂贵得多。此外，你也许可以在一个均匀细化的正方形或立方体网格上创建一个非常快速和优化的求解器，并在你想进行计算的地方嵌入这里的技术。这将要求你只有一个领域的表面代表（一个更便宜和更容易制作的网格）。

为了玩一玩，我们要把虚构的域以及我们强加给它的边界条件复杂化一点。

[1.x.131][1.x.132] 。


如果我们使用下面的参数文件。

[1.x.133] 



我们得到一个看起来 "花花绿绿 "的域，在这里我们施加一个线性边界条件 [2.x.274] 。这个测试表明，该方法在从其边界条件中恢复一个完全线性的函数方面实际上是相当准确的，即使网格没有对齐，我们也得到了一个相当好的结果。

用[2.x.276]替换[2.x.275]，即修改参数文件，使我们有 

[1.x.134] 

产生右边的马鞍。

 [2.x.277]  

[1.x.135] [1.x.136][1.x.137] 。


[1.x.138][1.x.139]。


虽然目前的教程程序是为`spacedim`等于2而编写的，但为了使程序在不同的尺寸组合中运行，你只需要做一些小的改动。

如果你想在`spacedim`等于3，`dim`等于2的情况下运行，那么你几乎肯定要做以下改变。

- 为嵌入式网格使用不同的参考域，也许是从文件中读取。不可能用一个正方形域的单一参数来构造一个光滑的封闭表面，因此你很可能想使用一个拓扑学上等同于球体边界的参考域。

- 使用位移代替变形，将[2.x.278]映射到[2.x.279]。 

[1.x.140][1.x.141]。


我们已经在其他教程中看到（例如在[2.x.280]和[2.x.281]中）如何从输入文件中读取网格。对于这个教程程序来说，一个很好的概括是允许用户从参数文件本身选择要读取的网格，而不是在教程程序本身硬编码网格类型。

[1.x.142][1.x.143] 。


目前，我们没有关于Schur补数的预处理程序。这对于二维问题来说是可以的，几百次的迭代就可以将残差降低到机器的精度，但是这在三维中是行不通的。

在这里，一个好的预处理程序是什么并不明显。我们用舒尔补码解决的物理问题是将迪里切特数据 [2.x.282] 与拉格朗日乘数的值联系起来 [2.x.283] 。 [2.x.284]可以解释为法线梯度的*跳跃，需要强加在[2.x.285]上，跨越[2.x.286]，以获得Dirichlet数据 [2.x.287]。

所以[2.x.288]是某种诺伊曼到迪里切特的地图，我们希望有一个好的迪里切特到诺伊曼地图的近似值。一种可能性是使用[2.x.289]上的问题的边界元素近似，并构建与[2.x.290]相关的泊松问题的超星形算子的粗略近似，这正是迪里切特到诺依曼映射。

[1.x.144][1.x.145] 


这里提出的简单代码可以作为更复杂问题的起点，要解决这些问题，需要在并行代码上运行，可能使用分布式网格（见[2.x.291]，[2.x.292]，以及[2.x.293]和[2.x.294]的文档）。 

当并行使用非匹配网格时，会出现一个问题：为了计算矩阵[2.x.295]，一个进程需要关于实空间同一区域的两个网格的信息，但是，当使用分布式网格时，这种信息可能无法获得，因为存储在特定处理器上的[2.x.296]三角形的本地所有部分可能与存储在同一处理器上的[2.x.297]三角形的本地所有部分不在同一地点。

可以实施各种策略来解决这个问题。

- 分布两个网格，以便满足这个约束条件。

- 对不满足该约束的实空间部分使用通信。

- 对嵌入空间使用分布式三角法，对嵌入配置使用共享三角法。

后一种策略显然是最容易实现的，因为本教程程序中使用的大多数函数在并行情况下也能不变地工作。当然，我们可以使用反转策略（即有一个分布式嵌入三角图和一个共享嵌入三角图）。

然而，这种策略很可能会更加昂贵，因为根据定义，嵌入网格要比嵌入网格大，而且分布这两个网格中最大的网格更有意义，保持最小的网格在所有处理器中共享。[1.x.146] [1.x.147] [2.x.298]  

 [2.x.299] 
