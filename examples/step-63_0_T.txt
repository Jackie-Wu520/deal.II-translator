 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17 ][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33] 

 [2.x.3]  

[1.x.34] 

 [2.x.4]  

[1.x.35] [1.x.36][1.x.37]。


该程序使用几何多网格(GMG)预处理程序解决一个平流-扩散问题。该预处理程序的基本原理在[2.x.5]中讨论；这里我们讨论非对称PDE所需的必要变化。此外，我们还介绍了块平滑的概念（与[2.x.6]中的点平滑相比），并检查了加法和乘法平滑器的DoF重编号的效果。

[1.x.38][1.x.39] 

平流-扩散方程由以下公式给出 

[1.x.40] 

其中[2.x.7] ，[2.x.8]是[1.x.41]，[2.x.9]是一个源。有几个注意事项。

1. 如果[2.x.10]，这是[2.x.11]中解决的拉普拉斯方程（以及其他许多地方）。

2. 如果[2.x.12]，那么这就是[2.x.13]中解决的静止平流方程。

3. 人们可以为这个问题定义一个无量纲数，称为[1.x.42]。 [2.x.14] ，其中[2.x.15] 是域的长度尺度。它描述了我们所考虑的那种方程的特点。如果[2.x.16]，我们说问题是[1.x.43]，否则如果[2.x.17]，我们会说问题是[1.x.44]。

在本教程的讨论中，我们将关注以平流为主的流动。这是很复杂的情况。我们知道，对于扩散主导的问题，标准的Galerkin方法可以很好地工作，我们也知道简单的多网格方法，如[2.x.18]中定义的方法非常有效。另一方面，对于平流主导的问题，标准Galerkin方法会导致振荡和不稳定的离散，简单的求解器往往不是很有效。因此，本教程程序旨在解决这两个问题。


[1.x.45][1.x.46] 。


使用标准的Galerkin有限元方法，对于合适的测试函数[2.x.19]，PDE的离散弱形式将为 

[1.x.47] 

其中 

[1.x.48] 



不幸的是，用这种方法通常会得到震荡解。事实上，对于这种形式，可以显示出以下误差估计。

[1.x.49] 

如果精确解足够平滑，右边的下限可以被估计为如下。

[1.x.50] 

其中[2.x.20]是所用有限元的多项式程度。因此，我们得到的估计是 

[1.x.51] 

换句话说，数值解会收敛。另一方面，鉴于上述[2.x.21]的定义，我们不得不期待当[2.x.22]时，即如果问题只有少量的扩散时，数值解会很差，而且误差很大。

为了解决这个问题，我们将考虑新的弱形式 

[1.x.52] 

其中总和是在所有单元[2.x.23]上进行的，每个单元都有内积，[2.x.24]是定义在[2.x.25]中的一个单元常数稳定参数。

从本质上讲，加入离散强形式残差会增强双线性形式[2.x.26]的矫顽力，从而增加离散解的稳定性。这种方法通常被称为[1.x.53]或[1.x.54]（流线型上风/Petrov-Galerkin）。


[1.x.55][1.x.56] 。


本教程的目标之一是从使用一个简单的（point-wise）Gauss-Seidel（SOR）平滑器扩展到多网格层次结构的每一级（类PreconditionSOR）。术语 "point-wise "传统上用于求解器，表示每次在一个 "网格点 "上求解；对于标量问题，这意味着使用一个求解器，每次更新线性系统的一个未知数，保持所有其他未知数固定不变；然后在问题中的所有未知数上迭代，一旦完成，从第一个未知数重新开始，直到这些 "扫频 "收敛。雅可比、高斯-赛德尔和SOR迭代都可以用这种方式解释。在多网格的背景下，人们不认为这些方法是 "求解器"，而是 "平滑器"。因此，人们对实际解决线性系统不感兴趣。为了使多网格方法发挥作用，只需去除残差的高频部分即可，因为这可以将解限制在更粗的网格上。 因此，我们只需对所有未知数进行少量的、固定数量的 "扫频"。在本教程的代码中，这是由 "平滑步骤 "参数控制的。

但是这些方法作为求解器使用时，已知收敛速度相当慢。虽然作为多网格平滑器，它们出乎意料地好，但它们也可以被改进。特别是，我们在这里也考虑 "基于单元 "的平滑器。这些方法一次解决一个单元上的所有未知数，保持所有其他未知数的固定；然后它们转到下一个单元，如此反复。我们可以把它们看作是雅可比（Jacobi）、高斯-赛德尔（Gauss-Seidel）或SOR的 "区块 "版本，但由于自由度是在多个单元中共享的，这些区块是重叠的，这些方法实际上最好在加法和乘法施瓦兹方法的框架内解释。

与[2.x.28]不同的是，我们的测试问题包含一个平流项。特别是在扩散常数较小的情况下[2.x.29]，信息是沿着给定的平流方向的流线传输的。这意味着，如果平滑器允许信息在单一平滑器应用中沿下游方向传播，那么平滑器可能会更有效。如果我们想按照这些未知数（或未知数块）的列举顺序一次解决一个未知数（或未知数块），那么这个信息传播特性需要相应地重新排列自由度或单元（对于基于单元的平滑器），以便更上游的自由度被提前处理（指数较低），更下游的自由度被推迟处理（指数较大）。排序的影响将在结果部分可见。

现在让我们简单定义一下本教程中使用的平滑器。关于更详细的介绍，我们参考[2.x.30]以及书籍[2.x.31]和[2.x.32] 。施瓦兹预处理器需要一个分解 

[1.x.57] 

我们的有限元空间 [2.x.33] 的分解。每个子问题 [2.x.34] 也有一个基于双线性形式 [2.x.36] 的里兹投影 [2.x.35] 。这个投影为每个子问题[2.x.38]诱导出一个局部算子 [2.x.37] 。如果[2.x.39]是对[2.x.40]的正交投影，就可以表明[2.x.41]。

由此，我们可以为算子[2.x.42]定义一个[1.x.58]作为 

[1.x.59] 

换句话说，我们将我们的解决方案投射到每个子问题中，应用子问题[2.x.43]的逆，并将所有[2.x.44]的贡献相加。

请注意，通过为每个自由度定义一个子问题[2.x.45]，我们可以将逐点（一次一个未知数）的雅可比方法解释为加法施瓦茨方法。然后，[2.x.46]成为与[2.x.47]的对角线项的逆的乘法。

对于本教程中使用的 "Block Jacobi "方法，我们为当前层次上的网格的每个单元定义一个子问题[2.x.48]。注意，我们使用的是连续有限元，所以这些块是重叠的，因为两个单元之间的界面上的自由度都属于两个子问题。对子问题（在deal.II中它们被称为 "块"）进行操作的施瓦茨算子的逻辑在RelaxationBlock类中实现。块状雅可比 "方法是在RelaxationBlockJacobi类中实现的。该类的许多方面（例如如何定义块以及如何反转局部子问题[2.x.49]）可以在平滑器数据中配置，详见[2.x.50] 和[2.x.51]。

到目前为止，我们讨论了加法平滑器，其中更新可以独立应用，并且在单一平滑器应用中没有信息流动。一个[1.x.60]解决了这个问题，其定义为 

[1.x.61] 

与上述相反，子问题[2.x.52]上的更新是按顺序应用的。这意味着在颠倒子问题[2.x.53]时得到的更新立即被用于[2.x.54]。这在写出项目的时候就可以看到。

[1.x.62] 



当把子空间[2.x.55]定义为整个自由度块时，这个方法在RelaxationBlockSOR类中实现，并在本教程中选择 "块SOR "时使用。RelaxationBlockSOR类也是从RelaxationBlock派生的。因此，加法和乘法的施瓦兹方法都在一个统一的框架内实现。

最后，让我们注意到，标准的Gauss-Seidel（或SOR）方法可以被看作是一个乘法施瓦兹方法，每个DoF都有一个子问题。


[1.x.63][1.x.64] 


我们将考虑以下测试问题：[2.x.56] ，即一个以原点为圆心的半径为0.3的正方形被移除。此外，我们使用[2.x.57], [2.x.58], [2.x.59], 和迪里切特边界值 

[1.x.65] 



下面的数字描述了有（左）和无（右）流线扩散的解决方案。在没有流线扩散的情况下，我们看到边界层周围有很大的振荡，这表明标准Galerkin有限元方法对这个问题的不稳定性。

 [2.x.60] [1.x.66] [1.x.67] 


[1.x.68] [1.x.69] 




标准deal.II需要的典型文件。

[1.x.70] 



包括所有相关的多层次文件。

[1.x.71] 



C++: 

[1.x.72] 



我们将使用[2.x.61]功能来组装矩阵。

[1.x.73] 




[1.x.74] [1.x.75] 




像往常一样，我们将把所有与这个程序相关的东西放到一个自己的命名空间中。




由于我们将使用MeshWorker框架，第一步是定义以下由[2.x.62]使用的assemble_cell()函数所需要的结构 `ScratchData`包含一个FEValues对象，这是组装一个单元的局部贡献所需要的，而`CopyData`包含一个单元的局部贡献的输出以及复制到全局系统的必要信息。它们的目的在WorkStream类的文档中也有解释）。

[1.x.76] 




[1.x.77] [1.x.78] 




第二步是定义处理要从输入文件中读取的运行时参数的类。   


我们将使用ParameterHandler在运行时传入参数。结构`Settings`解析并存储整个程序要查询的参数。

[1.x.79] 




[1.x.80] [1.x.81]    


单元和自由度被遍历的顺序将对乘法的收敛速度起作用。在这里，我们定义了一些函数，这些函数返回单元的特定排序，供块平滑器使用。   


对于每种类型的单元排序，我们定义了一个适用于活动网格的函数和一个适用于水平网格的函数（即适用于多网格层次结构中的某一层的单元）。虽然求解系统所需的唯一重新排序是在水平网格上进行的，但我们在output_results()中包含了主动网格的重新排序，以达到可视化的目的。   


对于两个下游排序函数，我们首先创建一个包含所有相关单元的数组，然后使用一个 "比较器 "对象在下游方向进行排序。然后，函数的输出是一个简单的数组，包含了刚刚计算出的排序中的单元格的索引。

[1.x.82] 



产生随机排序的函数在精神上是相似的，它们首先将所有单元格的信息放入一个数组。但是，它们不是对它们进行排序，而是利用C++提供的生成随机数的设施对元素进行随机洗牌。这样做的方式是在数组的所有元素上进行迭代，为之前的另一个元素抽取一个随机数，然后交换这些元素。其结果是对数组中的元素进行随机洗牌。

[1.x.83] 




[1.x.84] [1.x.85] 




本教程中解决的问题是对[1.x.86]第118页上的例3.1.3的改编。主要区别在于我们在域的中心添加了一个洞，其边界条件为零的迪里希特。   


为了进行完整的描述，我们需要首先实现零右手边的类（当然我们可以直接使用[2.x.63]  

[1.x.87] 



我们还有Dirichlet边界条件。在外部正方形边界的连接部分，我们将数值设置为1，而在其他地方（包括内部圆形边界），我们将数值设置为0。

[1.x.88] 



如果[2.x.64]，或者如果[2.x.65]和[2.x.66]，将边界设置为1。

 




[1.x.90] [1.x.91] 




流线扩散法有一个稳定常数，我们需要能够计算出来。这个参数如何计算的选择来自于[1.x.92]。

[1.x.93] 




[1.x.94] [1.x.95]。




这是程序的主类，看起来应该与 [2.x.67] 非常相似。主要的区别是，由于我们是在运行时定义我们的多网格平滑器，我们选择定义一个函数`create_smoother()`和一个类对象`mg_smoother`，这是一个 [2.x.68] 派生自MGSmoother的平滑器。请注意，对于从RelaxationBlock派生的平滑器，我们必须为每个级别包括一个`smoother_data`对象。这将包含关于单元格排序和单元格矩阵倒置方法的信息。







[1.x.96] 




[1.x.97] [1.x.98] 




在这里，我们首先为活动和多网格级网格设置DoFHandler、AffineConstraints和SparsityPattern对象。   


我们可以用DoFRenumbering类对活动DoF进行重新编号，但是平滑器只作用于多网格层，因此，这对计算并不重要。相反，我们将对每个多网格层次上的DoFs进行重新编号。

[1.x.99] 



在列举了全局自由度以及（上面最后一行）层次自由度之后，让我们对层次自由度进行重新编号，以获得一个更好的平滑器，正如介绍中所解释的那样。 如果需要的话，下面的第一个区块会对下游或上游方向的每个层次的自由度进行重新编号。这只对点平滑器（SOR和Jacobi）有必要，因为块平滑器是在单元上操作的（见`create_smoother()`）。然后下面的块也实现了随机编号。

[1.x.100] 



该函数的其余部分只是设置了数据结构。下面代码的最后几行与其他GMG教程不同，因为它同时设置了接口输入和输出矩阵。我们需要这样做，因为我们的问题是非对称性的。

[1.x.101] 




[1.x.102] [1.x.103] 




这里我们定义了每个单元上的线性系统的装配，以便被下面的Mesh_loop()函数使用。这个函数为活动单元或水平单元装配单元矩阵（不管它的第一个参数是什么），并且只有在调用活动单元时才装配右手边。







[1.x.104] 



如果我们使用流线扩散，我们必须将其贡献添加到单元矩阵和单元右手边。如果我们不使用流线扩散，设置[2.x.69]就会否定下面的贡献，我们就只能使用标准的Galerkin有限元组合。

[1.x.105] 



局部矩阵的组装有两个部分。首先是Galerkin贡献。

[1.x.106] 



然后是流线扩散贡献。

[1.x.107] 



这同样适用于右手边。首先是Galerkin贡献。

[1.x.108] 



然后是流线扩散贡献。

[1.x.109] 




[1.x.110] [1.x.111] 。




在这里，我们采用[2.x.70]来翻阅单元格，为我们组装system_matrix、system_rhs和所有mg_matrices。







[1.x.112] 



与活动层的约束不同，我们选择为这个函数的每个多网格层创建约束对象，因为它们在程序的其他地方不需要。

[1.x.113] 



如果[2.x.71]是一个`interface_out` dof对，那么[2.x.72]是一个`interface_in` dof对。注意：对于 "interface_in"，我们加载接口条目的转置，即，dof对[2.x.73]的条目被存储在 "interface_in(i,j)"。这是对对称情况的优化，允许在solve()中设置边缘矩阵时只使用一个矩阵。然而，在这里，由于我们的问题是非对称的，我们必须同时存储`interface_in`和`interface_out`矩阵。

[1.x.114] 




[1.x.115][1.x.116] 。




接下来，我们根据`.prm`文件中的设置来设置平滑器。两个重要的选项是多网格v周期每一级的平滑前和平滑后步骤的数量以及松弛参数。




由于乘法方法往往比加法方法更强大，所以需要较少的平滑步骤来看到收敛，与网格大小无关。块平滑器比点平滑器的情况也是如此。这反映在下面对每种平滑器的平滑步骤数的选择上。




点平滑器的松弛参数是在试验和错误的基础上选择的，它反映了在我们细化网格时保持GMRES求解的迭代次数不变（或尽可能接近）的必要值。在`.prm`文件中给 "Jacobi "和 "SOR "的两个值是针对1度和3度有限元的。如果用户想改成其他度数，他们可能需要调整这些数字。对于块平滑器，这个参数有一个更直接的解释，即对于二维的加法，一个DoF可以有多达4个单元的重复贡献，因此我们必须将这些方法放松0.25来补偿。对于乘法来说，这不是一个问题，因为每个单元的逆向应用都会给其所有的DoF带来新的信息。




最后，如上所述，点平滑器只对DoF进行操作，而块平滑器对单元进行操作，因此只有块平滑器需要被赋予有关单元排序的信息。点平滑器的DoF排序已经在`setup_system()`中得到了处理。







[1.x.117] 




[1.x.118] [1.x.119]。




在求解系统之前，我们必须首先设置多网格预处理程序。这需要设置各级之间的转换、粗略矩阵求解器和平滑器。这个设置几乎与[2.x.74]相同，主要区别在于上面定义的各种平滑器，以及由于我们的问题是非对称性的，所以我们需要不同的界面边缘矩阵。实际上，在本教程中，这些接口矩阵是空的，因为我们只使用全局细化，因此没有细化边。然而，我们在这里仍然包括了这两个矩阵，因为如果人们简单地切换到自适应细化方法，程序仍然可以正确运行）。) 




最后要注意的是，由于我们的问题是非对称的，我们必须使用适当的Krylov子空间方法。我们在这里选择使用GMRES，因为它提供了在每次迭代中减少残差的保证。GMRES的主要缺点是，每次迭代，存储的临时向量的数量都会增加一个，而且还需要计算与之前存储的所有向量的标量积。这是很昂贵的。通过使用重启的GMRES方法可以放松这一要求，该方法对我们在任何时候需要存储的向量数量设置了上限（这里我们在50个临时向量后重启，即48次迭代）。这样做的缺点是我们失去了在整个迭代过程中收集的信息，因此我们可以看到收敛速度较慢。因此，在哪里重启是一个平衡内存消耗、CPU工作量和收敛速度的问题。然而，本教程的目标是通过使用强大的GMG预处理程序来实现非常低的迭代次数，所以我们选择了重启长度，使下面显示的所有结果在重启发生之前就能收敛，因此我们有一个标准的GMRES方法。如果用户有兴趣，在deal.II中提供的另一种合适的方法是BiCGStab。







[1.x.120] 




[1.x.121][1.x.122] 。




最后一个感兴趣的功能是生成图形输出。这里我们以.vtu格式输出解决方案和单元格排序。




在该函数的顶部，我们为每个单元生成一个索引，以可视化平滑器使用的排序。请注意，我们只对活动单元而不是平滑器实际使用的层次做这个处理。对于点平滑器，我们对DoFs而不是单元进行重新编号，所以这只是对现实中发生的情况的一种近似。最后，随机排序不是我们实际使用的随机排序（见`create_smoother()`）。   


然后，单元格的（整数）排序被复制到一个（浮点）矢量，用于图形输出。

[1.x.123] 



然后，考虑到以前的教程程序，函数的其余部分就很简单了。

[1.x.124] 




[1.x.125] [1.x.126]。




和大多数教程一样，这个函数创建/细化网格并调用上面定义的各种函数来设置、装配、求解和输出结果。




在第0个循环中，我们在正方形[2.x.75]上生成网格，半径为3/10单位的洞以原点为中心。对于`manifold_id`等于1的对象（即与洞相邻的面），我们指定一个球面流形。







[1.x.127] 




[1.x.128][1.x.129] 。




最后，主函数与大多数教程一样。唯一有趣的一点是，我们要求用户传递一个`.prm`文件作为唯一的命令行参数。如果没有给出参数文件，程序将把所有默认值的样本参数文件的内容输出到屏幕上，然后用户可以复制并粘贴到自己的`.prm`文件中。







[1.x.130] 

[1.x.131][1.x.132]。


[1.x.133][1.x.134]。


GMG的主要优势在于它是一种[2.x.76]方法，也就是说，问题的复杂性随着问题的大小而线性增加。为了证明本教程中介绍的线性求解器实际上是[2.x.77]，我们只需要证明GMRES求解的迭代次数在我们细化网格时保持大致不变。

以下各表给出了GMRES的迭代次数，以减少初始残差的系数[2.x.78]。我们选择了足够数量的平滑步骤（基于方法），以获得独立于网格大小的迭代数。从下面的表格可以看出，该方法确实是[2.x.79] 。

[1.x.135][1.x.136] 。


逐点平滑器（"Jacobi "和 "SOR"）是按照每层的DoFs编号顺序来应用的。我们可以使用DoFRenumbering命名空间来影响这一点。块平滑器的应用是基于我们在`setup_smoother()`中设置的顺序。我们可以直观地看到这个编号。下面的图片显示了在下游、随机和上游编号的活动单元格的编号（从左到右）。

 [2.x.80]  

让我们从加法平滑器开始。下表显示了从GMRES获得收敛所需的迭代次数。

 [2.x.81]  

我们看到，重新编号DoFs/单元对收敛速度没有影响。这是因为这些平滑器独立计算每个DoF（点平滑器）或单元（块平滑器）的操作，并将结果相加。由于我们可以将这些平滑器定义为矩阵之和的应用，而矩阵加法是换元的，所以我们对不同组件进行加法的顺序不会影响最终结果。

另一方面，乘法平滑器的情况则不同。

 [2.x.82]  

在这里，我们可以通过在平流方向上对DoF/单元进行重新编号来加速收敛，同样，如果我们在相反的方向上进行重新编号，我们可以减缓收敛。这是因为平流主导的问题有一个信息流的方向性（平流方向），如果对DoFs/单元进行正确的重新编号，乘法就能抓住这个方向。

然而，乘法的这一特点取决于[2.x.83]的值。当我们增加[2.x.84]，问题变得更加以扩散为主时，我们在网格上的信息传播更加均匀，在平流方向上重新编号的优势就会减弱。相反，在[2.x.85]的极端情况下（仅有平流），我们有一个一阶PDE，具有正确重编号的乘法成为有效的求解器。正确的下游编号可能导致方法只需要一次迭代，因为信息可以从流入边界向下游传播，而没有相反方向的信息传输。然而，请注意，在[2.x.86]的情况下，必须对这种情况下的边界条件给予特别关注）。


[1.x.137][1.x.138] 。


我们将把结果限制在使用下游重新编号的运行上。下面是对[2.x.87]和[2.x.88]两个元素的所有四个平滑器的交叉比较。

 [2.x.89]  

我们看到，对于[2.x.90]，两个乘法平滑器需要的平滑步骤和迭代次数的组合都比加法平滑器小。然而，当我们将度数增加到[2.x.91]元素时，在平滑步骤和迭代次数方面，块平滑器有明显的优势。具体来说，块状SOR平滑器在度数上给出了恒定的迭代次数，而块状Jacobi平滑器的迭代次数只增加了约38%，而Jacobi和SOR的迭代次数分别为75%和183%。

[1.x.139][1.x.140] 。


迭代次数并不能完全说明一种平滑器比另一种平滑器的最优性。很明显，我们必须检查迭代的成本。块状平滑器在这里处于不利地位，因为它们必须为每个单元构建和反转一个单元矩阵。下面是一个具有74,496个DoF的[2.x.92]元素的求解时间的比较。

 [2.x.93]  

需要最多迭代的平滑器（Jacobi）实际上需要最短的时间（大约是下一个最快方法的2/3）。这是因为应用Jacobi平滑步骤所需要的只是乘以一个对角线矩阵，这是非常便宜的。另一方面，虽然SOR比块SOR需要超过3倍的迭代（每个迭代有3倍的平滑步骤），但时间大致相当，这意味着块SOR的一个平滑步骤比SOR的一个平滑步骤大约慢9倍。最后，Jacobi块比SOR块的成本高6倍，这从每个方法的1个步骤具有相同的成本（反转单元格矩阵并将其相加或相乘），而Jacobi块每次迭代的平滑步骤数是2次迭代的3倍，这在直觉上是合理的。


[1.x.141][1.x.142] 


还有几个重要的点要提到。

 [2.x.94] [2.x.95] 对于平行分布的网格，乘法不能在整个领域内执行。这是因为它们一次操作一个单元，下游的单元只有在上游的单元已经完成后才能被处理。这在单个处理器上是没有问题的。处理器只是一个接一个地浏览单元的列表。然而，在并行的情况下，这将意味着一些处理器是空闲的，因为上游处理器还没有完成对当前处理器所拥有的上游单元的工作。一旦上游处理器完成，下游处理器就可以开始工作，但那时上游处理器已经没有工作了。换句话说，在这些平稳的步骤中，大部分时间，大多数处理器实际上是空闲的。这不是获得良好的并行可扩展性的方法! 

我们可以使用一种混合方法，即在每个子域上应用乘法平滑器，但是当你增加子域的数量时，该方法接近于加法的行为。这是这些方法的一个主要缺点。 [2.x.96]  

 [2.x.97] 目前对块平滑器的研究表明，很快我们将能够计算单元矩阵的逆，比目前在deal.II里面做的要便宜得多。这项研究是基于快速对角线化方法（可追溯到20世纪60年代），并在光谱界使用了约20年（见，例如，[1.x.143]）。目前，人们正在努力将这些方法推广到DG，并使其更加稳健。此外，人们似乎应该能够利用无矩阵实现的优势，以及在域的内部，单元矩阵往往看起来非常相似的事实，允许更少的矩阵逆计算。 [2.x.98][2.x.99] 。 

结合1.和2.给出了一个很好的理由，期望像块状雅可比这样的方法在未来会变得非常强大，尽管目前对这些例子来说它是相当慢的。


[1.x.144][1.x.145] 。


[1.x.146][1.x.147]。


改变平滑步骤的数量和平滑器松弛参数（在[2.x.100]中设置在[2.x.101]里面，只对点平滑器有必要），以便我们对一个[2.x.102]元素保持恒定的迭代次数。

[1.x.148][1.x.149] 。


增加/减少乘法的`.prm`文件中的参数 "Epsilon"，观察哪些数值的重新编号不再影响收敛速度。

[1.x.150][1.x.151] 。


该代码已被设置为能在自适应细化的网格中正常工作（界面矩阵已创建并设置）。设计一个合适的细化标准或尝试KellyErrorEstimator类。[1.x.152] [1.x.153] [2.x.103] 。 

 [2.x.104] 
