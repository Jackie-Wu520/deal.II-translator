 [2.x.0][2.x.1] 。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17 ][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33] 

[1.x.34] [1.x.35][1.x.36]。


 [2.x.3]  

这个程序致力于两个方面：使用混合有限元--特别是Raviart-Thomas元--以及使用块状矩阵来定义求解器、预处理器和使用系统矩阵的子结构的嵌套版本。我们要解决的方程仍然是泊松方程，尽管有一个矩阵值的系数。[1.x.37] 

 [2.x.4]被假定为均匀正定，即有[2.x.5]使[2.x.7]的特征值[2.x.6]满足[2.x.8] 。使用符号[2.x.9]而不是通常的[2.x.10]作为解变量将在下一节中变得清晰。

在讨论了方程和我们要用来解决它的公式后，本介绍将包括块状矩阵和向量的使用，求解器和预处理器的定义，最后是我们要解决的实际测试案例。

我们将扩展[2.x.11]中的这个教程程序，不仅要解决混合拉普拉斯方程，还要增加另一个描述两种流体的混合运输的方程。

这里涉及的方程属于矢量值问题的范畴。这个主题的顶层概述可以在[2.x.12]模块中找到。


[1.x.38][1.x.39] 


在上述形式中，泊松方程（即右手边为非零的拉普拉斯方程）通常被认为是多孔介质中流体流动的良好模型方程。当然，人们通常通过[1.x.40]来模拟流体流动，或者，如果流体速度很慢或粘度很大，则通过[1.x.41]（我们在[2.x.13]中涉及）。在这两个模型中，第一个模型的作用力是惯性和粘性摩擦，而在第二个模型中，只有粘性摩擦--即一个流体粒子对附近的粒子所施加的力。如果你在一个大的领域里有自由流动，例如管道、河流或空气中，这是很合适的。另一方面，如果流体被限制在孔隙中，那么孔壁对流体施加的摩擦力变得越来越重要，而内部粘性摩擦力变得越来越不重要。如果这两种效应都很重要，那么建立模型首先会导致[1.x.42]，而在非常小的孔隙的限制下会导致[1.x.43]。后者只是泊松方程或拉普拉斯方程的不同名称，其内涵是人们想应用它的领域：多孔介质中的缓慢流动。本质上，它说速度与驱动流体通过多孔介质的负压梯度成正比。

达西方程对驱动流动的压力进行建模。由于求解变量是压力，我们在此使用[2.x.14]的名称，而不是通常用于求解偏微分方程的[2.x.15]的名称）。拉普拉斯方程的这种观点的典型应用是为地下水流或油藏中的碳氢化合物流动建模。在这些应用中，[2.x.16]是渗透性张量，即衡量土壤或岩石基质对流体流动的阻力大小。

在上述应用中，数值方案的一个理想特征是它应该是局部保守的，也就是说，无论什么东西流入一个单元，也会从该单元流出（或者如果源不为零，差值等于每个单元的源项的积分）。然而，事实证明，拉普拉斯方程的通常离散化（如[2.x.17]、[2.x.18]或[2.x.19]中使用的那些）并不满足这一特性。但是，人们可以通过选择不同的问题表述和特定的有限元空间组合来实现这一点。


[1.x.44][1.x.45] 


为此，我们首先引入了第二个变量，称为速度， [2.x.20] 。根据其定义，速度是压力梯度的负方向的一个矢量，乘以渗透性张量。如果渗透率张量与单位矩阵成正比，这个方程就很容易理解和直观：渗透率越高，速度就越高；速度与压力梯度成正比，从高压区到低压区（因此是负号）。

有了这第二个变量，就可以找到拉普拉斯方程的另一个版本，称为[1.x.46]。[1.x.47] 

这里，我们将定义速度的方程[2.x.21]乘以[2.x.22]，因为这使得方程组是对称的：其中一个方程有梯度，第二个方程有负发散，这两个方程当然是彼此相邻的，结果是一个对称的双线性形式，因此，在[2.x.23]是对称张量的共同假设下，是对称的系统矩阵。

这个问题的弱式是通过将两个方程与测试函数相乘，并将一些项进行部分积分而得到的。[1.x.48] 

其中[1.x.49] 

这里，[2.x.24]是边界处的外向法向量。请注意，在这个公式中，原问题的迪里希特边界值被纳入到弱形式中。

为了得到良好的解决，我们必须在空间[2.x.25]中寻找[2.x.26]、[2.x.27]和[2.x.28]的解和检验函数。几乎每一本关于有限元理论的书都说过一个众所周知的事实，如果选择离散的有限元空间来逼近[2.x.30]是不恰当的，那么产生的离散问题是不稳定的，离散的解不会收敛到精确的解。这里考虑的问题的一些细节--属于 "鞍点问题 "的范畴 

-- 可以在维基百科的[1.x.50]页面上找到）。) 

为了克服这个问题，已经为[2.x.31]开发了一些不同的有限元对，导致了稳定的离散问题。其中一个对子是对速度[2.x.33]使用Raviart-Thomas空间，对压力[2.x.34]使用不连续元素类[2.x.35]。关于这些空间的细节，我们特别参考Brezzi和Fortin的关于混合有限元方法的书，但许多其他关于有限元理论的书，例如Brenner和Scott的经典书，也说明了相关结果。在任何情况下，在适当选择函数空间的情况下，离散的表述如下。找到[2.x.36]，以便[1.x.51]。




在继续之前，让我们简短地停顿一下，说明上述函数空间的选择为我们提供了所需的局部守恒特性。特别是，由于压力空间由不连续的片断多项式组成，我们可以选择测试函数[2.x.37]作为在任何给定单元[2.x.38]上等于1，其他地方为0的函数。如果我们也到处选择[2.x.39]（记住，上面的弱式必须对[1.x.52]离散测试函数[2.x.40]成立），那么把这些测试函数的选择放到上面的弱式表述中，特别意味着[1.x.53] 

当然，我们可以将其以更明确的形式写成[1.x.54]。

应用发散定理的结果是，对于每个单元[2.x.42]的选择，[2.x.41]必须满足[1.x.55]的关系。

如果你现在记得[2.x.43]是速度，那么左边的积分正是穿过单元[2.x.44]边界的（离散）通量。那么声明是，通量必须等于[2.x.45]内的源上的积分。特别是，如果没有源（即[2.x.46]在[2.x.47]中），那么声明是[1.x.56]通量为零，也就是说，任何流入一个单元的东西都必须通过单元边界的其他部分流出。这就是我们所说的[1.x.57]，因为它对每个单元都成立。

另一方面，通常的连续[2.x.48]元素在用于压力时不会产生这种属性（例如，我们在[2.x.49]中这样做），因为我们不能选择一个离散的测试函数[2.x.50]，在一个单元[2.x.51]上为一，在其他地方为零：它将是不连续的，因此不在有限元空间内。严格来说，我们只能说上面的证明对连续元素不起作用。这些元素是否仍然可能导致局部守恒是一个不同的问题，因为人们可以认为不同的证明可能仍然有效；然而，在现实中，这个属性确实不成立）。) 




[1.x.58][1.x.59] 。


deal.II库（当然）实现了任意阶的Raviart-Thomas元素 [2.x.52] [2.x.53] ，以及不连续的元素 [2.x.54] 。如果我们暂时忘记它们的特殊属性，那么我们就必须解决一个离散问题[1.x.60] 。

的双线性形式和右手边，以及[2.x.55] , [2.x.56] 。[2.x.57]和[2.x.58]都来自空间[2.x.59]，其中[2.x.60]本身就是一个[2.x.61]维函数的空间，以适应流速是矢量值的事实。那么必要的问题是：我们如何在程序中做到这一点？

矢量值元素已经在以前的教程程序中讨论过了，第一次是在 [2.x.62] 中详细讨论。那里的主要区别是，矢量值空间[2.x.63]的所有分量都是统一的：位移矢量的[2.x.64]分量都是相等的，来自同一个函数空间。因此，我们可以做的是建立[2.x.65]作为[2.x.66]乘以通常的[2.x.67]有限元空间的外积，并以此确保我们所有的形状函数只有一个非零矢量分量。因此，我们在[2.x.68]中所做的不是处理矢量值的形状函数，而是查看（标量）唯一的非零分量，并使用[2.x.69]调用来计算出这实际上是哪个分量。

这对Raviart-Thomas元素不起作用：由于它们的构造满足空间[2.x.70]的某些规律性属性，[2.x.71]的形状函数通常在其所有矢量分量中都是非零的。由于这个原因，如果应用[2.x.72]来确定形状函数[2.x.73]的唯一非零分量，就会产生一个例外。我们真正需要做的是在[2.x.74]中获得一个形状函数的所有[2.x.75]矢量分量。在deal.II的字典中，我们把这样的有限元称为 [2.x.76] 非原始 [2.x.77] ，而把标量的有限元或者每个矢量值的形状函数只在一个矢量分量中不为零的有限元称为 [2.x.78] 原始 [2.x.79] 。

那么对于非原始元素，我们要怎么做呢？为了弄清楚这个问题，让我们回到教程的程序中，几乎是最开始的时候。在那里，我们了解到，我们使用[2.x.80]类来确定正交点的形状函数的值和梯度。例如，我们会调用 [2.x.81] 来获得 [2.x.82] 的形状函数在正交点上的数值 [2.x.83] 。后来，在 [2.x.84] 和其他教程程序中，我们了解到这个函数调用也适用于矢量值的形状函数（原始有限元），它返回形状函数 [2.x.85] 在正交点 [2.x.86] 的唯一非零分量的值。

对于非原始形状函数，这显然是行不通的：形状函数[2.x.87]没有单一的非零向量分量，因此调用[2.x.88]也就没有什么意义。然而，deal.II提供了第二个函数调用，[2.x.89]，返回正交点[2.x.90]的值[2.x.91]是一个介于零和当前有限元的矢量分量数量之间的索引；例如，我们将用于描述速度和压力的元素将有[2.x.92]分量。值得注意的是，这个函数调用也可用于原始形状函数：它将简单地对除一个分量外的所有分量返回零；对于非原始形状函数，它一般会对不止一个分量返回非零值。

我们现在可以尝试用向量分量来重写上面的双线性形式。例如，在2d中，第一项可以这样改写（注意，[2.x.93]）。[1.x.61] 

如果我们这样实施，我们会得到这样的代码。

[1.x.62] 



这充其量是繁琐的，容易出错的，而且不是独立的维度。有一些明显的方法可以使事情与维度无关，但最终，这些代码根本不漂亮。如果我们能够简单地提取形状函数[2.x.94]和[2.x.95]的分量，那就更好了。在程序中，我们以如下方式进行。

[1.x.63] 



事实上，这不仅是双线性形式的第一项，而且是整个事情（不包括边界贡献）。

这段代码的作用是，给定一个[2.x.97]对象，在正交点[2.x.100]提取形状函数[2.x.99]的第一个[2.x.98]分量的值，也就是该形状函数的速度分量。换句话说，如果我们把形状函数[2.x.101]写成元组[2.x.102]，那么该函数返回这个元组的速度部分。请注意，速度当然是一个[2.x.103]维度的张量，并且该函数返回一个相应的对象。同样地，在我们用压力提取器下标的地方，我们提取标量压力分量。整个机制在[2.x.104]模块中有更详细的描述。

在实践中，如果我们在每个最外层的循环中只评估一次形状函数、它们的梯度和发散，并存储结果，我们可以做得更好一些，因为这样可以节省一些原本重复的计算（通过提前计算所有相关的量，然后只在实际的循环中插入结果，甚至可以节省更多的重复操作，关于这种方法的实现见[2.x.105]）。最后的结果是这样的，在每个空间维度上工作。

[1.x.64] 



这非常类似于我们最初写下的双线性形式和右手边的形式。

有一个最后的项我们必须注意：右手边包含项[2.x.106]，构成压力边界条件的弱执行。我们已经在[2.x.107]中看到了如何处理面积分：本质上与域积分完全相同，只是我们必须使用FEFaceValues类而不是[2.x.108]。为了计算边界项，我们只需在所有的边界面上进行循环并在那里进行积分。该机制的工作方式与上述相同，即提取器类也对FEFaceValues对象工作。

[1.x.65] 



你可以在本程序的源文件中找到与上述完全相同的代码。因此，我们在下面将不作过多评论。


[1.x.66][1.x.67] 。


在组装好线性系统后，我们就面临着解决它的任务。这里的问题是，矩阵拥有两个不理想的特性。

- 它是[1.x.68]，也就是说，它既有正特征值也有负特征值。  我们不想在这里证明这个属性，但请注意，对于所有形式为[2.x.109]的矩阵都是如此，比如这里的[2.x.110]就是正定的。

- 该矩阵在右下方有一个零块（在双线性形式中没有将压力[2.x.111]与压力测试函数[2.x.112]耦合的项）。

至少它是对称的，但上面的第一个问题仍然意味着共轭梯度法是行不通的，因为它只适用于矩阵是对称和正定的问题。我们将不得不求助于其他迭代求解器，如MinRes、SymmLQ或GMRES，它们可以处理不确定的系统。然而，下一个问题立即浮现。由于零块，对角线上有零，通常的 "简单 "预处理程序（Jacobi、SSOR）都无法工作，因为它们需要除以对角线元素。

对于我们期望用这个程序运行的矩阵大小，迄今为止最简单的方法是直接使用一个直接求解器（特别是与deal.II捆绑的SparseDirectUMFPACK类）。 [2.x.113]走的就是这条路线，并表明解决[1.x.69]线性系统只需3、4行代码就可以完成。

但是，这是一个教程。我们教如何做事情。因此，在下文中，我们将介绍一些可用于类似这种情况的技术。也就是说，我们将考虑线性系统不是由一个大矩阵和向量组成的，而是要将矩阵分解为[1.x.70]，这些矩阵对应于系统中出现的各个运算符。我们注意到所得到的求解器并不是最优的--有更好的方法来有效地计算这个系统，例如在[2.x.114]的结果部分所解释的方法，或者我们在[2.x.115]中用于类似于当前问题的方法。在这里，我们的目标仅仅是介绍新的求解技术以及如何在交易中实现它们。


[1.x.71][1.x.72] 。


鉴于使用上述标准求解器和预处理器的困难，让我们再看一下矩阵。如果我们对自由度进行排序，使所有的速度变量排在所有的压力变量之前，那么我们可以将线性系统[2.x.116]细分为以下几块。[1.x.73] 

其中[2.x.117]分别是速度和压力自由度的值，[2.x.118]是速度空间的质量矩阵，[2.x.119]对应于负发散算子，[2.x.120]是其转置，对应于梯度。

通过区块消除法，我们可以按以下方式对这个系统重新排序（用系统的第一行乘以[2.x.121]，然后用第二行减去）。[1.x.74] 

这里，矩阵[2.x.122]（称为[2.x.123]的[1.x.75]）显然是对称的，由于[2.x.124]的正定性和[2.x.125]具有全列秩，[2.x.126]也是正定的。

因此，如果我们能够计算出[2.x.127]，我们就可以对其应用共轭梯度法。然而，计算[2.x.128]是昂贵的，因为它需要我们计算（可能很大的）矩阵[2.x.129]的逆；而[2.x.130]实际上也是一个全矩阵，因为即使[2.x.131]是稀疏的，其逆[2.x.132]通常也是一个密集矩阵。另一方面，CG算法并不要求我们真正拥有[2.x.133]的表示：只需与它形成矩阵-向量乘积即可。我们可以利用矩阵乘积是关联的这一事实，分步进行（也就是说，我们可以通过设置括号的方式使乘积更方便计算）。为了计算[2.x.134]，我们[2.x.135][2.x.136]计算[2.x.137]；[2.x.138]用CG方法解决[2.x.139]的[2.x.140]，适用于正定和对称的质量矩阵[2.x.141]；[2.x.142]计算[2.x.143]，得到[2.x.144] 。 [2.x.145] 注意我们如何从右到左评估表达式[2.x.146]以避免矩阵-矩阵乘积；这样，我们所要做的就是评估矩阵-向量乘积。

在下文中，我们必须想出表示矩阵[2.x.147]的方法，以便在共轭梯度求解器中使用它，以及定义我们可以预设涉及[2.x.148]的线性系统解决方案的方法，并处理与矩阵[2.x.149]的线性系统求解（上述第二步骤）。

 [2.x.150] 这个考虑的关键点是要认识到，为了实现一个迭代求解器，如CG或GMRES，我们实际上从来不需要矩阵的实际[1.x.76]! 所需要的只是我们能够形成矩阵-向量乘积。对于预处理程序也是如此。在deal.II中，我们对这一要求进行了编码，只要求给予求解器类的矩阵和预处理器有一个[2.x.151]成员函数来做矩阵-向量乘积。一个类如何选择实现这个函数对求解器来说并不重要。因此，类可以通过，例如，做一连串的乘积和线性求解来实现它，正如上面所讨论的。


[1.x.77][1.x.78] 。


deal.II包括支持以一种非常普遍的方式来描述这种线性操作。这是由LinearOperator类完成的，与[2.x.152]"MatrixType概念 "一样，它定义了[1.x.79]对矢量进行线性操作的最小接口。

[1.x.80] 

然而，LinearOperator和普通矩阵的关键区别在于，LinearOperator不允许对底层对象进行任何进一步的访问。你能用LinearOperator做的就是把它的 "动作 "应用到一个向量上。我们借此机会介绍一下LinearOperator的概念，因为它是一个非常有用的工具，允许你以非常直观的方式构造复杂的求解器和预处理器。

作为第一个例子，让我们构建一个代表[2.x.153]的LinearOperator对象。这意味着每当这个运算符的[2.x.154]函数被调用时，它必须解决一个线性系统。这就要求我们指定一个解算器（和相应的）前置条件。假设[2.x.155]是对系统矩阵左上块的引用，我们可以写成。

[1.x.81] 

我们没有使用SolverControl，而是使用了ReductionControl类，该类在达到绝对容限（我们选择[2.x.156]）或残差减少某一系数（此处为[2.x.157]）时停止迭代。相反，SolverControl类只检查绝对公差。在我们的案例中，我们必须使用ReductionControl来解决一个小问题。我们将送入[2.x.158]的右手边基本上是由残差形成的，随着外部迭代的进行，残差的规范自然会大大降低。这使得用绝对公差来控制非常容易出错。

我们现在有一个LinearOperator [2.x.159] ，我们可以用它来构造更复杂的算子，如Schur补码 [2.x.160] 。假设[2.x.161]是对右上角区块的引用，构造一个LinearOperator [2.x.162]只需两行。

[1.x.82] 

在这里，三个LinearOperator对象的乘法得到一个复合对象[2.x.163]，该函数首先应用[2.x.164]，然后是[2.x.165]（即用[2.x.166]解方程），最后是[2.x.167]到任何给定的输入向量。在这个意义上，[2.x.168]类似于以下代码。

[1.x.83] 

( [2.x.169] 是两个临时向量)。这种方法背后的关键点是，我们实际上从未创建过矩阵的内积。相反，每当我们必须与[2.x.170]进行矩阵向量乘法时，我们只需按上述顺序运行所有单独的[2.x.171]操作。

 [2.x.172] 我们可以通过实现一个专门的类[2.x.173]，提供一个合适的[2.x.174]函数，来实现创建一个 "类似矩阵 "的对象的相同目标。跳过一些细节，这可能看起来像下面这样。

[1.x.84] 

尽管这两种方法完全等同，但LinearOperator类比这种手工方法有很大的优势。它提供了所谓的[1.x.85][1.x.86]。在数学上，我们认为[2.x.175]是复合矩阵[2.x.176]，LinearOperator类允许你或多或少地逐字写出来。

[1.x.87] 

另一方面，手工方法掩盖了这一事实。

现在我们要做的就是形成定义[2.x.177]和[2.x.178]的两个方程的右边，然后分别用舒尔补码矩阵和质量矩阵来解决它们。例如，第一个方程的右手边为 [2.x.179] 。这可以按以下方式实现。

[1.x.88] 

同样，这是一个完全有效的方法，但是deal.II要求我们手动调整最终向量和临时向量的大小，而且每一个操作都要占用一个新的行，这使我们很难阅读。这就是线性运算符框架中的第二个类可以将帮助我们的地方。与LinearOperator的精神类似，一个PackagedOperation存储了一个 "计算"。

[1.x.89] 

该类允许[1.x.90]涉及向量和线性运算符的表达式。这是通过存储计算表达式来实现的，并且只在对象被转换为向量对象，或者[2.x.180]（或[2.x.181]被手动调用时才执行计算。假设[2.x.182]是右手边的两个向量，我们可以简单地写出。

[1.x.91] 

这里，[2.x.183]是一个打包操作，[1.x.92]是我们指定的计算。它不会立即创建一个带有实际结果的向量。

有了这些先决条件，解决[2.x.184]和[2.x.185]是创建另一个求解器和逆的问题。

[1.x.93] 



 [2.x.186]我们在这个例子中手工开发的功能在库中已经很容易获得。看看schur_complement(), condense_schur_rhs(), and postprocess_schur_solution()。


[1.x.94][1.x.95] 。


有人可能会问，如果我们有一个Schur补码的预处理程序是否会有帮助 [2.x.187] 。一般来说，答案是：当然。问题是，我们对这个舒尔补码矩阵一无所知。我们不知道它的条目，我们所知道的只是它的作用。另一方面，我们必须认识到，我们的求解器是昂贵的，因为在每次迭代中，我们必须与舒尔补矩阵做一次矩阵-向量乘积，这意味着我们必须在每次迭代中对质量矩阵做一次反转。

有不同的方法对这样的矩阵进行预处理。一个极端是使用一些便宜的方法，因此对每次迭代的工作没有实际影响。另一个极端是使用本身非常昂贵的预处理程序，但作为回报，它确实降低了用[2.x.188]求解所需的迭代次数。

我们将沿着第二种方法进行尝试，既是为了提高程序的性能，也是为了展示一些技术。为此，让我们回顾一下，理想的预处理程序当然是[2.x.189]，但这是无法实现的。然而，将[1.x.96]作为预处理程序如何？

作为先决条件如何？这意味着每次我们必须做一个预处理步骤时，我们实际上必须用[2.x.190]来解决。起初，这看起来几乎和立即用[2.x.191]求解一样昂贵。然而，请注意，在内迭代中，我们不必计算[2.x.192]，而只需计算其对角线的逆值，这很便宜。

值得庆幸的是，LinearOperator框架使得这一点非常容易写出来。我们之前已经对[2.x.194]矩阵使用了雅可比预处理程序（[2.x.193]）。所以剩下的就是写出近似的舒尔补码应该是什么样子。

[1.x.97] 

注意这个算子的不同之处在于，它只是做了一次雅可比扫频（即与对角线的逆数相乘），而不是与整个[2.x.195]相乘。（这就是与[2.x.196]的单一雅可比预处理步骤的定义：它是与[2.x.197]的对角线的逆数相乘；换句话说，对向量[2.x.199]的[2.x.198]操作正是 PreconditionJacobi 所做的）。

有了这些，我们几乎完成了预处理程序：它应该是近似舒尔补码的逆运算。我们再次通过使用inverse_operator()函数创建一个线性算子来实现这一点。然而这一次我们想为CG求解器选择一个相对较小的容忍度（即反转[2.x.200]）。理由是[2.x.201]，所以我们实际上不需要完全反转它。然而，这产生了一个微妙的问题：[2.x.202]将被用于最后的外层CG迭代以创建一个正交基础。但为了使其发挥作用，每次调用都必须是精确的线性操作。我们通过使用IterationNumberControl来确保这一点，它允许我们将执行的CG迭代次数固定为一个固定的小数字（在我们的例子中为30）。

[1.x.98] 



这就是全部! 

显然，应用这个近似舒尔补数的逆运算是一个非常昂贵的预处理程序，几乎和舒尔补数本身的逆运算一样昂贵。我们可以期望它能大大减少Schur补码所需的外部迭代次数。事实上，它确实如此：在使用0阶元素的7次细化网格的典型运行中，外部迭代次数从592次下降到39次。另一方面，我们现在必须应用一个非常昂贵的预处理程序25次。因此，更好的衡量标准只是程序的运行时间：在目前的笔记本电脑上（截至2019年1月），对于这个测试案例，它从3.57秒下降到2.05秒。这似乎并不令人印象深刻，但在更细的网格和更高阶的元素上，节省的时间变得更加明显了。例如，一个7倍细化的网格和使用2阶元素（相当于约40万个自由度）产生了1134次到83次的外部迭代的改进，运行时间从168秒到40秒。并非惊天动地，但意义重大。


[1.x.99][1.x.100] 。


在这个教程程序中，我们将以上述的混合公式求解拉普拉斯方程。由于我们想在程序中监控解的收敛性，我们选择右手边、边界条件和系数，以便恢复我们已知的解函数。特别是，我们选择压力解[1.x.101]。

对于系数我们选择单位矩阵[2.x.203]来简化。因此，确切的速度满足[1.x.102]。

选择这个解是因为它完全没有发散，使得它成为不可压缩流体流动的一个现实的测试案例。因此，右手边等于[2.x.204] ，作为边界值，我们必须选择[2.x.205] 。

在本程序的计算中，我们选择[2.x.206] 。你可以在[1.x.103]中找到所得到的解决方案，在注释程序之后。[1.x.104] [1.x.105] 。


[1.x.106] [1.x.107] 。




由于这个程序只是对[2.x.207]的改编，在头文件方面没有太多的新东西。在deal.II中，我们通常按照base-lac-grid-dofs-fe-numerics的顺序列出包含文件，然后是C++标准包含文件。

[1.x.108] 



唯一值得注意的两个新头文件是LinearOperator和PackagedOperation类的文件。

[1.x.109] 



这是唯一重要的新头文件，即声明Raviart-Thomas有限元的文件。

[1.x.110] 



最后，作为本程序中的一项奖励，我们将使用一个张量系数。由于它可能具有空间依赖性，我们认为它是一个张量值的函数。下面的include文件提供了提供这种功能的[2.x.208]类。

[1.x.111] 



最后一步和以前的所有程序一样。我们把所有与这个程序相关的代码放到一个命名空间中。(这个想法在 [2.x.209] 中首次提出) 。

[1.x.112] 




[1.x.113] [1.x.114]。




同样，由于这是对 [2.x.210] 的改编，主类与该教程程序中的主类几乎相同。就成员函数而言，主要区别在于构造函数将Raviart-Thomas元素的度数作为参数（并且有一个相应的成员变量来存储这个值），并且增加了[2.x.211]函数，在该函数中，不出意外，我们将计算精确解和数值解之间的差异，以确定我们计算的收敛性。

[1.x.115] 



第二个不同之处是，疏散模式、系统矩阵以及解和右手向量现在被封锁了。这意味着什么，以及对这些对象能做什么，在本程序的介绍中已经解释过了，下面我们在解释这个问题的线性求解器和预处理器时也会进一步解释。

[1.x.116] 




[1.x.117] [1.x.118]。




我们的下一个任务是定义我们问题的右手边（即原始拉普拉斯方程中压力的标量右手边），压力的边界值，以及一个描述压力和精确解的速度的函数，以便以后计算误差。请注意，这些函数分别有一个、一个和[2.x.212]个分量，我们将分量的数量传递给[2.x.213]基类。对于精确解，我们只声明实际上一次性返回整个解向量（即其中的所有成分）的函数。下面是各自的声明。

[1.x.119] 



然后，我们当然也要定义这些各自的函数。鉴于我们在介绍中讨论了解决方案的样子，下面的计算应该是很简单的。

[1.x.120] 




[1.x.121] [1.x.122] 




除了其他方程数据外，我们还想使用渗透性张量，或者更好的是--因为这是在弱形式中出现的全部--渗透性张量的逆， [2.x.214] 。对于验证解的精确性和确定收敛顺序的目的来说，这个张量的作用大于帮助。因此，我们将简单地把它设置为同一矩阵。     


然而，在现实生活中的多孔介质流动模拟中，空间变化的渗透率张量是不可缺少的，我们想利用这个机会来展示使用张量值函数的技术。     


可能毫不奇怪，deal.II也有一个基类，不仅适用于标量和一般矢量值的函数（[2.x.215]基类），也适用于返回固定维度和等级的张量的函数，即[2.x.216]模板。在这里，所考虑的函数返回一个dim-by-dim矩阵，即一个等级为2、维度为[2.x.217]的张量。然后我们适当地选择基类的模板参数。     


[2.x.218]类所提供的接口本质上等同于[2.x.219]类。特别是，存在一个[2.x.220]函数，它接收一个评估函数的点的列表，并在第二个参数中返回函数的值，一个张量的列表。

[1.x.123] 



实现起来就不那么有趣了。和以前的例子一样，我们在类的开头添加一个检查，以确保输入和输出参数的大小是相同的（关于这个技术的讨论见[2.x.221]）。然后我们在所有的评估点上循环，对于每一个评估点，将输出张量设置为身份矩阵。     


在函数的顶部有一个奇怪的地方（`(void)point;`语句），值得讨论。我们放入输出`values`数组的值实际上并不取决于函数被评估的坐标`points`数组。换句话说，`points'参数实际上是不用的，如果我们想的话，可以不给它起名字。但是我们想用`points`对象来检查`values`对象是否有正确的大小。问题是，在发布模式下，`AssertDimension`被定义为一个宏，扩展为空；然后编译器会抱怨`points`对象没有使用。消除这个警告的习惯方法是有一个评估（读取）变量的语句，但实际上不做任何事情：这就是`(void)points;`所做的：它从`points`中读取，然后将读取的结果转换为`void`，也就是什么都没有。换句话说，这句话是完全没有意义的，除了向编译器解释是的，这个变量事实上是被使用的，即使是在发布模式下。(在调试模式下，`AssertDimension'宏会扩展为从变量中读取的东西，所以在调试模式下，这个有趣的语句是没有必要的)。

[1.x.124] 




[1.x.125] [1.x.126] ... 





[1.x.127] [1.x.128] [1.x.128]。




在这个类的构造函数中，我们首先存储传入的关于我们将使用的有限元的度数的值（例如，度数为0，意味着使用RT(0)和DG(0)），然后构造属于介绍中描述的空间[2.x.222]的矢量值元素。构造函数的其余部分与早期的教程程序一样。   


这里唯一值得描述的是，这个变量所属的[2.x.223]类的构造函数调用有很多不同的构造函数，都是指将较简单的元素绑定在一起，成为一个较大的元素。在目前的情况下，我们想把一个RT(度)元素与一个DQ(度)元素结合起来。这样做的[2.x.224]构造函数要求我们首先指定第一个基本元素（给定程度的[2.x.225]对象），然后指定这个基本元素的副本数量，然后类似地指定[2.x.226]元素的种类和数量。注意Raviart-Thomas元素已经有[2.x.227]个矢量分量，所以耦合元素将有[2.x.228]个矢量分量，其中第一个[2.x.229]个对应于速度变量，最后一个对应于压力。   


同样值得比较的是，我们从基本元素中构建这个元素的方式，与我们在[2.x.230]中的方式相比较：在那里，我们将其构建为[2.x.231]，即我们简单地使用[2.x.232]元素，每个坐标方向上的位移都有一份。

[1.x.129] 




[1.x.130] [1.x.131]。




接下来的这个函数从众所周知的函数调用开始，创建和细化一个网格，然后将自由度与之关联。

[1.x.132] 



然而，接下来事情就变得不同了。正如在介绍中提到的，我们要将矩阵细分为对应于速度和压力这两个不同类型变量的块。为此，我们首先要确保与速度和压力相对应的指数不混在一起。首先是所有速度自由度，然后是所有压力自由度。这样一来，全局矩阵就很好地分离成一个[2.x.233]系统。为了实现这一点，我们必须根据自由度的矢量分量对其重新编号，这个操作已经很方便地实现了。

[1.x.133] 



接下来，我们要弄清楚这些块的大小，以便我们可以分配适当的空间量。为此，我们调用了[2.x.234]函数，该函数计算了某个向量分量的多少个形状函数是非零的。我们有[2.x.235]个向量分量，[2.x.236]将计算有多少个形状函数属于这些分量中的每个。     


这里有一个问题。正如该函数的文档所描述的，它 [1.x.134] 将 [2.x.237] -速度形状函数的数量放入 [2.x.238] 中，将 [2.x.239] -速度形状函数的数量放入 [2.x.240] 中（以及类似的3d），并将压力形状函数的数量放入 [2.x.241] 中 。但是，Raviart-Thomas元素的特殊性在于它是非[2.x.242]"原始 "的，也就是说，对于Raviart-Thomas元素，所有的速度形状函数在所有分量中都是非零。换句话说，该函数不能区分[2.x.243]和[2.x.244]速度函数，因为[1.x.135]没有这种区分。因此，它将速度的总体数量放入[2.x.245] , [2.x.246]中的每一个。另一方面，压力变量的数量等于在dim-th分量中不为零的形状函数的数量。     


利用这一知识，我们可以从[2.x.247]中的任何第一个[2.x.248]元素中得到速度形状函数的数量，然后用下面这个来初始化向量和矩阵块大小，以及创建输出。     




 [2.x.249] 如果你觉得这个概念难以理解，你可能要考虑用函数 [2.x.250] 来代替，就像我们在 [2.x.251] 的相应代码中做的那样。你可能还想阅读一下术语表中[2.x.252]"块 "和[2.x.253]"组件 "之间的区别。

[1.x.136] 



下一个任务是为我们将要创建的矩阵分配一个稀疏度模式。我们使用与前面步骤一样的压缩稀疏模式，但是由于[2.x.254]是一个块状矩阵，我们使用[2.x.255]类，而不仅仅是[2.x.256] 。这种块状稀疏模式在[2.x.257]模式中有四个块。块的大小取决于[2.x.258]，它持有速度和压力变量的数量。在第二步中，我们必须指示块系统更新它所管理的块的大小的知识；这发生在[2.x.259]的调用中。

[1.x.137] 



我们以与非区块版本相同的方式使用压缩的区块稀疏模式来创建稀疏模式，然后创建系统矩阵。

[1.x.138] 



然后，我们必须以与块压缩稀疏性模式完全相同的方式调整解和右手向量的大小。

[1.x.139] 




[1.x.140][1.x.141] 。




同样地，组装线性系统的函数在本例的介绍中已经大部分讨论过了。在它的顶部，发生的是所有常规的步骤，此外，我们不仅为单元项分配正交和[2.x.260]对象，而且还为面项分配。之后，我们为变量定义通常的缩写，并为本地矩阵和右手贡献分配空间，以及保存当前单元本地自由度的全局数字的阵列。

[1.x.142] 



下一步是声明代表源项、压力边界值和方程中的系数的对象。除了这些代表连续函数的对象外，我们还需要数组来保存它们在各个单元的正交点上的值（或面，对于边界值）。请注意，在系数的情况下，数组必须是矩阵的一种。

[1.x.143] 



最后，我们需要几个提取器，用来获取矢量值形状函数的速度和压力成分。它们的功能和使用在[2.x.261]报告中有详细描述。基本上，我们将把它们作为下面FEValues对象的下标：FEValues对象描述了形状函数的所有矢量分量，而在订阅后，它将只指速度（一组从零分量开始的[2.x.262]分量）或压力（位于[2.x.263]位置的标量分量）。

[1.x.144] 



有了这一切，我们就可以继续在所有单元上进行循环。这个循环的主体已经在介绍中讨论过了，这里就不再评论了。

[1.x.145] 



所有单元的循环的最后一步是将局部贡献转移到全局矩阵和右手向量中。请注意，我们使用的界面与之前的例子完全相同，尽管我们现在使用的是块状矩阵和向量，而不是常规的。换句话说，对于外界来说，块对象具有与矩阵和向量相同的接口，但它们还允许访问单个块。

[1.x.146] 




[1.x.147][1.x.148] 。




我们在这个例子中使用的线性求解器和预处理器已经在介绍中进行了详细的讨论。因此，我们在此不再讨论我们的方法的原理，而只是对一些剩余的实现方面进行评论。





[1.x.149] [1.x.150]。




正如在引言中所概述的，求解函数基本上包括两个步骤。首先，我们必须形成涉及舒尔补数的第一个方程，并求解压力（解决方案的第1部分）。然后，我们可以从第二个方程（解的第0部分）重构速度。

[1.x.151] 



作为第一步，我们声明对矩阵的所有块状分量、右手边和我们将需要的解向量的引用。

[1.x.152] 



然后，我们将创建相应的LinearOperator对象并创建[2.x.264]运算器。

[1.x.153] 



这样我们就可以声明舒尔补码 [2.x.265] 和近似舒尔补码 [2.x.266] 。

[1.x.154] 



我们现在从[2.x.267]中创建一个预处理程序，应用固定数量的30次（便宜的）CG迭代。

[1.x.155] 



现在来看看第一个方程。它的右边是[2.x.268]，这就是我们在前几行计算的内容。然后我们用CG求解器和我们刚刚声明的预处理器来解决第一个方程。

[1.x.156] 



得到压力后，我们可以计算速度。方程为[2.x.269] ，我们通过首先计算右手边，然后与代表质量矩阵逆的对象相乘来解决它。

[1.x.157] 




[1.x.158] [1.x.159] 。





[1.x.160] [1.x.161]。




在我们处理完线性求解器和预处理器之后，我们继续实现我们的主类。特别是，下一个任务是计算我们数值解的误差，包括压力和速度。   


为了计算解的误差，我们已经在 [2.x.271] 和 [2.x.272] 中介绍了 [2.x.270] 函数。然而，在那里我们只处理了标量解，而在这里我们有一个矢量值的解，其分量甚至表示不同的量，并且可能有不同的收敛阶数（由于所使用的有限元的选择，这里不是这种情况，但在混合有限元应用中经常是这种情况）。因此，我们要做的是 "掩盖 "我们感兴趣的成分。这很容易做到：[2.x.273]函数将一个指向权重函数的指针作为其参数之一（参数默认为空指针，意味着单位权重）。我们要做的是传递一个函数对象，在我们感兴趣的成分中等于1，而在其他成分中等于0。例如，为了计算压力误差，我们应该传递一个函数，代表在[2.x.274]分量中具有单位值的常数向量，而对于速度，常数向量在第一个[2.x.275]分量中应该是1，而在压力的位置是0。   


在deal.II中，[2.x.276]正是这样做的：它想知道它要表示的函数应该有多少个矢量分量（在我们的例子中，这将是[2.x.277]，用于联合速度-压力空间），哪个个体或范围的分量应该等于1。因此，我们在函数的开头定义了两个这样的掩码，接下来是一个代表精确解的对象和一个向量，我们将在其中存储由[2.x.278]计算的单元误差。

[1.x.162] 



正如在[2.x.279]中已经讨论过的，我们必须认识到，不可能精确地整合误差。我们所能做的就是用正交法对这个积分进行近似。这实际上在这里出现了一个小小的转折：如果我们像人们可能倾向于做的那样天真地选择一个[2.x.280]类型的对象（这就是我们用于积分线性系统的对象），就会发现误差非常小，根本不遵循预期的收敛曲线。现在的情况是，对于这里使用的混合有限元，高斯点恰好是超收敛点，其中的点误差比其他地方小得多（而且收敛的阶数更高）。因此，这些点不是特别好的积分点。为了避免这个问题，我们简单地使用梯形法则，并在每个坐标方向上迭代[2.x.281]次（同样如[2.x.282]中的解释）。

[1.x.163] 



有了这个，我们就可以让库计算误差并将其输出到屏幕上。

[1.x.164] 




[1.x.165] [1.x.166] 




最后一个有趣的函数是我们生成图形输出的函数。请注意，所有的速度分量都得到相同的解名 "u"。再加上使用[2.x.283]，这将导致[2.x.284]生成单个速度分量的矢量表示，更多信息请参见[2.x.285]或[2.x.286]模块中的 "生成图形输出 "部分。最后，对于高阶元素来说，在图形输出中每个单元只显示一个双线性四边形似乎不合适。因此，我们生成大小为(度数+1)x(度数+1)的斑块来捕捉解决方案的全部信息内容。关于这方面的更多信息，请参见[2.x.288]的教程程序。

[1.x.167] 




[1.x.168][1.x.169] 。




这是我们主类的最后一个函数。它唯一的工作是按照自然顺序调用其他函数。

[1.x.170] 




[1.x.171] [1.x.172]。




我们从[2.x.289]而不是[2.x.290]偷来的主函数。它几乎等同于 [2.x.291] 中的函数（当然，除了改变了类名），唯一的例外是我们将有限元空间的度数传递给混合拉普拉斯问题的构造函数（这里，我们使用零阶元素）。

[1.x.173] 

[1.x.174][1.x.175] 。


[1.x.176][1.x.177] 。




如果我们按原样运行程序，对于我们使用的[2.x.292]网格，我们得到这样的输出（因为我们使用片状常数，所以总共有1024个单元，1024个压力自由度，2112个速度，因为Raviart-Thomas元素定义了每个面的一个自由度，有[2.x.293]个面平行于[2.x.294]-轴，同样数量平行于[2.x.295] -轴）。

[1.x.178] 



迭代次数如此之少，当然是由于我们开发的良好（但昂贵！）的预处理程序。为了获得对解决方案的信心，让我们看一下它。下面三张图片显示了（从左到右）x-速度、y-速度和压力。

 [2.x.296]  




让我们从压力开始：它在左边最高，在右边最低，所以流动将从左到右。此外，虽然在图中几乎看不出来，但我们选择的压力场是这样的：从左到右的流动首先是向中心流动，然后又向外流动。因此，X-速度必须增加以使流动通过狭窄的部分，这一点在左图中很容易看到。中间的图像表示在域的左端有Y方向的内流，而在域的右端有Y方向的外流。




作为补充说明，请注意左图中的x-速度在x方向上是连续的，而y-速度在y方向上是连续的。其他方向上的流场是不连续的。这非常明显地反映了Raviart-Thomas元素的连续性特性，事实上，它只在空间H(div)而不是在空间[2.x.297]。最后，压力场是完全不连续的，但鉴于我们选择了[2.x.298]作为该求解分量的有限元，这不应该令人惊讶。




[1.x.179][1.x.180] 。




该程序提供了两个明显的玩耍和观察收敛的地方：使用的有限元的程度（传递给[2.x.299]的构造器）和细化水平（在[2.x.300]中确定）。人们可以做的是改变这些值，并在以后的程序运行过程中观察计算出的误差。




如果这样做，就会发现压力变量的[2.x.301]误差有如下模式。 [2.x.302]  

理论上预期的收敛顺序很好地反映在表格最后一行所显示的实验观察结果中。




我们可以用速度变量中的[2.x.303]误差做同样的实验。 [2.x.304] 这里关于收敛顺序的结果是相同的。




[1.x.181] [1.x.182][1.x.183] 。


[1.x.184][1.x.185] 。


地下水或石油储层模拟的现实流动计算不会使用恒定的渗透率。这里有一个改变这种情况的第一个相当简单的方法：我们使用一个渗透率，在远离中心流线的地方快速衰减，直到它达到一个背景值0.001。这是为了模仿流体在砂岩中的行为：在大部分领域中，砂岩是均匀的，虽然对流体有渗透性，但不是过分的渗透；在另一块石头上，石头沿着一条线裂开了，或者说断层了，流体沿着这条大裂缝更容易流动。下面是我们如何实现这样的东西。

[1.x.186] 

记住，该函数返回渗透率张量的逆值。




用更高的网格分辨率，我们可以直观地看到这一点，这里有x-和y-速度。

 [2.x.305]  

很明显，流体基本上只沿着中线流动，而不是其他地方。




另一种可能性是使用一个随机渗透率场。实现这一点的一个简单方法是在领域周围散布一些中心，然后使用一个渗透率场，它是这些中心的（负）指数之和。然后，流动将试图从一个高渗透率的中心跳到下一个中心。这是描述随机介质的一种完全不科学的尝试，但是实现这种行为的一种可能性是这样的。

[1.x.187] 



这个张量的对角线元素的片状常数插值（即[2.x.306]）看起来如下。

 [2.x.307]  


有了这样一个渗透率场，我们将得到如下的x-velocities和压力。

 [2.x.308]  

我们将在 [2.x.309] 和 [2.x.310] 中再次使用这些渗透率场。


[1.x.188][1.x.189] 。


正如介绍中提到的，这里使用的Schur补码求解器并不是可以想象的最好的（也不打算成为一个特别好的）。更好的解算器可以在文献中找到，并且可以使用这里介绍的相同的块矩阵技术来构建。我们在[2.x.311]中再次提到这个主题，在那里我们首先为斯托克斯方程建立了一个Schur补数求解器，就像我们在这里所做的那样，然后在[1.x.190]部分讨论了基于求解系统整体但基于单个块的预处理的更好方法。我们还将在[2.x.312]中再来讨论这个问题。[1.x.191] [1.x.192] [2.x.313] 。 

 [2.x.314] 
