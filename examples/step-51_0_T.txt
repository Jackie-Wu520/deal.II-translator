 [2.x.0][2.x.1] 。 

本教程取决于 [2.x.2] , [2.x.3] , [2.x.4] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19 ][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38] 

 [2.x.5]  

[1.x.39] 

[1.x.40] [1.x.41] [1.x.42] 


本教程程序介绍了对流-扩散方程的可混合的不连续Galkerin方法的实现。

[1.x.43][1.x.44] 。


反对使用非连续Galerkin元素的一个常见论点是，在隐式系统中必须解决大量的全局耦合自由度。 这是因为，与连续有限元不同，在典型的非连续元中，每个顶点有一个自由度[1.x.45]，而不是只有一个，对边和面也是如此。 作为未知数增长速度的例子，考虑FE_DGPMonomial基础：每个标量解分量都由度数为[2.x.6]的多项式表示，每个元素有[2.x.7]个自由度。通常，一个元素的所有自由度都与相邻元素的所有自由度相耦合。 由此产生的离散方程会很快产生非常大的线性系统，特别是对于2或3维的方程系统。

[1.x.46][1.x.47] 。

为了减轻解决这些大型线性系统的计算成本，Cockburn和同事们提出了可混合的非连续Galerkin（HDG）方法（见Nguyen和Peraire最近发表的HDG概述文章中的参考文献[2.x.8]）。

HDG方法通过使用Dirichlet-to-Neumann映射制定数学问题来实现这一目标。 偏微分方程首先被写成一阶系统，然后通过DG方法将每个场离散化。 在这一点上，网格骨架上的单值 "跟踪 "值，即元素面，被视为独立的未知量。这就产生了离散公式中的未知数，分为两类。

- 面未知数，只与面的两边的单元未知数耦合。

- 单元未知数，只与定义在同一单元内的单元和面的未知数耦合。最重要的是，一个单元的内部自由度不会与另一个单元的任何内部自由度相耦合。

Dirichlet-to-Neumann图的概念允许以下求解过程。 [2.x.9] [2.x.10] 使用局部元素内部数据来强制执行三角结构骨架上的诺伊曼条件。 然后，全局问题是求解轨迹值，这是唯一全局耦合的未知数。   [2.x.11] 使用已知的骨架值作为Dirichlet数据来求解局部元素级的解决方案。 这被称为 "局部求解器"，是一个[1.x.48]逐个元素的求解过程。 [2.x.12]  

[1.x.49][1.x.50] 

上述程序也有一个线性代数的解释--被称为[1.x.51]--被Guyan在连续有限元的背景下利用来减少全局线性系统的大小 [2.x.13] ，以及被Fraeijs de Veubeke用于混合方法 [2.x.14] 。在后一种情况下（混合公式），系统的减少是通过使用不连续的通量与引入额外的辅助变量[1.x.52]来实现的，该变量近似于每个元素边界上的未知数的轨迹。这个过程被称为混合化，并且通过类比，这也是Cockburn、Gopalakrishnan和Lazarov在2009年引入的局部非连续Galerkin方法[2.x.15]，以及随后由他们的合作者开发的，最终被称为[1.x.53]（HDG）方法的原因。

让我们把与HDG问题相关的完整线性系统写成一个块状系统，离散DG（单元内部）变量[2.x.16]为第一块，骨架（面）变量[2.x.17]为第二块。[1.x.54] 

我们现在的目标是用类似于[2.x.19]的舒尔补码方法消除[2.x.18]块，这将导致以下两个步骤。[1.x.55] 

重点是[2.x.20]的存在不是问题，因为[2.x.21]是一个块对角线矩阵，每个块对应一个单元，因此足够容易反转。与其他单元的耦合是由骨架变量上的矩阵[2.x.22]和[2.x.23]引入的。[2.x.24]的块对角性以及[2.x.25]和[2.x.26]的结构使我们能够逐元反转矩阵[2.x.27]（迪里切特问题的局部解）并从[2.x.29]中减去[2.x.28]。因此，Dirichlet-to-Neumann地图概念的步骤对应于 [2.x.30] [2.x.31] 构建Schur补足矩阵 [2.x.32] 和右手边 [2.x.33] [1.x.56 ]并以通常的方式将贡献插入全局跟踪矩阵，[2.x.34]求解舒尔互补系统[2.x.35]，[2.x.36]使用第二个方程求解[2.x.37]，给出[2.x.38] 。 [2.x.39]  


[1.x.57][1.x.58] 。

对传统DG方法的另一个批评是，近似通量的收敛是次优的。 局部HDG解决方案可以被证明是收敛的[2.x.40] ，即以最优的顺序收敛。 此外，超级收敛特性可用于后处理新的近似解，其收敛速度为[2.x.41] 。


[1.x.59][1.x.60] 。


可混合的非连续Galerkin方法只是解决非连续Galerkin方法的问题的一种方法。另一种思路是所谓的 "弱Galerkin "方法。它在[2.x.42]中进行了探讨。


[1.x.61][1.x.62] 。


本例中使用的HDG公式取自[2.x.43] [1.x.63][1.x.64][1.x.65] 。

我们考虑域[2.x.44]上的对流-扩散方程，其边界为Dirichlet边界[2.x.45]和Neumann边界[2.x.46] : [1.x.66] 



引入辅助变量[2.x.47]，将上述方程改写为一阶系统。[1.x.67] 



我们将这些方程乘以权重函数[2.x.48]，并对每个元素[2.x.49]进行部分积分，得到。[1.x.68] 



用帽子装饰的条款表示数值轨迹（通常也被称为数值通量）。 它们是对元素边界上的内部值的近似。 为了确保守恒，这些项在任何给定的元素边上必须是单值的[2.x.50]，即使在不连续的形状函数中，当然可能有来自界面附近单元的多个值。我们通过使用以下形式的轨迹来消除数字轨迹[2.x.51]。[1.x.69] 



变量[2.x.52]作为一个额外的自变量被引入，是我们最终建立一个全局耦合线性系统的变量。如上所述，它被定义在元素面上，并且在面与面的交汇处（2D中的顶点，3D中的边缘和顶点）不连续。数值跟踪函数中出现的[2.x.53]和[2.x.54]的值被认为是限制在边界[2.x.55]的单元内部解。

局部稳定参数[2.x.56]对HDG解的稳定性和准确性有影响；进一步讨论见文献。据报道，稳定参数为1是给出最佳结果的选择。趋向于无穷大的稳定参数[2.x.57]禁止解在元素边界上跳跃，使HDG解接近于连续有限元素的近似值。在下面的程序中，我们选择稳定参数为[1.x.70] 。

其中我们设定扩散[2.x.58]，扩散长度尺度为[2.x.59] 。

HDG方法中的轨迹/骨架变量在元素面上是单值的。 因此，它们必须强有力地代表[2.x.60]上的迪里希特数据。 这意味着[1.x.71] 。

其中等号实际上是指边界函数[2.x.62]对面变量空间的[2.x.61]投影（例如面的线性函数）。然后用不均匀约束的方法[2.x.64]将这种约束应用于骨架变量[2.x.63]。 

将三角结构中所有元素的贡献相加，强制执行数值通量的法线分量，并对由[2.x.65]加权的方程进行部分积分，我们得出问题的最终形式：找到[2.x.66]，以便 

[1.x.72] 



未知数[2.x.67]被称为局部变量；它们被表示为标准DG变量。 未知数[2.x.68]是骨架变量，在网格的一维表面（面）上有支持。

我们用符号[2.x.69]表示所有单元上的积分之和，[2.x.70]表示所有单元的所有面的积分，也就是说，内部面被访问两次，每边一次，并有相应的法向量。当结合共享一个面的两个元素的贡献时，上述方程产生了DG方法中熟悉的条款，解在单元边界上有跳跃。

在上述方程中，标量变量[2.x.71]的空间[2.x.72]被定义为在每个单元上为张量积多项式[2.x.73]且在元素边界上不连续的函数空间[2.x.74]，即由[2.x.75]描述的空间。梯度或通量变量的空间 [2.x.76] 是一个矢量元素空间，其中每个分量是局部多项式且不连续 [2.x.77] 。在下面的代码中，我们将这两个局部部分收集在一个FESystem中，其中第一个@p dim分量表示梯度部分，最后一个标量分量对应于标量变量。对于骨架部分[2.x.78]，我们定义了一个由住在元素面上的不连续张量积多项式组成的空间，在deal.II中由FE_FaceQ这个类来实现。这个空间在其他方面与FE_DGQ相似，即解函数在两个相邻的面之间不连续，也可参见下面的结果部分进行说明。

在上面给出的弱形式中，我们可以注意到以下的耦合模式。 [2.x.79] [2.x.80] 矩阵[2.x.81]包括局部-局部耦合项。 当局部加权函数[2.x.82]与局部求解项[2.x.83]相乘时就会产生这些耦合项。因为这些元素是不连续的，所以[2.x.84]是块对角线的。   [2.x.85] 矩阵[2.x.86]代表局部面的耦合。 这些是具有加权函数[2.x.87]的条款，乘以骨架变量[2.x.88] 。   [2.x.89] 矩阵[2.x.90]代表面-局域耦合，它涉及加权函数[2.x.91]乘以局域解[2.x.92] 。   [2.x.93] 矩阵[2.x.94]是面-面耦合；条款涉及[2.x.95]和[2.x.96] 。 [2.x.97]  

[1.x.73][1.x.74] 。


HDG方法的一个特点是，它们通常允许构建一个丰富的解决方案，以提高精确度。这种后处理方法以逐个元素的方式获取HDG解决方案，并将其结合起来，这样在使用度数为[2.x.99]的多项式时可以获得[2.x.98]级的精度。要做到这一点，有两个必要的因素。 [2.x.100] [2.x.101] 计算的解决方案梯度 [2.x.102] 以最佳速度收敛，即 [2.x.103] 。   [2.x.104] 解的标量部分的单元平均，[2.x.105] ，以[2.x.106]的速度超级收敛。 [2.x.107]  

我们现在引入一个新的变量[2.x.108]，在约束条件[2.x.111]下，通过最小化单元[2.x.109]的表达式找到它。这个约束是必要的，因为最小化函数并不能确定[2.x.112]的常数部分。这就转化为以下方程组。[1.x.75] 



由于我们在第二组方程中用张量积多项式空间中的整套基函数进行测试，这是一个过度确定的系统，方程比未知数多一个。我们在下面的代码中通过省略其中一个方程来解决这个问题（因为拉普拉斯的行在代表一个常数函数时是线性依赖的）。正如我们将在下面看到的，这种形式的后处理给出了所需的超级收敛结果，速率为[2.x.114] 。 应该指出的是，在构建[2.x.115]时有一定的自由度，这种从梯度中提取信息的最小化方法不是唯一的方法。特别是，这里定义的后处理方案在任何意义上都不满足对流-扩散方程。作为替代方案，上面引用的Nguyen, Peraire和Cockburn的论文提出了另一个有点复杂的对流-扩散公式，该公式也可以将通量变量后处理为[2.x.116]-符合的变体，并且在扩散较小时更好地表示局部对流-扩散算子。我们把更复杂的后处理的实现作为一个可能的扩展留给感兴趣的读者。

请注意，对于矢量值的问题，后处理的工作原理是类似的。我们只需为每个向量分量的平均值分别设置约束，并使用梯度作为主要信息来源。

[1.x.76][1.x.77] 。


在这个教程程序中，我们考虑的测试案例与 [2.x.117] 中的几乎一样。计算域是[2.x.118]，确切的解决方案对应于[2.x.119]中的解决方案，除了一个缩放。我们使用以下源中心[2.x.120]的指数 [2.x.121] [2.x.122] 一维：[2.x.123] , [2.x.124] 二维：[2.x.125] , [2.x.126] 三维：[2.x.127] 。 [2.x.128]  

有了精确的解决方案，我们就可以选择右侧的强制力和诺伊曼边界条件，从而得到这个解决方案（制造的解决方案技术）。在这个例子中，我们选择扩散等于1，对流为[1.x.78] 注意，对流是无发散的，[2.x.129] 。

[1.x.79] [1.x.80] 。


除了实现上述方程，下面的实现还提供了以下特点。 [2.x.130] [2.x.131] WorkStream来并行化局部求解器。Workstream已在 [2.x.132] 中详细介绍。   [2.x.133] 从跟踪中重构本地DG解。   [2.x.134] 对解进行后处理以实现超融合。   [2.x.135] 用于直接输出全局骨架解的DataOutFaces。 [2.x.136] [1.x.81] [1.x.82]。


[1.x.83] [1.x.84] ．




大多数deal.II的include文件在以前的例子中已经涉及到了，没有注释。

[1.x.85] 



然而，我们确实为这个例子准备了几个新的包含文件。第一个文件定义了三角形面上的有限元空间，我们称之为 "骨架"。这些有限元在元素内部没有任何支持，它们代表了在每个模数一的表面上有一个单一的值的多项式，但在模数二的表面上允许有不连续点。

[1.x.86] 



我们包含的第二个新文件定义了一种新的稀疏矩阵类型。 常规的[2.x.137]类型存储了所有非零条目的索引。 [2.x.138]则是利用了DG解的耦合性。 它存储了一个指定大小的矩阵子块的索引。 在HDG背景下，这个子块大小实际上是由骨架解字段定义的每个面的自由度数量。这使矩阵的内存消耗减少了三分之一，当在求解器中使用矩阵时，也会有类似的速度提升。

[1.x.87] 



这个例子的最后一个新包括涉及到数据输出。 由于我们有一个定义在网格骨架上的有限元场，我们希望能直观地看到这个解决方案的实际情况。DataOutFaces正是这样做的；其界面与我们熟悉的DataOut几乎相同，但输出的数据只有模拟的二维1数据。

[1.x.88] 



我们首先将所有的类放入自己的命名空间。

[1.x.89] 




[1.x.90][1.x.91] 。   


分析解决方案的结构与 [2.x.139] 中的相同。有两个例外。首先，我们也为三维情况创建了一个解决方案，其次，我们对解决方案进行了缩放，使其在解决方案宽度的所有值上的规范是统一的。

[1.x.92] 



这个类实现了一个函数，标量解和其负梯度被收集在一起。这个函数在计算HDG近似的误差时使用，它的实现是简单地调用解类的值和梯度函数。

[1.x.93] 



接下来是对流速度的实现。如介绍中所述，我们选择一个二维的[2.x.140]和三维的[2.x.141]的速度场。这就得到了一个无发散的速度场。

[1.x.94] 



我们实现的最后一个函数是用于制造解的右手边。它与[2.x.142]非常相似，不同的是我们现在有一个对流项而不是反应项。由于速度场是不可压缩的，即[2.x.143]，对流项简单读作[2.x.144] 。

[1.x.95] 




[1.x.96] [1.x.97] 。




HDG的求解过程与 [2.x.145] 的求解过程密切相关。主要区别在于使用了三套不同的DoFHandler和FE对象，以及ChunkSparseMatrix和相应的解决方案向量。我们还使用WorkStream来实现多线程的局部求解过程，利用局部求解器令人尴尬的并行性质。对于WorkStream，我们定义了对单元格的本地操作和复制到全局矩阵和向量的函数。我们这样做既是为了装配（装配要运行两次，一次是在我们生成系统矩阵时，一次是在我们从骨架值计算元素内部解时），也是为了后处理，在后处理中我们提取一个在高阶收敛的解。

[1.x.98] 



用于组装和解决原始变量的数据。

[1.x.99] 



对解进行后处理以获得[2.x.146]是一个逐个元素的过程；因此，我们不需要组装任何全局数据，也没有声明任何 "任务数据 "供WorkStream使用。

[1.x.100] 



以下三个函数被WorkStream用来完成程序的实际工作。

[1.x.101] 



本地 "解决方案是每个元素的内部。 这些代表原始解场 [2.x.147] 以及辅助场 [2.x.148] 。

[1.x.102] 



新的有限元类型和相应的[2.x.149]被用于耦合元素级局部解的全局骨架解。

[1.x.103] 



正如介绍中所说，HDG解可以通过后处理达到[2.x.150]的超收敛率。 后处理的解是一个不连续的有限元解，代表每个单元内部的原始变量。 我们定义了一个程度为[2.x.151]的FE类型来表示这个后处理的解，我们只在构造后用于输出。

[1.x.104] 



与骨架相对应的自由度强烈地强制执行Dirichlet边界条件，就像在连续Galerkin有限元方法中一样。我们可以通过AffineConstraints对象以类似的方式强制执行边界条件。此外，悬挂节点的处理方式与连续有限元的处理方式相同。对于只在面定义自由度的面元素，这个过程将精炼面的解设置为与粗略面的表示相吻合。     


请注意，对于HDG来说，消除悬空节点并不是唯一的可能性&mdash；就HDG理论而言，我们也可以使用精炼侧的未知数，并通过精炼侧的跟踪值表达粗略侧的局部解。然而，这样的设置在deal.II环路方面不容易实现，没有进一步分析。

[1.x.105] 



ChunkSparseMatrix类的用法与通常的稀疏矩阵类似。你需要一个ChunkSparsityPattern类型的稀疏模式和实际的矩阵对象。在创建稀疏模式时，我们只需要额外传递局部块的大小。

[1.x.106] 



与 [2.x.152] 相同。

[1.x.107] 




[1.x.108] [1.x.109] [1.x.109]。





[1.x.110] [1.x.111] 构造函数与其他例子中的相似，除了处理多个DoFHandler和FiniteElement对象。请注意，我们为局部DG部分创建了一个有限元系统，包括梯度/通量部分和标量部分。

[1.x.112] 




[1.x.113] [1.x.114] HDG解的系统设置方式与其他大多数教程程序类似。 我们小心翼翼地用我们所有的DoFHandler对象来分配道夫。 [2.x.153]和[2.x.154]对象与全局骨架解决方案一起。

[1.x.115] 



在创建块状稀疏模式时，我们首先创建通常的动态稀疏模式，然后在将其复制到最终的稀疏模式中时，设置块状大小，该大小等于一个面的道夫数量。

[1.x.116] 




[1.x.117] [1.x.118] 接下来是平行装配的本地数据结构的定义。第一个结构[2.x.155]包含了被写入全局矩阵的本地向量和矩阵，而ScratchData包含了我们在本地装配中需要的所有数据。这里有一个值得注意的变量，即布尔变量@p trace_reconstruct。正如介绍中提到的，我们分两步解决HDG系统。首先，我们为骨架系统创建一个线性系统，通过舒尔补码[2.x.156]将局部部分浓缩到其中。然后，我们用骨架的解来解决局部部分。对于这两个步骤，我们需要两次元素上的相同矩阵，我们希望通过两个装配步骤来计算。由于大部分的代码是相似的，我们用相同的函数来做这件事，但只是根据我们在开始装配时设置的一个标志在两者之间切换。由于我们需要将这一信息传递给本地工作程序，所以我们在任务数据中存储一次。

[1.x.119] 




[1.x.120] [1.x.121] [2.x.157] 包含WorkStream内每个线程的持久性数据。 FEValues、矩阵和矢量对象现在应该很熟悉了。 有两个对象需要讨论。 [2.x.158] int> > fe_local_support_on_face`和[2.x.159] int> > fe_support_on_face`。 这些用于指示所选择的有限元是否在与[2.x.160]相关的局部部分和骨架部分[2.x.161]的参考单元的特定面上有支持（非零值）。 我们在构造函数中提取这一信息，并为我们工作的所有单元一次性存储。 如果我们不存储这一信息，我们将被迫在每个单元上装配大量的零项，这将大大降低程序的速度。

[1.x.122] 




[1.x.123] [1.x.124] [2.x.162] 包含WorkStream在对局部解决方案进行后处理时使用的数据 [2.x.163] 。 它与 [2.x.164] 类似，但要简单得多。 

[1.x.125] 




[1.x.126] [1.x.127] [2.x.165] 函数类似于 [2.x.166] 上的函数，其中正交公式和更新标志被设置，然后 [2.x.167] 被用来以多线程的方式做工作。 [2.x.168] 输入参数用于决定我们是求全局骨架解（假）还是局部解（真）。   


对于汇编的多线程执行，值得注意的一点是，`assemble_system_one_cell()`中的局部计算会调用BLAS和LAPACK函数，如果这些函数在deal.II中可用的话。因此，底层的BLAS/LAPACK库必须支持同时来自多个线程的调用。大多数实现都支持这一点，但有些库需要以特定方式构建以避免问题。例如，在BLAS/LAPACK调用内部没有多线程的情况下编译的OpenBLAS需要建立一个名为`USE_LOCKING'的标志，并将其设置为true。

[1.x.128] 




[1.x.129] [1.x.130] HDG程序的真正工作是由 [2.x.169] 汇编局部矩阵 [2.x.170] 在这里完成，同时还有全局矩阵的局部贡献 [2.x.171] 。

[1.x.131] 



为FEValues reinit函数构建dof_handler_local的迭代器。

[1.x.132] 



我们首先计算单元内部对[2.x.172]矩阵的贡献（在介绍中称为矩阵[2.x.173]），对应于局部-局部耦合，以及局部右手向量。 我们在每个正交点存储基函数、右手边值和对流速度的值，以便快速访问这些场。

[1.x.133] 



面项被集合在所有元素的所有面上。这与更传统的DG方法相反，在组装过程中，每个面只被访问一次。

[1.x.134] 



在求解局部变量时需要已经获得的[2.x.174]值。

[1.x.135] 



在这里，我们计算介绍中讨论的稳定参数：由于扩散是1，并且扩散长度尺度被设定为1/5，它只是导致扩散部分的贡献为5，而通过元素边界的对流的大小为对流部分的中心化方案。

[1.x.136] 



我们存储非零流量和标量值，利用我们在[2.x.175]中创建的support_on_face信息。 

[1.x.137] 



当 [2.x.176] 我们准备为骨架变量 [2.x.177] 组装系统时。如果是这种情况，我们必须组装所有与问题相关的局部矩阵：局部-局部、局部-面部、面部-局部和面部-面部。 面-面矩阵被存储为[2.x.178]，这样就可以通过@p copy_local_to_global将其组装到全局系统中。

[1.x.138] 



注意face_no-local矩阵的符号。 我们在组装时否定了这个符号，这样我们就可以在计算舒尔补数时使用[2.x.179]的加法。

[1.x.139] 



这最后一项是将[2.x.180]项的贡献添加到本地矩阵中。相对于上面的面矩阵，我们在两个装配阶段都需要它。

[1.x.140] 



当[2.x.181]我们在逐个元素的基础上求解局部解。 局部右手边的计算是通过用计算值@p trace_values替换[2.x.182]计算中的基础函数@p tr_phi。 当然，现在矩阵的符号是减号，因为我们已经把所有的东西移到了方程的另一边。

[1.x.141] 



一旦完成了所有局部贡献的组装，我们必须：（1）组装全局系统。(1)组装全局系统，或者(2)计算局部解值并保存。无论哪种情况，第一步都是对局部-局部矩阵进行反转。

[1.x.142] 



对于(1)，我们计算舒尔补码，并将其添加到@p cell_matrix，矩阵[2.x.183]的介绍中。

[1.x.143] 



对于（2），我们只是求解（ll_matrix）.（solution_local）=（l_rhs）。因此，我们用[2.x.184]乘以我们已经倒置的局部-局部矩阵，并用[2.x.185]函数来存储结果。

[1.x.144] 




[1.x.145] [1.x.146] 如果我们处于解题的第一步，即[2.x.186]，那么我们将局部矩阵集合到全局系统中。

[1.x.147] 




[1.x.148] [1.x.149] 骨架解是通过使用带有身份预处理的BiCGStab求解器来解决的。

[1.x.150] 



一旦我们求出了骨架解，我们就可以以逐个元素的方式求出局部解。 我们通过重新使用相同的[2.x.187]函数来做到这一点，但将[2.x.188]切换为真。

[1.x.151] 




[1.x.152] [1.x.153]。




后处理方法有两个目的。首先，我们要在度数为[2.x.189]的元素空间中构建一个后处理的标量变量，我们希望能在阶[2.x.190]收敛。这又是一个逐个元素的过程，只涉及标量解以及局部单元上的梯度。为了做到这一点，我们引入了已经定义好的从头开始的数据以及一些更新标志，并运行工作流来并行地完成这一工作。   


其次，我们要计算离散化误差，就像我们在 [2.x.191] 中做的那样。整体程序与调用[2.x.192]相似，区别在于我们如何计算标量变量和梯度变量的误差。在[2.x.193]中，我们通过计算[2.x.194]或[2.x.195]的贡献来做到这一点。在这里，我们有一个DoFHandler，它计算了这两个贡献，并按其矢量成分排序，[2.x.196]为梯度，[2.x.197]为标量。为了计算它们的值，我们用一个ComponentSelectFunction来计算它们中的任何一个，再加上上面介绍的@p SolutionAndGradient类，它包含了它们中任何一个的分析部分。最终，我们还计算了后处理的解决方案的L2-误差，并将结果添加到收敛表中。

[1.x.154] 




[1.x.155][1.x.156]    


这是为后处理所做的实际工作。根据介绍中的讨论，我们需要设置一个系统，将DG解的梯度部分投影到后处理变量的梯度上。此外，我们还需要将新的后处理变量的平均值设置为等于单元上标量DG解的平均值。   


从技术上讲，梯度的投影是一个有可能填满我们的[2.x.198]乘以[2.x.199]矩阵的系统，但它是单数（所有行的总和为零，因为常数函数的梯度为零）。因此，我们拿掉一行，用它来强加标量值的平均值。我们为标量部分挑选第一行，尽管我们可以为[2.x.200]元素挑选任何行。然而，如果我们使用FE_DGP元素，第一行将对应常数部分，删除例如最后一行将得到一个奇异系统。这样一来，我们的程序也可以用于这些元素。

[1.x.157] 



在集合了所有的项之后，我们又可以继续解决这个线性系统。我们对矩阵进行反转，然后将反转结果乘以右手边。另一种方法（在数值上更稳定）是只对矩阵进行因式分解，并应用因式分解的方法。

[1.x.158] 




[1.x.159] [1.x.160] 我们有三组我们想输出的结果：局部解、后处理的局部解和骨架解。前两个结果都 "活 "在元素体积上，而后者则活在三角形的一维表面上。 我们的[2.x.201]函数将所有的局部解决方案写入同一个vtk文件，尽管它们对应于不同的DoFHandler对象。 骨架变量的图形输出是通过使用DataOutFaces类完成的。

[1.x.161] 



我们首先定义本地解决方案的名称和类型，并将数据添加到[2.x.202]。 

[1.x.162] 



我们添加的第二个数据项是后处理的解决方案。在这种情况下，它是一个属于不同DoFHandler的单一标量变量。

[1.x.163] 



[2.x.203]类的工作方式类似于[2.x.204]，它定义了三角形的骨架上的解决方案。 我们在此将其视为如此，代码与上面类似。

[1.x.164] 




[1.x.165] [1.x.166]。




我们为HDG实现了两种不同的细化情况，就像在[2.x.205]中一样：adaptive_refinement和global_refinement。 global_refinement选项每次都会重新创建整个三角形。这是因为我们想使用比一个细化步骤更细的网格序列，即每个方向2、3、4、6、8、12、16...个元素。




adaptive_refinement模式使用[2.x.206]对标量局部解中的非规则区域给出一个体面的指示。

[1.x.167] 



就像在[2.x.207]中一样，我们将其中两个面的边界指标设置为1，在这里我们要指定诺伊曼边界条件而不是迪里希特条件。由于我们每次在全局细化时都会重新创建三角形，所以在每个细化步骤中都会设置标志，而不仅仅是在开始时。

[1.x.168] 




[1.x.169] [1.x.170] 这里的功能基本上与[2.x.208] 相同。我们在10个周期中循环，在每个周期中细化网格。 在最后，收敛表被创建。

[1.x.171] 



与[2.x.209]相比，收敛表有一个微小的变化：由于我们没有在每个循环中以2的系数细化网格（而是使用2, 3, 4, 6, 8, 12, ...的序列），我们需要告诉收敛率评估这一点。我们通过设置单元格数量作为参考列，并额外指定问题的维度来实现，这为单元格数量和网格大小之间的关系提供了必要的信息。

[1.x.172] 



现在是对主类的三个调用，完全类似于 [2.x.210] 。

[1.x.173] 

[1.x.174][1.x.175]。


[1.x.176][1.x.177] 。


我们首先看一下程序在二维运行时产生的输出。在下面的四张图片中，我们展示了多项式度数[2.x.211]的解决方案和程序的第2、3、4和8周期。在图中，我们将内部数据（DG部分）与骨架部分（[2.x.212]）产生的数据叠加到同一图中。我们不得不生成两个不同的数据集，因为细胞和面孔代表不同的几何实体，在deal.II的VTK输出中不支持它们的组合（在同一个文件中）。

这些图像显示了HDG的明显特征：细胞的解（彩色表面）在细胞之间是不连续的。骨架变量上的解位于面，并将局部部分联系起来。骨架解决方案在面与面之间的顶点上是不连续的，尽管它的值沿着同一坐标方向的线相当接近。骨架解可以被解释为两边之间的橡胶弹簧，它可以平衡解的跳跃（或者说，通量[2.x.213]）。从左上角的图片可以看出，大体解经常出现过冲和欠冲的情况，而骨架变量确实是对精确解的更好的近似；这就解释了为什么我们可以通过后处理步骤得到更好的解。

随着网格的细化，单元之间的跳动变得很小（我们代表一个平滑的解决方案），骨架解决方案接近内部部分。对于第8周期，两个变量没有明显的差别。我们还看到边界条件是如何弱化实施的，内部变量并不完全满足边界条件。在下部和左侧边界，我们设置了诺伊曼边界条件，而在右侧和顶部边界，我们设置了迪里希特条件。

 [2.x.214]  

接下来，我们看一下后处理的解，还是在周期2、3、4和8。这是一个不连续的解，局部由二阶多项式描述。虽然在第二周期的网格上，解决方案看起来不是很好，但在第三和第四周期，它看起来好得多。正如下面的收敛表所示，我们发现它也更快地收敛到了分析解。

 [2.x.215]  

最后，我们看一下[2.x.216]在第二周期的解。尽管网格较粗，只有64个单元，但经过后处理的解在质量上与第8周期4,096个单元的线性解（未经过后处理）相似。这清楚地表明了高阶方法对于平滑解的优越性。

 [2.x.217]  

[1.x.178][1.x.179] 。


当程序运行时，它还会输出各自的步骤和收敛表的信息，并在最后列出各部分的误差。在2D中，收敛表看起来如下。

[1.x.180] 




我们可以看到网格细化后的误差减少，对于进行了全局细化的情况，也可以看到收敛率。在[2.x.218]准则下，标量变量和梯度变量的Q1元素的二次收敛率很明显，在[2.x.219]准则下，后处理的标量变量的三次收敛率也很明显。请注意HDG解决方案的这一明显特征。在典型的连续有限元中，阶[2.x.220]的解的梯度只以[2.x.221]的速率收敛，而实际的解则是[2.x.222]。即使有限元的超收敛结果也是可用的（例如Zienkiewicz和Zhu首次提出的超收敛补丁恢复），但这些通常只限于结构化网格和其他特殊情况。对于Q3 HDG变量，标量变量和梯度在四阶收敛，后处理的标量变量在五阶收敛。

同样的收敛率在三维中也被观察到。

[1.x.181] 



[1.x.182][1.x.183] 。


[1.x.184][1.x.185]。


这些收敛表验证了介绍中所说的预期收敛率。现在，我们想展示一下HDG方法与通常的有限元（连续Galkerin）方法在本教程的问题上的计算效率的快速比较。当然，与连续有限元相比，HDG方法对于传输为主的问题的稳定性方面在实践中也很重要，这是在平滑分析解的问题上看不到的方面。在下面的图片中，我们比较了[2.x.223]误差作为自由度数的函数（左）和线性求解器中花费的计算时间（右），连续有限元（CG）和本教程中介绍的混合非连续Galerkin方法的两个空间维度。相对于教程中我们只使用无条件的BiCGStab，下面的数字中显示的时间使用了[2.x.224]中的Trilinos代数多网格预处理 对于HDG部分，为了利用最细级别的矩阵中的块状结构，我们使用了ChunkSparseMatrix的跟踪变量的包装器。

 [2.x.225]  

图中的结果显示，HDG方法在[2.x.226]时比连续有限元慢，对立方体元素的速度差不多，对六阶元素则更快。然而，我们在上面已经看到，HDG方法实际上产生的解比原始变量所表示的更精确。因此，在下面的两幅图中，我们转而显示HDG的后处理解的误差（例如用[2.x.227]表示）。现在我们看到，对于[2.x.228]和[2.x.229]，在相同的工作量下，HDG有明显的优势，而对于[2.x.230]，质量也差不多。

 [2.x.231]  

由于HDG方法实际产生的结果收敛为 [2.x.232] ，我们应该将其与具有相同渐进收敛行为的连续Galerkin解进行比较，即具有度数的FE_Q [2.x.233] 。如果我们这样做，我们会得到下面的收敛曲线。我们看到，用二阶多项式的CG又明显优于用线型的HDG。然而，HDG对高阶的优势仍然存在。

 [2.x.234]  

这些结果与一般的DG方法的特性是一致的。最佳性能通常不是在线性元素上实现的，而是在更高的阶数上实现的，通常在 [2.x.235] 左右。这是因为不连续解的体积-表面效应，有太多的解存在于表面，因此当元素为线性时，会出现重复工作。换句话说，尽管DG方法专注于不连续（因此看起来精度不高）的解的表示，但在相对高的阶数上使用时往往最有效。

[1.x.186][1.x.187] 。


现在我们在三维中显示同样的数字：第一行显示了自由度数和计算时间与标量变量[2.x.236]中的[2.x.237]误差的关系，在阶数[2.x.238]下的CG和HDG，第二行显示了后处理的HDG解决方案而不是原始解决方案，第三行比较了后处理的HDG解决方案与阶数[2.x.239]下的CG。在三维中，体积-表面效应使得HDG的成本更高，对于线型来说，CG的解决方案显然比HDG更好。对于立方体，HDG和CG的质量相似，而HDG对于六阶多项式又更有效率。我们也可以使用FE_DGP和FE_FaceP的组合来代替（FE_DGQ, FE_FaceQ），它们不使用[2.x.240]度的张量积多项式，而是使用[1.x.188]度的Legendre多项式[2.x.241]。在给定的网格大小下，FE_FaceP的骨架变量的自由度较少，但解的质量（误差与自由度数的关系）与FE_FaceQ的结果非常相似。

 [2.x.242]  

关于效率比较的最后一点说明。我们试图使用通用的稀疏矩阵结构和类似的求解器（两者的最佳AMG预处理器，没有对任何一个AMG参数进行特别的调整），以便在一个玩具例子上对两种方法的成本与精度进行公平的描述。然而，应该注意的是，连续有限元的几何多网格（GMG）对于[2.x.243]和[2.x.244]来说，大约快了四到五个系数。截至2019年，HDG的最优复杂度迭代求解器仍在研究界开发中。另外，还有其他方面的CG的实现，如[2.x.245]中所示的快速无矩阵方法，使高阶连续元素更具竞争力。同样，本教程的作者也不清楚是否可以对HDG做出类似的改进。我们参考了[1.x.189]中最近的效率评估。


[1.x.190][1.x.191] 


正如在介绍中已经提到的，一种可能性是实现文献中讨论的另一种后处理技术。

第二个没有做得很好的项目与这个程序的性能有关，这当然是实际应用中的一个问题（还要权衡(H)DG方法对传输为主的问题有更好的解决质量）。让我们看看这个教程程序的计算时间和各个部分的份额。

 [2.x.246]  

从表中可以看出，解算器和汇编调用在程序的运行时间中占主导地位。这也清楚地表明了哪些地方的改进是最有意义的。

 [2.x.247] [2.x.248] 更好的线性求解器。我们使用的是BiCGStab迭代求解器，没有预设条件，迭代次数随着问题大小的增加而增加（Q1元素和全局细化的迭代次数小的时候是35次，大的时候增加到701次）。为了做得更好，例如可以使用Trilinos的代数多网格预处理程序，或者像[1.x.192]中讨论的一些更高级的变体。对于以扩散为主的问题，比如目前的问题，只要我们不与MPI并行工作，就可以设计这样一个求解器，在最细的层次上使用更高效的ChunkSparseMatrix的矩阵-向量积。对于MPI并行化的计算，可以使用一个标准的[2.x.249]。

   [2.x.250] 通过预先组装不从一个单元改变到另一个单元的部分（那些既不包含可变系数也不包含映射依赖项的部分）来加速组装。 [2.x.251] [1.x.193] [1.x.194] [2.x.252] 。 

 [2.x.253] 
