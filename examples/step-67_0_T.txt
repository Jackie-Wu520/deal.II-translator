 [2.x.0] [2.x.1]  

本教程取决于 [2.x.2] , [2.x.3] , [2.x.4] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14 ][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27] 



 [2.x.5]  

[1.x.28] 

[1.x.29] [1.x.30] [1.x.31] 


本教程程序使用显式时间积分器求解流体力学的欧拉方程，其无矩阵框架应用于空间的高阶非连续Galerkin离散化。关于欧拉系统的细节和另一种隐式方法，我们也参考了[2.x.6]的教程程序。你可能还想看看[2.x.7]，看看解决这些方程的另一种方法。


[1.x.32][1.x.33] 。


欧拉方程是一个守恒定律，描述了可压缩无iscid气体的运动， [1.x.34] 其中解矢量的[2.x.8] 分量为 [2.x.9] 。这里，[2.x.10] 表示流体密度，[2.x.11] 表示流体速度，[2.x.12] 表示气体的能量密度。速度不直接求解，而是用变量[2.x.13]，即线性动量（因为这是个守恒量）。

欧拉通量函数是一个[2.x.14]矩阵，定义为[1.x.35]，其中[2.x.15]为[2.x.16]身份矩阵，[2.x.17]为外积；其组成部分分别表示质量、动量和能量通量。右手边的强制力由[1.x.36]给出，其中矢量[2.x.18]表示重力的方向和大小。然而，它也可以表示作用于流体的任何其他单位质量的外力。例如，想想外部电场对带电粒子所施加的静电力）。

三个方程组，第二个涉及[2.x.19]部分，描述了质量、动量和能量的守恒。压力不是一个解决方案的变量，但需要通过其他变量的 "闭合关系 "来表达；我们在这里选择适合由两个原子组成的分子的气体的关系，在中等温度下，由[2.x.20]给出，常数为[2.x.21] 。


[1.x.37][1.x.38] 。


对于空间离散化，我们使用高阶不连续Galerkin（DG）离散化，使用[1.x.39]形式的解扩展。 这里，[2.x.22]表示[2.x.23]第1个基函数，以矢量形式写出不同成分的独立形状函数，让[2.x.24]分别通过密度、动量和能量变量。在这种形式下，空间依赖性包含在形状函数中，时间依赖性包含在未知系数中 [2.x.25] 。与连续有限元方法中一些形状函数跨越元素边界不同，在DG方法中，形状函数是单个元素的局部，从一个元素到下一个元素是不连续的。从一个单元到其相邻单元的解的连接是由下面规定的数值通量来实现的。这允许一些额外的灵活性，例如在数值方法中引入方向性，例如，上卷法。

DG方法是解决传输特性问题的流行方法，因为它们结合了低分散误差和几乎没有解决的尺度上的可控耗散。这使得它们在流体动力学领域的模拟中特别有吸引力，因为在这些领域中，需要代表广泛的活动尺度，而不充分解决的特征很容易干扰重要的良好解决的特征。此外，高阶DG方法非常适用于现代硬件的正确实施。同时，DG方法也不是万能的。特别是当解出现不连续（冲击）时，就像欧拉方程在某些流态下的典型情况一样，高阶DG方法容易出现振荡解，就像所有不使用通量或坡度限制器的高阶方法一样。这是[1.x.40]的结果，即任何线性的总变差（TVD）方案（如基本的DG离散化）最多能达到一阶精度。换句话说，由于DG方法的目标是高阶精度，所以它们不可能对产生冲击的解进行TVD。尽管有些人声称DG方法中的数值通量可以控制耗散，但这一点价值有限，除非[1.x.41]问题中的冲击与单元边界一致。任何穿过单元内部的冲击都会因为高阶多项式而再次产生振荡成分。在有限元和DG界，存在许多不同的方法来处理冲击，例如在有问题的单元上引入人工扩散（使用基于解的模态分解等的有问题单元指标），在子网格上转换为耗散性低阶有限体积方法，或者增加一些限制性程序。考虑到这种情况下的大量可能性，再加上相当大的实施努力，我们在这里不考虑带有明显冲击的欧拉方程系统，而是集中在带有波浪状现象的亚音速流动系统。对于一个能很好地处理冲击的方法（但每个未知数的成本更高），我们参考了[2.x.26]的教程程序。

对于DG公式的推导，我们将欧拉方程与测试函数[2.x.27]相乘，并对单个单元[2.x.28]进行积分，从而得到[1.x.42] 。

然后我们对第二项进行分项积分，将发散从解槽移到测试函数槽，并产生元素边界上的积分：[1.x.43] 在表面积分中，我们用项[2.x.30]代替项[2.x.29]，即数值流量。数值通量的作用是连接相邻元素上的解并弱化解的连续性。这保证了PDE的全局耦合反映在离散化中，尽管单元上有独立的基函数。通过将数值通量定义为来自内部面两侧的解的函数 [2.x.31] 和 [2.x.33] ，包括与邻居的连接。我们要求的一个基本属性是，数值通量需要是[1.x.44]。也就是说，我们希望所有的信息（即质量、动量和能量）在一个面上离开一个单元时，都能完整地进入邻近的单元，反之亦然。这可以表示为[2.x.34]，也就是说，数值通量从任何一边都评估为相同的结果。结合数值通量与所考虑的面的单位外法向量相乘的事实，即从两边指向相反的方向，我们看到守恒被满足了。数值通量的另一个观点是作为一个单值的中间状态，从两边微弱地连接解决方案。

有大量的数值通量函数可用，也叫黎曼求解器。对于欧拉方程来说，存在所谓的精确黎曼求解器--意味着来自两边的状态以符合欧拉方程的方式沿着不连续点结合起来--以及近似黎曼求解器，它违反了一些物理特性，并依靠其他机制来使方案总体上准确。近似黎曼求解器的优点是计算成本较低。大多数通量函数都起源于有限体积界，它类似于单元（称为体积）内的多项式0度的DG方法。由于欧拉算子[2.x.35]的体积积分对于恒定解和检验函数会消失，所以数值通量必须完全代表物理算子，这也解释了为什么在该界有大量的研究。对于DG方法，一致性是由单元内的高阶多项式保证的，这使得数值通量不再是一个问题，通常只影响收敛率，例如，对于度数为[2.x.40]的多项式，解是否收敛为[2.x.36]、[2.x.37]或[2.x.38]准则。因此，数值通量可以被看作是一种机制，用于选择更有利的耗散/分散特性或关于离散化和线性化算子的极值特征，这影响到显式时间积分器中最大的可接受的时间步长。

在这个教程中，我们实现了两种通量的变体，可以通过程序中的开关来控制（当然，通过输入文件来控制它们的运行时间参数也很容易）。第一个通量是局部的Lax--Friedrichs通量[1.x.45] 。

在Lax--Friedrichs通量的原始定义中，使用了一个系数[2.x.41]（对应于信息在界面两边移动的最大速度），说明两个状态之间的差异，[2.x.42]被欧拉通量中的最大特征值惩罚，即[2.x.43] ，其中[2.x.44]为音速。在下面的实现中，我们对惩罚项进行了一些修改，因为无论如何，惩罚都是近似的性质。我们使用 

[1.x.46] 

额外的因子[2.x.45]降低了惩罚强度（这导致特征值的负实部减少，从而增加了可接受的时间步长）。使用和内的平方允许我们减少昂贵的平方根操作的数量，对于原始的Lax--Friedrichs定义是4个，现在只需要一个。这种简化导致参数[2.x.46]的减少最多为2倍，因为[2.x.47]，最后一个不等式来自杨氏不等式。

第二个数值通量是由Harten, Lax和van Leer提出的，称为HLL通量。它考虑到欧拉方程的不同传播方向，取决于声速。它利用一些中间状态 [2.x.48] 和 [2.x.49] 来定义两个分支 [2.x.50] 和 [2.x.51] 。关于中间状态[2.x.52]和[2.x.53]的定义，已经提出了几个变种。最初提出的变体采用密度平均的速度定义， [2.x.54] 。由于我们考虑的是没有冲击的欧拉方程，因此在本教程程序中，我们简单地使用算术手段，[2.x.55]和[2.x.56]，与[2.x.57]，而将其他变体留给可能的扩展。我们还注意到，HLL通量在文献中被扩展为所谓的HLLC通量，其中C代表表示接触不连续的能力。

在没有邻接状态[2.x.58]的边界上，通常的做法是从边界条件中推导出合适的外部值（详见关于DG方法的一般文献）。在本教程程序中，我们考虑三种类型的边界条件，即[1.x.48]，其中所有分量都是规定的；[1.x.49][1.x.50]，其中我们不规定外部解，因为流场要离开域，而使用内部值；我们仍然需要规定能量，因为欧拉通量中还剩下一个传入特性；[1.x.51]和[1.x.52]，描述一个无穿透的配置。[1.x.53] 

解的多项式展开最后被插入到弱形式中，测试函数被基础函数取代。这就得到了一个空间上离散、时间上连续的非线性系统，其未知系数的数量有限 [2.x.59] , [2.x.60] 。关于DG方法中多项式度数的选择，截至2019年，文献中并没有关于什么多项式度数最有效的共识，决定权取决于问题。高阶多项式可以确保更好的收敛率，因此对于中等到高精确度要求的[1.x.54]解来说，高阶多项式更有优势。同时，自由度所在的体积与表面的比率，随着高阶度的增加而增加，这使得数值通量的影响变弱，通常会减少耗散。然而，在大多数情况下，解决方案是不平滑的，至少与可以承受的分辨率相比是不平滑的。例如，在不可压缩流体力学、可压缩流体力学以及与之相关的波浪传播课题中都是如此。在这个前渐进制度中，误差大约与数值分辨率成正比，而其他因素，如分散误差或耗散行为变得更加重要。非常高阶的方法往往被排除在外，因为它们带有根据未知数衡量的更多限制性的CFL条件，而且当涉及到表示复杂几何形状时，它们也不那么灵活。因此，2到6的多项式度数在实践中是最受欢迎的，见例如[2.x.61]中的效率评估和其中引用的参考文献。

[1.x.55][1.x.56] 


为了在时间上进行离散，我们稍微重新排列弱的形式，并在所有单元上求和。[1.x.57] 其中[2.x.62]贯穿所有基函数，从1到[2.x.63] 。

我们现在用[2.x.64]表示质量矩阵，其条目为[2.x.65] ，用[1.x.58]表示评价欧拉算子右边的算子，给定一个与全局未知数矢量和使用中的有限元相关的函数[2.x.66]。这个函数[2.x.67]是明确随时间变化的，因为在边界上评估的数值通量将涉及边界某些部分的随时间变化的数据[2.x.68]、[2.x.69]和[2.x.70]，取决于边界条件的分配。有了这个符号，我们可以把空间离散、时间连续的系统紧凑地写成[1.x.59]，其中我们还冒昧地用[2.x.71]来表示全局解向量（除了相应的有限元函数）。等价地，上述系统的形式为[1.x.60] 。

对于用高阶非连续Galerkin方法离散的双曲系统，该系统的显式时间积分非常流行。这是由于质量矩阵[2.x.72]是块对角线的（每个块只对应于定义在同一单元上的同类变量），因此很容易倒置。在每个时间步长--或Runge-Kutta方案的阶段--我们只需要用给定的数据评估一次微分算子，然后再应用质量矩阵的逆值。另一方面，对于隐式时间步进，人们首先必须将方程线性化，然后迭代求解线性系统，这涉及到几个残差评估和至少十几个线性化算子的应用，这在[2.x.73]教程程序中已经得到证明。

当然，显式时间步长的简单性是有代价的，即由于所谓的Courant-Friedrichs-Lewy（CFL）条件而产生的条件稳定性。它指出，时间步长不能大于离散微分算子的最快信息传播。用更现代的术语来说，传播速度对应于离散算子的最大特征值，反过来又取决于网格大小、多项式程度[2.x.74]和欧拉算子的物理学，即[2.x.75]相对于[2.x.76]的线性化的特征值。在这个程序中，我们将时间步长设置为：。[1.x.61] 

以所有正交点和所有单元的最大值为准。无量纲数[2.x.77]表示Courant数，可以选择到最大稳定数[2.x.78]，其值取决于所选择的时间步进方法及其稳定性能。用于多项式缩放的幂[2.x.79]是启发式的，代表1到8之间的多项式度数的最接近，例如见[2.x.80] 。在更高的度数限制下，[2.x.81]，[2.x.82]的比例更准确，与通常用于内部惩罚方法的逆向估计有关。关于公式中使用的[1.x.62]网格尺寸[2.x.83]和[2.x.84]，我们注意到对流传输是定向的。因此，一个适当的比例是使用速度方向上的元素长度 [2.x.85] 。下面的代码从参考单元到实际单元的Jacobian的倒数得出这个比例，即我们近似 [2.x.86] 。相反，声波具有各向同性的特点，这就是为什么我们使用最小的特征尺寸，由[2.x.87]的最小奇异值代表，用于声学缩放 [2.x.88] 。最后，我们需要添加对流和声学限制，因为欧拉方程可以以速度传输信息 [2.x.89] 。

在这个教程程序中，我们使用了[1.x.63]的一个具体变体，一般来说，它使用以下更新程序，从时间[2.x.91]的状态[2.x.90]到新时间[2.x.92]的[2.x.93] ：[1.x.64 ] 在[2.x.96]阶段方案中，向量[2.x.94]、[2.x.95]是算子在某个中间状态的评价，并通过某种线性组合用于定义步骤结束值[2.x.97]。该方案中的标量系数[2.x.98]、[2.x.99]和[2.x.100]的定义，使高阶方案满足某些条件，最基本的是[2.x.101]。参数通常以所谓的[1.x.65]的形式收集，它收集了定义该方案的所有系数。对于一个五阶段的方案，它看起来像这样。[1.x.66] 

在本教程中，我们使用显式Runge--Kutta方法的一个子集，即所谓的低存储Runge--Kutta方法（LSRK），它假定了系数的额外结构。在参考文献[2.x.102]所使用的变体中，假设使用形式为[1.x.67]的Butcher tableaus 有了这样的定义，对[2.x.103]的更新与中间值的信息共享存储 [2.x.104] 。从[2.x.105]和[2.x.106]开始，每个[2.x.107]阶段的更新简化为[1.x.68] 除了连续更新的向量[2.x.108]，这个方案只需要两个辅助向量，即保存微分算子评估的向量[2.x.109]和保存微分算子应用的右手边的向量[2.x.110] 。在后续阶段[2.x.111]，值[2.x.112]和[2.x.113]可以使用相同的存储。

低存储量变体的主要优点是一方面减少了内存消耗（如果必须在内存中装入非常多的未知数，持有所有的[2.x.114]来计算后续的更新，对于[2.x.115]来说已经是一个极限，在5到8之间 - 记得我们使用的是显式方案，所以我们不需要存储任何通常比几个向量大很多的矩阵），另一方面是减少内存访问。在这个程序中，我们对后一个方面特别感兴趣。由于运算符评估的成本只是简单地从内存中流转输入和输出向量的一小部分，我们必须考虑向量更新的成本，低存储量的变体可以提供两倍于传统显式Runge--Kutta方法的吞吐量，因为这个原因，见例如 [2.x.116] 中的分析。

除了参考文献[2.x.117]中的三阶、四阶和五阶精度的三个变体外，我们还使用了一个四阶精度的七级变体，该变体针对声学设置进行了优化 [2.x.118] 。声学问题是欧拉方程的亚音速体系中有趣的方面之一，其中可压缩性导致了声波的传播；通常，人们使用围绕背景状态的线性化欧拉方程的进一步简化，或围绕固定框架的声波方程。


[1.x.69][1.x.70] 


这个程序中使用的主要成分是我们用来评估算子 [2.x.119] 和反质量矩阵 [2.x.120] 的快速无矩阵技术。实际上，术语[1.x.71]有点名不副实，因为我们是在处理一个非线性算子，并没有将算子线性化，而算子又可以用矩阵表示。然而，如[2.x.121]和[2.x.122]所示，积分的快速评估已成为流行的稀疏矩阵-向量产品的替代方法，为此我们在交易二中创造了这个基础设施[1.x.72]。此外，反质量矩阵确实是以无矩阵的方式应用的，详见下文。

无矩阵的基础设施使我们能够快速评估弱形式的积分。其成分是将解系数快速插值为正交点的值和导数，在正交点进行逐点操作（在这里我们实现了上面推导的微分算子），以及与所有测试函数相乘和对正交点求和。第一和第三部分利用了和因子化，并在[2.x.123]的单元积分和[2.x.124]的面积分的教程程序中得到了广泛的讨论。唯一的区别是，我们现在处理的是一个[2.x.125]分量系统，而不是以前教程中的标量系统。在代码中，所有的变化是FEEvaluation和FEFaceEvaluation类的一个模板参数，即设置分量的数量。对向量的访问和以前一样，都由评价器透明地处理。我们还注意到，下面的代码中选择的单一评价器的变体并不是唯一的选择--我们也可以为单独的组件[2.x.126]、[2.x.127]和[2.x.128]使用单独的评价器；鉴于我们对所有组件的处理是相似的（也反映在我们把方程作为一个向量系统的方式），这里会更加复杂。和以前一样，FEEvaluation类通过结合对几个单元（和面）的操作来提供显式的矢量化，涉及的数据类型称为VectorizedArray。由于这种类型的算术运算都是重载的，所以我们不必为它费心，除了通过函数接口对函数进行评估，我们需要同时为几个正交点的位置提供特殊的[1.x.73]评估结果。

这个程序中更大的变化是在正交点的操作。在这里，多分量评估器为我们提供了以前没有讨论过的返回类型。当[2.x.129]为[2.x.130]的拉普拉斯返回一个标量（由于跨单元的矢量化，更准确地说，是一个VectorizedArray类型）时，它现在返回的类型是 "Tensor<1,dim+2,VectorizedArray<Number>"。同样，梯度类型现在是`张量<1,dim+2,张量<1,dim,矢量化数组<Number>>`，其中外部张量收集了欧拉系统的`dim+2'分量，内部张量是各个方向的偏导数。例如，欧拉系统的通量[2.x.131]就属于这种类型。为了减少我们为拼出这些类型而写的代码量，我们尽可能使用C++的`自动'关键字。

从实现的角度来看，非线性并不是一个很大的困难。它是在我们表达欧拉弱形式的条款时自然引入的，例如在动量项的形式中 [2.x.132] 。为了得到这个表达式，我们首先从动量变量 [2.x.134] 推导出速度 [2.x.133] 。鉴于[2.x.135]被表示为[2.x.136]度的多项式，正如[2.x.137]一样，速度[2.x.138]是参考坐标[2.x.139]的一个有理表达。当我们进行乘法[2.x.140]时，我们得到的表达式是两个多项式的比值，分子中的多项式程度[2.x.141]和分母中的多项式程度[2.x.142]。结合测试函数的梯度，对于仿形单元，即平行四边形/平行四边形，分子中的积分为[2.x.143]，分母中的积分为[2.x.144]。对于曲线单元，当积分乘以映射的雅各布系数的行列式时，会出现额外的多项式和有理数表达。在这一点上，人们通常需要放弃坚持精确的积分，而采取高斯（更确切地说，高斯-勒格伦德）正交提供的任何精度。这时的情况与拉普拉斯方程的情况类似，积分项包含非affince单元上的有理表达式，也只能进行近似积分。由于这些公式只对多项式进行精确积分，我们不得不以积分误差的形式忍受[1.x.74]的影响。

虽然不准确的积分对于椭圆问题来说通常是可以容忍的，但对于双曲问题来说，不准确的积分会引起一些令人头痛的效应，这种效应称为[1.x.75]。这个术语来自于信号处理，表达了不适当的、太粗糙的采样的情况。就正交而言，不适当的采样意味着我们使用的正交点与准确采样变系数积分所需的点相比太少。在DG文献中已经表明，别离误差会在[1.x.76]解析模拟的数值解中引入非物理性的振荡。别名主要影响到粗略的分辨率--而采用相同方案的更细的网格则工作良好--这一事实并不令人惊讶，因为分辨率高的模拟往往在一个单元的长度尺度上是平滑的（即，它们在较高的多项式程度上有小的系数，由于正交点太少而被遗漏，而在较低的多项式程度上的主要解贡献仍然被很好地捕获--这只是泰勒定理的一个结果）。为了解决这个问题，DG文献中提出了各种方法。一种技术是过滤，它可以抑制与高次多项式度数有关的解成分。由于所选择的节点基不是分层的，这就意味着要从节点基转化为分层基（例如，基于Legendre多项式的模态基），其中单元内的贡献是按多项式程度划分的。在这个基础上，我们可以将与高度数相关的求解系数乘以一个小数，保持低度数不变（以避免破坏一致性），然后再转换回节点基础。然而，过滤器会降低该方法的准确性。另一个在某种意义上更简单的策略是使用更多的正交点来更准确地捕捉非线性项。每个坐标方向使用超过[2.x.145]的正交点有时被称为过度积分或一致积分。后者在不可压缩的Navier-Stokes方程的背景下最为常见，其中[2.x.146]非线性导致度数为[2.x.147]的多项式积分（当同时考虑测试函数时），只要元素的几何形状是仿生的，就可以用每个方向的[2.x.148]正交点精确积分。在非多项式积分的欧拉方程的背景下，选择就不那么明确了。根据各种变量的变化，[2.x.149]或[2.x.150]点（分别精确积分度为[2.x.151]或[2.x.152]的多项式）都很常见。

为了反映程序中正交选择的这种可变性，我们把正交点的数量作为一个变量来指定，就像多项式的度数一样，并注意到人们会根据流量配置做出不同的选择。默认选择是[2.x.153]点--比最小可能的[2.x.154]点多一点。FEEvaluation和FEFaceEvaluation类允许通过模板参数无缝地改变点的数量，这样程序就不会因此而变得更复杂。


[1.x.77][1.x.78] 。


最后一个要素是反质量矩阵的评估 [2.x.155] 。在具有显式时间积分的DG方法中，质量矩阵是块状对角线，因此很容易反转--只需要反转对角线块。然而，考虑到无矩阵的积分评估在成本上更接近于只访问向量，即使应用块对角矩阵（例如通过LU因子的数组）也会比评估[2.x.156]的成本高几倍，仅仅是因为对于高阶有限元来说，仅仅存储和加载大小为`dofs_per_cell`乘`dofs_per_cell`的矩阵是昂贵的。由于这显然是不可取的，部分社区已经转向质量矩阵是对角线的基，例如[1.x.79]正交Legendre基，使用分层多项式或高斯四分法点上的拉格朗日多项式（这只是利用Legendre信息的另一种方式）。虽然对角线属性对于变形元素来说是失效的，但通过采取对角线质量矩阵而忽略其余部分（质量包络的变种，尽管不是[2.x.157]中利用的具有额外积分误差的变种）所产生的误差已被证明不会改变离散化精度。高斯正交点中的拉格朗日基础有时也被称为同位设置，因为多项式的结点与正交点重合（="同位"），避免了一些内插操作。鉴于我们想在[2.x.158]中对非线性项使用更多的正交点，然而，拼合属性就失去了。(更确切地说，在改变基础后，它仍然用于FEEvaluation和FEFaceEvaluation，见无矩阵论文 [2.x.159] ) 。

在这个教程程序中，我们使用拼合的思想来应用反质量矩阵，但有一个小小的转折。与其在高斯四分法的点上通过拉格朗日多项式使用配位，我们更喜欢在高斯-洛巴托的点上使用传统的拉格朗日基础，因为那些使面积分的评估变得便宜。这是因为对于高斯-洛巴托点来说，一些节点点位于单元格的面上，而且不难证明，在任何给定的面上，唯一具有非零值的形状函数正是其节点点事实上位于该面上的那些。当然，我们也可以像[2.x.160]中那样使用高斯-洛巴托正交（有一些额外的积分误差），但我们不想牺牲精度，因为这些正交公式通常比一般高斯正交公式的阶数低。相反，我们使用参考文献[2.x.161]中描述的一个想法，其中提出为了应用反质量矩阵而改变基础。让我们用[2.x.162]表示在正交点评估的形状函数矩阵，形状函数在矩阵的行中，正交点在列中。然后，单元格[2.x.163]上的质量矩阵由[1.x.80]给出 这里，[2.x.164]是对角线矩阵，其条目为雅各布系数乘以正交权重（JxW）的决定数。矩阵[2.x.165]被构造为一维矩阵的克朗克积（张量积），例如在三维中为[1.x.81]，这是基础函数是一维形状函数的张量积，正交公式是一维正交公式的张量积的结果。对于多项式的数量等于正交点的数量的情况，[2.x.166]中的所有矩阵都是方形的，同样，克朗克积中的[2.x.167]的成分也是方形的。因此，我们可以对每个矩阵进行反转，形成整体的逆，[1.x.82]这个公式的结构与用和因子化技术对积分进行正向评估的步骤完全相同（即交易二的FEEvaluation和MatrixFree框架）。因此，我们可以利用相同的代码路径，采用不同的插值矩阵，[2.x.168]而不是[2.x.169] 。

类[2.x.170]实现了这个操作。它从有限元中包含的基（在此情况下，FE_DGQ）变为高斯正交点中的拉格朗日基。在这里，可以评估对角线质量矩阵的逆，这只是`JxW`因子的逆（即正交权重乘以从参考坐标到实坐标的雅各布系数）。一旦这样做了，我们就可以变回标准的节点高斯-洛巴托基础。

这种应用反质量矩阵的特殊方式的优点是成本类似于质量矩阵的正向应用，比用超积分和面积分评估空间算子[2.x.171]要便宜。(我们将在[1.x.83]中用详细的时序信息证明这一点。)事实上，它是如此便宜，以至于在大多数现代架构上，它受到读取源向量、读取对角线和写入目标向量的带宽限制。用于结果部分的硬件可以使计算的速度至少比从内存流向量的速度快一倍。


[1.x.84][1.x.85] 


在这个教程程序中，我们实现了两个测试案例。第一个案例是限于两个空间维度的收敛性测试。它运行一个所谓的等熵涡旋，通过背景流场进行传输。第二个案例使用了一个更令人兴奋的设置。我们从一个浸在通道中的圆柱体开始，使用[2.x.172]函数。在这里，我们强加一个马赫数为[2.x.173]的亚音速初始场，在[2.x.174]方向上速度不变。在顶壁和底壁以及圆柱体上，我们施加了一个无穿透（即切向流动）的条件。与初始条件相比，这种设置迫使气流重新定向，从而导致大的声波从圆柱体上传播出去。在上游方向，波的传播速度较慢（因为它必须逆着迎面而来的气体移动），包括密度和压力的不连续。在下游方向，由于声音的传播和流体的流动方向相同，传输速度较快，这在一定程度上抹去了不连续性。一旦声波碰到上下壁，声音就会被反射回来，形成一些漂亮的形状，如下图[1.x.86]所示。[1.x.87] [1.x.88]。

包含的文件与之前的无矩阵教程程序[2.x.175], [2.x.176], 和[2.x.177]相似。 

[1.x.89] 



下面的文件包括CellwiseInverseMassMatrix数据结构，我们将用它来进行质量矩阵反演，这是本教程程序唯一一个新的包含文件。

[1.x.90] 



与其他无矩阵教程程序类似，我们在文件顶部收集所有控制程序执行的参数。除了我们想要运行的维度和多项式程度，我们还指定了我们想要用于欧拉方程中的非线性项的高斯正交公式中的点数。此外，我们指定了随时间变化的问题的时间间隔，并实现了两个不同的测试案例。第一个是二维的分析解，而第二个是介绍中描述的围绕圆柱体的通道流。根据测试案例，我们还改变了运行仿真的最终时间，以及一个变量`output_tick`，它指定了我们要在哪个时间间隔内写入输出（假设tick大于时间步长）。

[1.x.91] 



接下来是时间积分器的一些细节，即用公式[2.x.178]来衡量时间步长的Courant数，以及选择一些低存储量的Runge-Kutta方法。我们指定Runge--Kutta方案的每一阶段的Courant数，因为这对不同阶段数的方案给出了一个更现实的数字成本表达。

[1.x.92] 



最终，我们选择了空间离散化的一个细节，即单元间面的数值通量（黎曼求解器）。对于这个程序，我们实现了Lax--Friedrichs通量和Harten--Lax--van Leer(HLL)通量的一个修正变体。

[1.x.93] 




[1.x.94] [1.x.95]。




我们现在定义了一个具有试验例0的精确解的类，以及一个具有试验例1的通道背景流场的类。鉴于欧拉方程是一个在[2.x.180]维度上有[2.x.179]个方程的问题，我们需要告诉函数基类关于正确的分量数量。

[1.x.96] 



就实际实现的函数而言，分析性测试案例是一个等熵涡流案例（例如，见Hesthaven和Warburton的书，第209页第6.6节的例6.1），它满足欧拉方程，其右侧的力项为零。考虑到这个定义，我们返回密度、动量或能量，这取决于所要求的成分。请注意，密度的原始定义涉及一些表达式的[2.x.181]-次方。由于[2.x.182]在某些系统上的实现速度相当慢，我们用对数和指数（以2为底）来代替它，这在数学上是等价的，但通常优化得更好。与[2.x.183]相比，这个公式对于非常小的数字来说，在最后一位数上可能会失去准确性，但我们还是很满意，因为小数字映射到接近1的数据。   


对于通道测试案例，我们简单地选择密度为1，[2.x.184]方向的速度为0.4，其他方向的速度为0，以及对应于根据背景速度场测量的1.3声速的能量，根据关系[2.x.185]计算。

[1.x.97] 




[1.x.98] [1.x.99] 。




接下来的几行实现了一些低存储量的Runge--Kutta方法的变体。这些方法有特定的布彻表，系数为[2.x.186]和[2.x.187]，如介绍中所示。如同Runge--Kutta方法中的惯例，我们可以从这些系数中推导出时间步长[2.x.188]。这种方案的主要优点是每个阶段只需要两个向量，即解的累积部分[2.x.189]（在最后一个阶段后的新时间[2.x.191]保持解[2.x.190]），在各阶段被评估的更新向量[2.x.192]，加上一个向量[2.x.193]以保持运算器的评估。这样的Runge-Kutta设置减少了内存存储和内存访问。由于内存带宽通常是现代硬件上的性能限制因素，当微分算子的评估得到很好的优化时，性能可以比标准的时间积分器得到改善。考虑到传统的Runge--Kutta方案可能允许稍大的时间步长，因为更多的自由参数可以获得更好的稳定性，这也是事实。   


在本教程中，我们集中讨论Kennedy, Carpenter和Lewis(2000)文章中定义的低存储方案的几个变体，以及Tselios和Simos(2007)描述的一个变体。还有一大系列的其他方案，可以通过额外的系数集或稍微不同的更新公式来解决。   


我们为这四种积分器定义了一个单一的类别，以上述枚举的方式加以区分。对每个方案，我们再将[2.x.194]和[2.x.195]的向量填充到类中的给定变量。

[1.x.100] 



首先是Kennedy等人（2000）的三阶方案。虽然它的稳定区域明显小于其他方案，但它只涉及三个阶段，所以在每个阶段的工作方面非常有竞争力。

[1.x.101] 



下一个方案是四阶的五级方案，同样在Kennedy等人（2000）的论文中定义。

[1.x.102] 



以下是针对声学问题明确导出的七级四阶方案。它在四阶方案中兼顾了虚特征值的精度，并结合了大的稳定区域。由于DG方案在最高频率之间是耗散的，这不一定转化为每级可能的最高时间步长。在本教程方案的背景下，数值通量在耗散中起着至关重要的作用，因此也是最大的稳定时间步长。对于修正的Lax--Friedrichs通量，如果只考虑稳定性，这个方案在每阶段的步长方面与`stage_5_order_4`方案相似，但对于HLL通量来说，效率略低。

[1.x.103] 



这里包括的最后一个方案是Kennedy等人（2000）的九级五阶方案。它是这里使用的方案中最精确的，但较高的精度等级牺牲了一些稳定性，所以每级的归一化步长小于四阶方案。

[1.x.104] 



时间积分器的主要功能是经历各阶段，评估算子，为下一次评估准备[2.x.196]向量，并更新解向量[2.x.197] 。我们将工作移交给所涉及的`pde_operator`，以便能够将Runge--Kutta设置的矢量操作与微分算子的评估合并起来，以获得更好的性能，所以我们在这里所做的只是委托矢量和系数。     


我们单独调用第一阶段的算子，因为我们在那里需要稍微修改一下参数。我们从旧的解决方案[2.x.198]而不是[2.x.199]向量中评估解决方案，所以第一个参数是`solution'。我们在这里让阶段向量[2.x.200]也持有评估的临时结果，因为它不用于其他方面。对于所有后续阶段，我们使用向量`vec_ki`作为第二个向量参数来存储运算符的求值结果。最后，当我们处于最后阶段时，我们必须跳过对向量[2.x.201]的计算，因为没有系数[2.x.202]可用（也不会用到）。

[1.x.105] 




[1.x.106] [1.x.107]。




在下面的函数中，我们实现了与欧拉方程有关的各种特定问题的运算符。每个函数都作用于我们在解向量中持有的守恒变量向量[2.x.203]，并计算各种衍生量。   


首先是速度的计算，我们通过除以[2.x.205]从动量变量[2.x.204]中得出。这里需要注意的是，我们用关键字`DEAL_II_ALWAYS_INLINE`来装饰所有这些函数。这是一个特殊的宏，映射到一个编译器专用的关键字，告诉编译器永远不要为这些函数创建一个函数调用，而是将实现[1.x.108]移到它们被调用的地方。这对性能至关重要，因为我们对其中一些函数的调用达到了几百万甚至几十亿次。例如，我们既使用速度来计算通量，也使用速度来计算压力，而这两个地方都要在每个单元的每个正交点进行计算。确保这些函数是内联的，不仅可以确保处理器不必执行跳转指令进入函数（以及相应的返回跳转），而且编译器可以在调用函数的地方之后的代码中重新使用一个函数的上下文的中间信息。(我们注意到，编译器通常很善于自己找出哪些函数要内联。在这里，编译器可能会也可能不会自己想出来，但我们可以肯定的是，内联是一个胜利。)    


我们应用的另一个技巧是为逆密度设置一个单独的变量 [2.x.206] 。这使得编译器只对通量进行一次除法，尽管除法在多个地方使用。由于除法的费用大约是乘法或加法的10到20倍，避免多余的除法对性能至关重要。我们注意到，由于四舍五入的影响，在浮点运算中，先取反数，后与之相乘并不等同于除法，所以编译器不允许用标准的优化标志来交换一种方式。然而，以正确的方式编写代码也不是特别困难。   


总而言之，所选择的总是内联和仔细定义昂贵的算术运算的策略使我们能够写出紧凑的代码，而不传递所有的中间结果，尽管要确保代码映射到优秀的机器代码。

[1.x.109] 



下一个函数使用公式[2.x.207]从保守变量矢量计算压力。如上所述，我们使用来自`euler_velocity()`函数的速度。注意，我们需要在这里指定第一个模板参数`dim`，因为编译器无法从张量的参数中推导出它，而第二个参数（数字类型）可以自动推导出来。

[1.x.110] 



这里是欧拉通量函数的定义，也就是实际方程的定义。考虑到速度和压力（编译器的优化将确保只做一次），考虑到引言中所述的方程，这是直截了当的。

[1.x.111] 



下一个函数是简化数值通量实现的辅助工具，实现了张量的张量（具有非标准的外维尺寸`dim + 2`，所以deal.II的张量类提供的标准重载在此不适用）与另一个相同内维的张量的作用，即矩阵-向量乘积。

[1.x.112] 



这个函数实现了数值通量（黎曼求解器）。它从一个界面的两边获得状态和法向量，从解的一边向解 [2.x.208] 。在依赖片断恒定数据的有限体积方法中，数值通量是核心成分，因为它是唯一输入物理信息的地方。在DG方法中，由于元素内部的多项式和那里使用的物理通量，数值通量就不那么核心了。由于在连续解的极限中，两边的数值一致的高阶插值，数值通量可以被看作是对两边解的跳跃的控制，以弱化连续性。必须认识到，在存在冲击的情况下，仅靠数值通量是无法稳定高阶DG方法的，因此任何DG方法都必须与进一步的冲击捕捉技术相结合，以处理这些情况。在本教程中，我们重点讨论了欧拉方程在亚声速体系中没有强不连续的波状解，我们的基本方案是足够的。   


然而，数值通量对整个方案的数值耗散起着决定性作用，并影响到显式Runge-Kutta方法的可接受的时间步长。我们考虑两种选择，一种是改良的Lax-Friedrichs方案，另一种是广泛使用的Harten-Lax-van Leer（HLL）通量。对于这两种变体，我们首先需要得到界面两侧的速度和压力，并评估物理欧拉通量。   


对于局部Lax--Friedrichs通量，其定义为[2.x.210]，其中因子[2.x.211]给出了最大波速，[2.x.212]是音速。在这里，考虑到通量对解的影响较小，出于计算效率的考虑，我们选择该表达式的两个修改。对于上述因子[2.x.213]的定义，我们需要取四个平方根，两个用于两个速度规范，两个用于两侧的声速。因此，第一个修改是宁可使用[2.x.214]作为最大速度的估计（如介绍中所示，它与实际最大速度最多相差2倍）。这使得我们可以从最大速度中抽出平方根，并且只需进行一次平方根计算就可以了。第二个修改是进一步放宽参数[2.x.215]--它越小，耗散系数就越小（与[2.x.216]中的跳跃相乘，最终可能会导致耗散变小或增大）。这使我们能够将频谱纳入显式Runge--Kutta积分器的稳定区域，并具有更大的时间步长。然而，我们不能使耗散太小，因为否则假想的特征值会越来越大。最后，目前的保守公式在[2.x.217]的极限中不是能量稳定的，因为它不是偏斜对称的，在这种情况下需要额外的措施，如分裂形式的DG方案。   


对于HLL通量，我们遵循文献中的公式，通过一个参数引入Lax--Friedrichs的两个状态的额外加权 [2.x.218] 。它是由欧拉方程的物理传输方向得出的，以当前的速度方向和声速为准。对于速度，我们在这里选择一个简单的算术平均数，这对于危险情况和材料参数的适度跳跃是足够的。   


由于数值通量在弱形式下是与法向量相乘的，因此我们对方程中的所有项都用法向量来乘以结果。在这些乘法中，上面定义的 "运算器*"能够实现类似于数学定义的紧凑符号。   


在这个函数和下面的函数中，我们使用变量后缀`_m`和`_p`来表示从[2.x.219]和[2.x.220]中得到的量，即在观察相邻单元时，相对于当前单元的 "这里 "和 "那里 "的值。

[1.x.113] 



这个和下一个函数是辅助函数，提供紧凑的评估调用，因为多个点通过VectorizedArray参数被分批放在一起（详见[2.x.221]教程）。这个函数用于亚音速外流边界条件，我们需要将能量分量设置为一个规定值。下一个函数请求所有分量上的解，用于流入边界，其中解的所有分量都被设置。

[1.x.114] 




[1.x.115][1.x.116] 。




该类实现了欧拉问题的评估器，类似于 [2.x.222] 或 [2.x.223] 的 `LaplaceOperator` 类。由于本算子是非线性的，不需要矩阵接口（交给预处理程序），我们跳过了无矩阵算子中的各种`vmult`函数，只实现了`apply`函数以及`apply`与上述低存储Runge-Kutta时间积分器所需的矢量更新的组合（称为`perform_stage`）。此外，我们还增加了三个涉及无矩阵例程的函数，即根据元素中的速度和声速计算时间步长的估计值（与实际时间步长的Courant数相结合），一个用于解决方案的投影（专门针对DG情况的[2.x.224]），以及一个用于计算与可能的分析解决方案或与某些背景状态的规范的误差。   


这门课的其余部分与其他无矩阵教程类似。正如介绍中所讨论的，我们提供了一些函数，允许用户在由[2.x.225]变量标记的领域边界的不同部分传递各种形式的边界条件，以及可能的体力。

[1.x.117] 



对于欧拉算子的初始化，我们设置了类中包含的MatrixFree变量。这可以给定一个描述可能的弯曲边界的映射以及描述自由度的DoFHandler对象来完成。由于我们在这个教程程序中使用的是不连续的Galerkin离散化，没有对解场施加强烈的约束，所以我们不需要传入AffineConstraints对象，而是使用一个假的来构造。关于正交，我们要选择两种不同的方式来计算基础积分。第一种是灵活的，基于模板参数`n_points_1d`（将被分配到本文件顶部指定的`n_q_points_1d`值）。更精确的积分是必要的，以避免由于欧拉算子中的可变系数而产生的混叠问题。第二个不太精确的正交公式是一个基于`fe_degree+1`的严密公式，需要用于反质量矩阵。虽然该公式仅在仿生元素形状上提供了精确的反，而在变形元素上则没有，但它能够通过张量乘积技术快速反转质量矩阵，这对于确保整体的最佳计算效率是必要的。

[1.x.118] 



随后的四个成员函数是必须从外部调用的，以指定各种类型的边界。对于一个流入的边界，我们必须以密度 [2.x.226] 、动量 [2.x.227] 和能量 [2.x.228] 来指定所有成分。考虑到这些信息，我们将函数和各自的边界ID一起存储在这个类别的地图成员变量中。同样，我们对亚音速外流边界（我们也要求一个函数，用来检索能量）和壁面（无穿透）边界进行处理，在壁面上我们施加零法线速度（不需要函数，所以我们只要求边界ID）。对于目前的DG代码来说，边界条件只作为弱形式的一部分被应用（在时间积分期间），设置边界条件的调用可以出现在对这个类的`reinit()`调用之前或之后。这与连续有限元代码不同，后者的边界条件决定了被送入MatrixFree初始化的AffineConstraints对象的内容，因此需要在无矩阵数据结构的初始化之前设置。   


在四个函数中的每一个中添加的检查是用来确保边界条件在边界的各个部分是相互排斥的，也就是说，用户不会意外地把一个边界既指定为流入边界，又指定为亚声速流出边界。

[1.x.119] 




[1.x.120] [1.x.121]。




现在我们继续讨论欧拉问题的局部评估器。评估器相对简单，并遵循 [2.x.229] 、 [2.x.230] 或 [2.x.231] 中的内容。第一个明显的区别是，我们使用的FEE估值具有非标准的正交点数量。以前我们总是将正交点的数量设置为等于多项式度数加1（确保在仿生元素形状上的精确积分），现在我们将正交点的数量设置为一个单独的变量（例如多项式度数加多项式度数的二分之一或三分之一），以便更准确地处理非线性项。由于评估器通过模板参数输入了适当的循环长度，并在变量[2.x.232]中保留了整个单元格中的正交点数量，我们现在自动操作更精确的公式，而不需要进一步修改。   


第二个区别是由于我们现在评估的是一个多分量系统，而不是之前考虑的标量系统。无矩阵框架提供了几种处理多成分情况的方法。这里显示的变体是利用一个嵌入了多个分量的FEEvaluation对象，由第四个模板参数`dim + 2`指定欧拉系统中的分量。因此，[2.x.233]的返回类型不再是标量（将返回VectorizedArray类型，收集多个元素的数据），而是`dim+2`组件的Tensor。该功能与标量的情况类似；它由一个基类的模板专业化处理，称为FEEvaluationAccess。另一个变体是使用几个FEEvaluation对象，一个标量对象用于密度，一个带`dim`分量的矢量值对象用于动量，另一个标量评估器用于能量。为了确保这些分量指向解决方案的正确部分，FEEvaluation的构造函数在所需的MatrixFree字段之后需要三个可选的整数参数，即多DoFHandler系统的DoFHandler编号（默认取第一个），如果有多个Quadrature对象，则取正交点的编号（见下文），以及作为第三个参数的矢量系统中的分量。由于我们有一个单一的矢量来表示所有的分量，我们将使用第三个参数，并将其设置为`0`表示密度，`1`表示矢量值的动量，`dim+1`表示能量槽。然后FEEvaluation在[2.x.234]和[2.x.235]或更紧凑的[2.x.236]和[2.x.237]调用中挑选合适的解矢量子范围。   


当涉及到体力向量的评估时，出于效率的考虑，我们对两种情况进行了区分。如果我们有一个常数函数（源自[2.x.238]），我们可以在正交点的循环外预先计算出数值，并简单地在所有地方使用该数值。对于一个更通用的函数，我们反而需要调用我们上面提供的`evaluate_function()`方法；这个路径更昂贵，因为我们需要访问与正交点数据相关的内存。   


其余的就按照其他教程的程序进行。由于我们已经在单独的`euler_flux()`函数中实现了欧拉方程的所有物理学，我们在这里所要做的就是调用这个函数，给定在正交点评估的当前解，由`phi.get_value(q)`返回，并告诉FEEvaluation对象排队，通过形状函数的梯度（这是一个外部`dim+2`分量的张量，每个张量持有一个`dim`成分的[2.x.239 ] 欧拉通量的分量）。) 最后值得一提的是，在我们得到一个外部函数的情况下，我们通过测试函数`phi.submit_value()`的值来排队测试数据的顺序。我们必须在调用`phi.get_value(q)'之后进行，因为`get_value()'（读取解决方案）和`submit_value()'（排队等待测试函数的乘法和正交点的求和）访问同一个底层数据域。这里很容易实现没有临时变量`w_q`，因为值和梯度之间没有混合。对于更复杂的设置，我们必须首先复制出例如一个正交点的值和梯度，然后通过[2.x.240]和[2.x.241]再次排队等待结果。    


最后，我们提到我们没有使用这个函数的第一个MatrixFree参数，这是一个来自[2.x.242]的回调，接口规定了现在的参数列表，但由于我们在一个成员函数中，MatrixFree对象已经可以作为`data`变量使用，我们坚持使用以避免混淆。

[1.x.122] 



下一个函数涉及到内部面的积分计算，在这里我们需要来自面附近的两个单元的评估器。我们将变量`phi_m`与解分量 [2.x.243] 相关联，将变量`phi_p`与解分量 [2.x.244] 相关联。在FEFaceEvaluation的构造函数中，我们通过第二个参数来区分两边，`true`代表内侧，`false`代表外侧，内侧和外侧表示相对于法向量的方向。   


注意，调用[2.x.245]和[2.x.246]结合了对向量和因式分解部分的访问。这种合并操作不仅节省了一行代码，而且还包含了一个重要的优化。鉴于我们在Gauss-Lobatto正交公式的点上使用拉格朗日多项式的节点基础，[2.x.247]中只有[2.x.248]的基础函数在每个面上评估为非零。因此，评估器只访问了向量中的必要数据，而跳过了乘以零的部分。如果我们首先读取向量，我们就需要从向量中加载所有的数据，因为孤立的调用不知道后续操作中需要哪些数据。如果随后的[2.x.249]调用要求数值和导数，确实需要每个分量的所有[2.x.250]向量条目，因为所有基函数的正常导数都是非零的。   


评价器的参数以及程序与单元评价相似。由于非线性项的存在，我们再次使用更精确的（过度）积分方案，指定为列表中第三个模板参数。在正交点上，我们再去找我们的自由函数来计算数值通量。它从两边（即[2.x.251]和[2.x.252]）接收在正交点评估的解决方案，以及到负边的法向量。正如上面所解释的，数值通量已经乘以来自减法侧的法向量了。我们需要转换符号，因为在引言中导出的弱形式中，边界项带有一个减号。然后，通量在减号和加号上都排队等待测试，由于来自加号的法向量与来自减号的法向量正好相反，所以换了符号。

[1.x.123] 



对于位于边界的面，我们需要施加适当的边界条件。在这个教程程序中，我们实现了上述的四种情况。第五种情况，即超音速流出条件，将在下面的 "结果 "部分讨论）。不连续的Galerkin方法对边界条件的施加不是作为约束条件，而只是弱化。因此，各种条件是通过找到一个适当的[1.x.124]量[2.x.253]来施加的，然后交给也用于内部面的数值通量函数。实质上，我们在域外 "假装 "一个状态，如果那是现实，PDE的解就会满足我们想要的边界条件。   


对于墙的边界，我们需要对动量变量施加一个无正态通量的条件，而对于密度和能量，我们使用的是诺伊曼条件 [2.x.254] 和 [2.x.255] 。为了实现无正态通量条件，我们将外部数值设置为内部数值，并减去壁面法线方向的2倍速度，即法线矢量方向的速度。   


对于流入边界，我们简单地将给定的Dirichlet数据[2.x.256]作为边界值。另一种方法是使用[2.x.257] ，即所谓的镜像原理。   


强加外流实质上是一个诺伊曼条件，即设置 [2.x.258] 。对于亚音速流出的情况，我们仍然需要强加一个能量值，我们从各自的函数中得出这个值。对于[1.x.125]的情况，即在Neumann部分有动量通入域的情况，需要一个特殊的步骤。根据文献（这一事实可以通过适当的能量论证得出），我们必须改用流入部分的通量的另一种变体，见Gravemeier, Comerford, Yoshihara, Ismail, Wall, "A novel formulation for Neumann inflow conditions in biomechanics", Int. J. Numer. Meth. 生物医学。Eng., vol. 28 (2012). 这里，动量项需要再次添加，这相当于去除动量变量上的通量贡献。我们在后处理步骤中这样做，而且只适用于我们都处于外流边界且法向量与动量（或等同于速度）之间的点积为负的情况。由于我们在SIMD矢量化时一次处理几个正交点的数据，因此我们在这里需要明确地在SIMD数组的条目上循环。   


在下面的实现中，我们在正交点的层面上检查各种类型的边界。当然，我们也可以将决定权移出正交点循环，将整个面作为同类处理，这就避免了在正交点的内循环中进行一些地图/集合查找。然而，效率的损失并不明显，所以我们在这里选择了更简单的代码。还要注意的是，最后的 "else "子句会捕捉到边界的某些部分没有通过[2.x.259]分配任何边界条件的情况。 

[1.x.126] 



下一个函数实现了质量矩阵的逆运算。算法和原理已经在介绍中进行了广泛的讨论，所以我们在这里只讨论[2.x.260]类的技术问题。它所做的操作与质量矩阵的正向评估类似，只是使用了不同的插值矩阵，代表反[2.x.261]因子。这些代表了从指定的基础（在这种情况下，高斯--洛巴托正交公式点中的拉格朗日基础）到高斯正交公式点中的拉格朗日基础的改变。在后者的基础上，我们可以应用点的逆向`JxW`因子，即正交权重乘以从参考坐标到实坐标的映射的雅各布系数。一旦完成了这一操作，基数将再次变回节点高斯-洛巴托基数。所有这些操作都由下面的 "apply() "函数完成。我们需要提供的是要操作的局部场（我们通过FEEvaluation对象从全局向量中提取），并将结果写回质量矩阵操作的目标向量。   


需要注意的一点是，我们在FEEvaluation的构造函数中添加了两个整数参数（可选），第一个是0（在多DoFHandler系统中选择DoFHandler；在这里，我们只有一个），第二个是1，用于进行正交公式选择。由于我们将正交公式0用于非线性项的过度积分，我们将公式1与默认的[2.x.262]（或变量名称中的`fe_degree+1`）点用于质量矩阵。这导致了对质量矩阵的平方贡献，并确保了精确的积分，正如介绍中所解释的。

[1.x.127] 




[1.x.128][1.x.129] 




现在我们来看看实现欧拉算子整体评价的函数，即[2.x.263]，调用上述的局部评价器。这些步骤在前面的代码中应该是清楚的。需要注意的一点是，我们需要调整与边界各部分相关的函数中的时间，以便在边界数据随时间变化的情况下与方程一致。然后，我们调用[2.x.264]来执行单元和面的积分，包括在`src`向量中进行必要的ghost数据交换。该函数的第七个参数，"true"，指定我们要在开始向其累积积分之前，将 "dst "向量作为循环的一部分归零。这个变体比在循环之前明确调用`dst = 0.;`要好，因为归零操作是在矢量的子范围内完成的，其部分是由附近的积分写入的。这加强了数据的定位，并允许缓存，节省了向量数据到主内存的一次往返，提高了性能。循环的最后两个参数决定了哪些数据被交换：由于我们只访问一个面的形状函数的值，这是典型的一阶双曲问题，并且由于我们有一个节点基础，节点位于参考元素表面，我们只需要交换这些部分。这又节省了宝贵的内存带宽。   


一旦应用了空间算子[2.x.265]，我们需要进行第二轮，应用反质量矩阵。这里，我们称之为[2.x.266]，因为只有单元积分出现。单元循环比全循环更便宜，因为只访问与局部拥有的单元相关的自由度，这只是DG离散化的局部拥有的自由度。因此，这里不需要鬼魂交换。   


在所有这些函数的周围，我们设置了定时器范围来记录计算时间，以统计各部分的贡献。

[1.x.130] 



让我们转到做Runge--Kutta更新的整个阶段的函数。它调用[2.x.267]，然后对向量进行一些更新，即`next_ri = solution + factor_ai * k_i`和`solution += factor_solution * k_i`。与其通过向量接口执行这些步骤，我们在这里提出了一个替代策略，在基于缓存的架构上速度更快。由于向量所消耗的内存往往比缓存所能容纳的要大得多，所以数据必须有效地来自缓慢的RAM内存。这种情况可以通过循环融合来改善，即在一次扫描中对`next_ki`和`solution`进行更新。在这种情况下，我们将读取两个向量`rhs`和`solution`并写入`next_ki`和`solution`，而在基线情况下，至少有4次读取和两次写入。在这里，我们更进一步，当质量矩阵反转在向量的某一部分完成后，立即执行循环。 [2.x.268]提供了一种机制，在单元格的循环第一次接触到一个向量条目之前，附加一个[2.x.269]（我们在这里没有使用，但是例如用于向量的清零），以及在循环最后接触到一个条目之后，再调用第二个[2.x.270]。回调的形式是给定向量上的一个范围（就MPI宇宙中的本地索引编号而言），可以由`local_element()`函数处理。   


对于这第二个回调，我们创建一个在范围上工作的lambda，并在这个范围上写入相应的更新。理想情况下，我们会在本地循环之前添加`DEAL_II_OPENMP_SIMD_PRAGMA`，以建议编译器对这个循环进行SIMD并行化（这意味着在实践中，我们要确保我们在循环内使用的指针的索引范围之间没有重叠，也称为别名）。事实证明，在写这篇文章的时候，GCC 7.2无法编译lambda函数中的OpenMP pragma，所以我们在下面注释了这个pragma。如果你的编译器比较新，你应该可以再次取消注释这些行。   


注意，当我们不需要更新`next_ri`向量时，我们为最后的Runge--Kutta阶段选择了不同的代码路径。这个策略带来了相当大的速度提升。在40核机器上，默认矢量更新时，逆质量矩阵和矢量更新需要60%以上的计算时间，而在更优化的变体中，这一比例约为35%。换句话说，这是一个大约三分之一的速度。

[1.x.131] 



在讨论了处理推进解的一个时间步长的函数的实现后，现在让我们来看看实现其他辅助操作的函数。具体来说，这些是计算投影、评估误差和计算单元上信息传输速度的函数。   


其中第一个函数基本上等同于[2.x.271]，只是速度快得多，因为它是专门针对DG元素的，不需要设置和解决线性系统，因为每个元素都有独立的基函数。我们在这里展示代码的原因，除了这个非关键操作的小幅提速之外，还因为它显示了[2.x.272]提供的额外功能     


投影操作的工作原理如下。如果我们用[2.x.273]表示在正交点评估的形状函数矩阵，在单元格[2.x.274]上的投影是一个形式为[2.x.275]的操作，其中[2.x.276]是包含雅各布系数乘以正交权重（JxW）的对角线矩阵，[2.x.277]是单元格的质量矩阵，[2.x.278]是要投影到正交点的场的评估。实际上，矩阵[2.x.279]通过张量积有额外的结构，如介绍中所解释的）。这个系统现在可以等效地写成[2.x.280] 。现在，项[2.x.281]和[2.x.282]相抵消，导致最终表达式[2.x.283] 。这个操作由[2.x.284]实现。这个名字来自于这个投影只是乘以[2.x.285]，一个从高斯正交点的节点基到给定的有限元基的基数变化。请注意，我们调用[2.x.286]将结果写入矢量，覆盖之前的内容，而不是像典型的积分任务那样累积结果--我们可以这样做，因为对于不连续的Galerkin离散，每个矢量条目都只有一个单元的贡献。

[1.x.132] 



下一个函数再次重复了deal.II库提供的功能，即[2.x.287]，我们在此展示了明确的代码，以强调跨多个单元的矢量化是如何工作的，以及如何通过该接口累积结果。回顾一下，矢量化数组的每个[1.x.133]都持有来自不同单元的数据。通过对当前MPI进程所拥有的所有单元批的循环，我们就可以填充一个结果的VectorizedArray；为了得到一个全局的总和，我们需要进一步去对SIMD阵列中的条目进行求和。然而，这样的程序并不稳定，因为SIMD数组事实上可能并不持有其所有通道的有效数据。当本地拥有的单元的数量不是SIMD宽度的倍数时，就会发生这种情况。为了避免无效数据，我们必须在访问数据时明确地跳过那些无效的通道。虽然人们可以想象，我们可以通过简单地将空车道设置为零（从而不对总和做出贡献）来使其工作，但情况比这更复杂。如果我们要从动量中计算出一个速度呢？那么，我们就需要除以密度，而密度是零--结果就会是NaN，并污染结果。当我们在单元格批次中循环时，使用函数[2.x.288]给我们提供有效数据的通道数，累积有效SIMD范围内的结果，就可以避免这个陷阱了。它在大多数单元上等于[2.x.289]，但如果与SIMD宽度相比，单元数有余数，则在最后一个单元批上可能更少。

[1.x.134] 



EulerOperator类的最后一个函数用于估计传输速度，由网格大小缩放，这与设置显式时间积分器中的时间步长有关。在欧拉方程中，有两种传输速度，即对流速度[2.x.290]和声波的传播速度[2.x.291]，相对于以速度运动的介质[2.x.292] 。   


在时间步长的公式中，我们感兴趣的不是这些绝对速度，而是信息穿过一个单元所需的时间量。对于与介质一起传输的信息，[2.x.293]是由网格大小缩放的，所以最大速度的估计可以通过计算[2.x.294]得到，其中[2.x.295]是由实域到参考域的转换的雅各布系数。注意，[2.x.296]返回的是反转和转置的Jacobian，代表从实数到参考坐标的度量项，所以我们不需要再转置它。在下面的代码中，我们将这个极限存储在变量`convective_limit`中。   


声音的传播是各向同性的，所以我们需要考虑到任何方向的网格大小。适当的网格大小比例由[2.x.297]的最小奇异值给出，或者说，[2.x.298]的最大奇异值。请注意，当忽略弯曲的单元时，可以通过单元顶点之间的最小距离来近似这个量。为了得到Jacobian的最大奇异值，一般的策略是使用一些LAPACK函数。由于我们在这里所需要的是一个估计值，我们可以避免将一个向量数组的张量分解成几个矩阵的麻烦，并进入一个（昂贵的）没有向量的特征值函数，而是使用应用于[2.x.299]的幂方法的几次迭代（在下面的代码中为五次）。这个方法的收敛速度取决于最大特征值与次大特征值的比率以及初始猜测，也就是所有1的矢量。这可能表明，我们在接近立方体形状的单元上得到缓慢的收敛，在这种情况下，所有的长度几乎都是一样的。然而，这种缓慢的收敛意味着结果将位于两个最大的奇异值之间，而这两个奇异值无论如何都是接近最大值的。在所有其他情况下，收敛将是快速的。因此，我们可以在这里仅仅硬编码5次迭代，并确信结果是好的。

[1.x.135] 



与前面的函数类似，我们必须确保只在一个单元格批的有效单元格上积累速度。

[1.x.136] 




[1.x.137] [1.x.138] 




这个类将EulerOperator类与时间积分器和通常的全局数据结构（如FiniteElement和DoFHandler）相结合，以实际运行Euler问题的模拟。   


成员变量是一个三角形、一个有限元、一个映射（用于创建高阶曲面，见[2.x.300]），以及一个描述自由度的DoFHandler。此外，我们还保留了上面描述的EulerOperator的一个实例，它将完成所有积分方面的繁重工作，以及一些时间积分的参数，如当前时间或时间步长。   


此外，我们使用一个PostProcessor实例来向输出文件写入一些额外的信息，这与 [2.x.301] 中的做法类似。DataPostprocessor类的接口很直观，要求我们提供关于需要评估的信息（通常只有解的值，除了Schlieren图，我们只在二维中启用它是有意义的），以及被评估的内容的名称。请注意，也可以通过可视化程序（如ParaView）中的计算器工具来提取大部分信息，但在写输出时就已经做了，这要方便得多。

[1.x.139] 



对于字段变量的主要评估，我们首先检查数组的长度是否等于预期值（长度`2*dim+4`或`2*dim+5`是由我们在下面的get_names()函数中指定的名字的大小得出）。然后我们在所有的评估点上循环，填充相应的信息。首先，我们填写密度[2.x.302]、动量[2.x.303]和能量[2.x.304]的原始解变量，然后计算得出速度[2.x.305]、压力[2.x.306]、声速[2.x.307]，以及显示[2.x.308]的Schlieren图，如果它被启用。参见[2.x.309]，了解另一个创建Schlieren图的例子）。

[1.x.140] 



对于量的解释，我们有标量密度、能量、压力、声速和Schlieren图，以及动量和速度的向量。

[1.x.141] 



关于必要的更新标志，我们只需要所有量的值，但Schlieren图除外，它是基于密度梯度的。

[1.x.142] 



这个类的构造函数并不令人惊讶。我们设置了一个基于 "MPI_COMM_WORLD "通信器的平行三角形，一个具有 "dim+2 "分量的密度、动量和能量的矢量有限元，一个与底层有限元相同程度的高阶映射，并将时间和时间步长初始化为零。

[1.x.143] 



作为一个网格，本教程程序实现了两个选项，取决于全局变量`testcase`。对于分析变量（`testcase==0`），域是[2.x.310]，域周围都有迪里希特边界条件（流入）。对于 "testcase==1"，我们将域设置为矩形框内的圆柱体，源自Sch&auml;fer和Turek(1996)对不可压缩的粘性流动的圆柱体的流动测试案例。在这里，我们有更多种类的边界。通道左侧的流入部分是给定的流入类型，为此我们选择了一个恒定的流入轮廓，而我们在右侧设置了一个亚声速的流出。对于圆柱体周围的边界（边界id等于2）以及通道壁（边界id等于3），我们使用壁的边界类型，即无正态流。此外，对于三维圆柱体，我们还在垂直方向上增加了一个重力。有了基础网格（包括由[2.x.311]设置的流形），我们就可以执行指定数量的全局细化，从DoFHandler中创建未知编号，并将DoFHandler和Mapping对象交给EulerOperator的初始化。

[1.x.144] 



在下文中，我们输出一些关于这个问题的统计数据。因为我们经常会出现相当多的单元格或自由度，所以我们希望用逗号来分隔每一组三位数来打印它们。这可以通过 "locales "来实现，尽管这种工作方式并不特别直观。 [2.x.312]对此有稍微详细的解释。

[1.x.145] 



对于输出，我们首先让欧拉算子计算出数值结果的误差。更确切地说，对于分析解的情况，我们计算与分析结果的误差，而对于第二个测试情况，我们计算与密度和能量恒定、速度恒定的背景场的偏差[2.x.313]方向的偏差。   


下一步是创建输出。这与[2.x.314]中的做法类似：我们让上面定义的后处理器控制大部分的输出，除了我们直接写的原始场。对于分析解的测试案例，我们还对分析解进行了另一次投影，并打印出该场和数值解之间的差异。一旦我们定义了所有要写的量，我们就建立输出的补丁。与[2.x.315]类似，我们通过设置适当的标志来创建一个高阶VTK输出，这使我们能够可视化高多项式度的场。最后，我们调用[2.x.316]函数，将结果写入给定的文件名。这个函数使用了特殊的MPI并行写设施，与其他大多数教程程序中使用的标准库的[2.x.317]变体相比，它通常对并行文件系统更加优化。`write_vtu_in_parallel()`函数的一个特别好的特点是，它可以将所有MPI行列的输出合并到一个文件中，使得没有必要有一个所有此类文件的中央记录（即 "pvtu "文件）。   


对于并行程序来说，看一下单元格在处理器之间的划分往往是有启发的。为此，我们可以向[2.x.318]传递一个数字向量，其中包含与当前处理器拥有的活动单元一样多的条目；然后这些数字应该是拥有这些单元的处理器的等级。例如，这样一个向量可以从[2.x.319]中获得。另一方面，在每个MPI进程中，DataOut将只读取那些对应于本地拥有的单元的条目，这些条目当然都有相同的值：即当前进程的等级。矢量的其余条目中的内容实际上并不重要，因此我们可以用一个廉价的技巧逃脱。我们只是把我们给[2.x.320]的向量的**值都填上当前MPI进程的等级。关键是在每个进程中，只有对应于本地拥有的单元格的条目会被读取，而忽略其他条目中的（错误的）值。事实上，每个进程提交的向量中，正确的条目子集是正确的，这就足够了。

[1.x.146] 



[2.x.321]函数将所有的碎片放在一起。它首先调用创建网格和设置数据结构的函数，然后初始化时间积分器和低存储积分器的两个临时向量。我们称这些向量为`rk_register_1`和`rk_register_2`，并使用第一个向量表示[2.x.322]，第二个向量表示[2.x.323]，在介绍中概述的Runge-Kutta方案的公式中。在我们开始时间循环之前，我们通过[2.x.324]函数计算时间步长。为了便于比较，我们将那里得到的结果与最小网格尺寸进行比较，并将它们打印到屏幕上。对于像本教程程序中的声速和速度接近统一的情况，预测的有效网格大小将是接近的，但如果缩放比例不同，它们可能会有所不同。

[1.x.147] 



现在我们准备开始时间循环，我们一直运行到时间达到预期的结束时间。每隔5个时间步长，我们就计算一个新的时间步长估计值--由于解决方案是非线性的，在模拟过程中调整这个值是最有效的。如果Courant数选择得过于激进，模拟通常会在时间步数为NaN时爆炸，所以在这里很容易发现。有一点需要注意的是，由于不同的时间步长选择的相互作用，四舍五入的误差可能会传播到前几位数，从而导致略有不同的解决方案。为了降低这种敏感性，通常的做法是将时间步长四舍五入或截断到几位数，例如在这种情况下是3。如果当前时间接近规定的输出 "刻度 "值（如0.02），我们也会写出输出。在时间循环结束后，我们通过打印一些统计数据来总结计算，这主要由[2.x.325]函数完成。

[1.x.148] 



main()函数并不令人惊讶，它遵循了以前所有MPI程序中的做法。当我们运行一个MPI程序时，我们需要调用`MPI_Init()`和`MPI_Finalize()`，我们通过[2.x.326]数据结构来完成。注意，我们只用MPI来运行程序，并将线程数设置为1。

[1.x.149] 

[1.x.150][1.x.151] 。


[1.x.152][1.x.153]。


在一台有40个进程的机器上以默认设置运行程序，会产生以下输出。

[1.x.154] 



程序输出显示，所有的错误都很小。这是由于我们使用了一个相对较细的[2.x.327]单元的网格，并使用5度的多项式来求得一个平滑的解决方案。一个有趣的模式显示在时间步长上：虽然在时间5之前是0.0069，但在后来的时间里增加到0.0096。在时间5和6.5之间，一旦在声速之上有一些运动的旋涡（因此传播速度更快）离开计算域，步长就会增加。在这之后，气流只是在同一方向上是均匀的，与之前均匀速度被漩涡覆盖的状态相比，气体的最大速度有所下降。我们的时间步长公式认识到了这种影响。

最后一个输出块显示了关于程序各个部分时间的详细信息；它通过显示最快和最慢的处理器所花费的时间以及平均时间来细分--这在非常大的计算中通常很有用，可以发现是否有处理器持续过热（并因此节制其时钟速度）或由于其他原因持续过慢。总结显示，在1.02秒内完成了1283个时间步骤（看所有MPI进程的平均时间），而11个文件的输出又花了0.96秒。将每个时间步骤分解成五个Runge--Kutta阶段，每次评估的计算时间为0.16毫秒。这种高性能是无矩阵评估器的典型表现，也是显式时间积分对隐式求解器非常有竞争力的原因，特别是对于大规模模拟。程序运行结束时的计算时间细分显示，[2.x.328]中的积分评估贡献了大约0.92秒，反质量矩阵的应用贡献了0.06秒。此外，对时间步长计算的运输速度的估计又贡献了0.05秒的计算时间。

如果我们再使用三个级别的全局细化和总共940万个DoF，最终的统计数据如下（对于修改后的Lax--Friedrichs通量，[2.x.329] ，和同一系统的40个核心的双插槽Intel Xeon Gold 6230）。

[1.x.155] 



每个时间步长，求解器现在需要0.02秒，大约是147k未知数的小问题的25倍。鉴于该问题涉及64倍的未知数，计算时间的增加并不令人惊讶。由于我们也做了8倍的时间步数，计算时间在理论上应该增加512倍。实际增加的时间是205秒/1.02秒=202。这是因为由于通信开销的原因，小问题的规模不能充分利用40个核心。如果我们研究一下每个时间步长所做操作的细节，这一点就很清楚了。带有近邻通信的微分算子[2.x.330]的评估从0.92秒到127秒，也就是说，它增加了138倍。另一方面，应用反质量矩阵和向量更新的成本，完全不需要在MPI进程之间通信，增加了1195倍。这一增长超过了理论上的512倍，因为对于较大的尺寸，操作受限于RAM内存的带宽，而对于较小的尺寸，所有的矢量都适合于CPU的缓存。数字显示，尽管使用了低存储量的Runge-Kutta积分器和合并矢量操作，但质量矩阵评估和矢量更新部分几乎消耗了Runge-Kutta阶段所花费的40%的时间。而且尽管对[2.x.331]算子使用了过度积分。对于更简单的微分算子和更昂贵的时间积分器，花费在质量矩阵和矢量更新部分的比例也可以达到70%。如果我们以每秒处理的DoFs和Runge--Kutta阶段计算一个吞吐量数字，我们得到[1.x.156]这个吞吐量数字非常高，因为简单地将一个向量复制到另一个向量的运行速度只有大约10,000 MDoFs/s。

如果我们进入下一个更大的规模，有3770万个DoFs，整个模拟时间为2196秒，其中1978秒用于时间步进。L_h算子的运行时间增加了9.3倍（1179秒对127秒），反质量矩阵和向量更新增加了10.3倍（797对77.5秒）。运行时间非最佳增长的原因可以追溯到给定硬件上的缓存效应（有40MB的二级缓存和55MB的三级缓存）。虽然不是所有的相关数据都适合940万DoF的缓存（一个向量需要75MB，我们有三个向量加上MatrixFree中的一些额外数据），但还是有能力满足一个半向量的需求。考虑到现代的缓存比天真的最近使用的策略更复杂（在这种情况下，我们几乎没有重复使用，因为数据是以类似流的方式使用的），我们可以假设，在940万DoFs的情况下，确实有相当一部分数据可以从缓存中交付。对于更大的情况，即使有最佳的缓存，也只有不到10%的数据可以放入缓存中，而且会有相关的性能损失。


[1.x.157][1.x.158] 。


对于修改后的Lax--Friedrichs通量和测量动量变量的误差，我们得到以下收敛表（密度和能量变量的速率非常相似）。

 [2.x.332]  

如果我们改用Harten-Lax-van Leer通量，结果如下。 [2.x.333]  

表中显示，我们对两种数值通量都得到了最佳的[2.x.334]收敛率。对于[2.x.335]，Lax--Friedrichs通量的误差略小，但对于[2.x.336]，情况则相反；无论如何，这个测试案例的差异相对较小。

对于[2.x.337]，我们在最细的网格上用两种通量达到了[2.x.338]的舍入精度。还要注意的是，误差是绝对的，域长为[2.x.339]，所以相对误差低于[2.x.340]。HLL通量在最高度数上要好一些，这是由于Lax--Friedrichs通量的轻微不准确造成的。Lax--Friedrichs通量对离开域的解设置了一个Dirichlet条件，这导致了一个小的人工反射，这在Lax--Friedrichs通量中被强调了。除此之外，我们看到数值通量的影响很小，因为元素内部的多项式部分是引起反射的主要动力。当试图用高阶DG设置来接近更具挑战性的设置时，通量的有限影响也会产生影响。以[2.x.341]的参数和网格为例，一旦高质部分接近边界，我们就会在两种通量下得到振荡（这反过来会使密度为负值，并使解决方案爆炸），这与低阶有限体积的情况不同（[2.x.342]）。因此，任何导致溶液中出现冲击的情况都需要某种形式的限制性或人工耗散。对于另一种选择，见[2.x.343]的教程程序。


[1.x.165][1.x.166] 


对于通道中圆柱体周围流动的测试案例，我们需要将第一行代码改为 

[1.x.167] 

这个测试案例从马赫数为0.31的恒定速度和恒定的初始密度的背景场开始；流动将不得不围绕一个圆柱体形式的障碍物。由于我们在圆柱体壁上施加了一个无穿透条件，最初正面撞击到圆柱体上的气流必须重新排列，这就产生了一个大的音波。下面的图片显示了二维情况下5级全局细化时0.1、0.25、0.5和1.0（左上至右下）的压力，使用了102,400个单元，多项式程度为5，所有4个求解变量的自由度为1470万。我们清楚地看到，在时间0.1的第一个快照中，不连续现象在上游方向传播缓慢，在下游方向传播较快。在时间0.25，声波已经到达顶部和底部的墙壁并反射到内部。从下壁和上壁反射波的不同距离，我们可以看到以[2.x.344]为代表的Sch&auml;fer-Turek试验案例的轻微不对称性，圆柱体上方的空间与下方相比要大一些。在后来的时间里，画面更加混乱，到处都是许多声波。

 [2.x.345]  

下一张图片显示了在时间1.0时，以相同的分辨率从通道入口看向出口的压力仰角图--在这里，我们可以看到大量的反射。在该图中，可以看到两种类型的波。较大振幅的波对应于初始不连续物撞击墙壁时发生的各种反射，而与元素大小相似的小振幅波则对应于数值伪影。它们起源于方案的有限分辨率，并在不连续面通过高阶多项式的元素时出现。这种效应可以通过提高分辨率来治愈。除了这种效应外，丰富的波浪结构是高阶DG方法的传输精度的结果。

 [2.x.346]  

在对1600个单元进行2级全局细化的情况下，40个MPI进程上的网格及其划分情况如下。

 [2.x.347]  

当我们在40个核心上运行具有4级全局细化的代码时，我们得到如下输出。

[1.x.168] 



这里显示的各种量的规范是对背景场（即初始条件）的偏差[2.x.348]、[2.x.349]和[2.x.350]。运行时间的分布总体上与之前的测试案例相似。唯一略有不同的是，与反质量矩阵和矢量更新相比，[2.x.351]花费的时间比例较大。这是因为几何体是变形的，无矩阵框架需要从内存中为几何体加载额外的数组，这些数组在仿生网格的情况下是被压缩的。

将全局细化的数量增加到5，输出变为。

[1.x.169] 



对性能的影响与分析性测试案例相似--理论上，计算时间应该增加8倍，但实际上我们看到时间步骤增加了11倍（219.5秒对2450秒）。这可以追溯到缓存，小的情况下大多适合缓存。一个有趣的效果，典型的具有一些负载不平衡的本地通信（积分[2.x.352]）和全局通信（计算运输速度）混合的程序，可以通过查看分别遇到不同阶段的最小和最大时间的MPI等级来观察。级别0报告了 "rk时间步进总数 "部分的最快吞吐量。同时，对于 "计算传输速度 "部分，它似乎是最慢的，几乎比平均水平慢了2倍，与较快的等级相比几乎是4倍。由于后者涉及到全局通信，我们可以将这部分的缓慢归因于本地Runge--Kutta阶段在这个等级上推进得更快，需要等到其他处理器跟上。在这一点上，人们可以怀疑这种不平衡的原因。在所有的MPI进程中，单元格的数量几乎是相同的。然而，无矩阵框架在位于通道出口处的仿生和笛卡尔单元上速度更快，较低的MPI等级被分配到这些单元。另一方面，报告Runga--Kutta阶段最高运行时间的等级32拥有靠近圆柱体的弯曲单元，对于这些单元不可能有数据压缩。为了提高吞吐量，我们可以在划分[2.x.353]对象时给不同的单元类型分配不同的权重，甚至可以测量几个时间步骤的运行时间并尝试重新平衡。

对于1470万DoFs的测试案例，在346000个Runge--Kutta阶段中，每个Runge--Kutta阶段的吞吐量可以计算到2085 MDoFs/s，比上面报告的2360 MDoFs/s的笛卡尔网格吞吐量稍慢一些。

最后，如果我们增加一个额外的细化，我们记录了以下输出。

[1.x.170] 



rk时间步进总数 "部分对应的是2010 MDoFs/s的吞吐量。执行139k时间步长的总体运行时间为20k秒（5.7小时），即每秒7个时间步长--对于有近6000万个未知数来说，这还不算太坏。更多的吞吐量可以通过增加计算的核心来实现。


[1.x.171][1.x.172] 


将通道测试案例切换到3D，并进行3次全局细化，其输出结果是 

[1.x.173] 



物理现象与二维案例相似，由于引力的作用，在z方向上有轻微的运动。这种情况下每个Runge--Kutta阶段的吞吐量为[1.x.174] 。

由于[2.x.354]项的计算比较昂贵，所以吞吐量比二维情况下低。这是由于 "度+2 "点的过度积分和更大比例的面积分（更差的体积-表面比率）与更昂贵的通量计算。如果我们只考虑反质量矩阵和矢量更新部分，我们记录到等熵涡旋的二维案例的吞吐量为4857 MDoFs/s，有3770万个未知数，而三维案例的运行速度为4535 MDoFs/s。性能是相似的，因为这两种情况实际上都受到内存带宽的限制。

如果我们进行四级全局细化，我们需要增加进程的数量，以适应内存中的所有内容--在这种情况下，计算需要大约350GB的RAM内存。另外，通过增加额外的资源，完成35k个时间步骤所需的时间也变得更容易忍受。因此，我们使用了6个节点，每个节点有40个核心，从而使计算有240个MPI进程。

[1.x.175] 

这个模拟有近20亿个未知数--确实是一个相当大的计算，但每个时间步长仍然只需要大约1.5秒。


[1.x.176][1.x.177] 。


这里介绍的代码可以直接扩展到自适应网格，给定适当的指标来设置细化标志。在声波方程的背景下，类似求解器的大规模自适应性已经由[1.x.178]实现。然而，在目前的情况下，自适应性的好处往往只限于靠近声波起源的早期时间和效果，因为波最终会反射和衍射。这导致了到处都是陡峭的梯度，类似于湍流，以及或多或少的全局细化网格。

另一个我们在结果部分没有讨论的主题是不同时间积分方案的比较。该程序提供了四种低存储Runga--Kutta积分器的变体，每一种都有略微不同的精度和稳定性行为。在这里实现的方案中，高阶方案提供了额外的精度，但在违反CFL条件之前，每级步长的效率略低。一个有趣的扩展是将这里提出的低存储变体与标准的Runge--Kutta积分器进行比较，或者使用与质量矩阵运算分开运行的矢量运算，并比较性能。


[1.x.179][1.x.180] 


正如介绍中所提到的，本程序中采用的修正的Lax--Friedrichs通量和HLL通量只是欧拉方程文献中大量数值通量中的两种变体。一个例子是HLLC通量（Harten-Lax-van Leer-Contact）通量，它增加了HLL通量或Roe通量中缺少的稀疏波效应。正如介绍中提到的，数值通量对高阶DG方案的影响是有争议的（与低阶离散的情况不同）。

为了提高求解器的稳定性，一个相关的改进是也要考虑空间积分项。上面使用的相当幼稚的实现方式的一个缺点是，原始欧拉方程的能量守恒（在没有冲击的情况下）只在离散误差范围内有效。如果解决方案的分辨率不足，离散化误差会引起数值能量的增加，并最终导致离散化的不稳定。这是因为欧拉方程中的项的不精确的数值积分，其中包含有理非线性和来自弯曲单元的高阶内容。摆脱这种困境的方法是所谓的倾斜对称公式，见[2.x.355]的一个简单变体。倾斜对称意味着在弱式中切换解[2.x.356]和检验函数[2.x.357]的作用，除了一些边界项外，产生原始量的精确负值。在离散设置中，挑战在于当积分只被近似计算时也要保持这种倾斜对称性（在连续情况下，倾斜对称性是部分积分的结果）。偏斜对称的数值方案平衡了保守形式的空间导数 [2.x.358] 和对流形式的贡献 [2.x.359] ，对于某些 [2.x.360] 。准确的条款取决于方程和积分公式，在某些情况下，可以通过特殊的倾斜对称有限差分方案来理解。

要想入门，感兴趣的读者可以看一下https://github.com/kronbichler/advection_miniapp，那里用deal.II实现了一个简单的平流方程的斜对称DG公式。

[1.x.181][1.x.182] 。


正如介绍中提到的，随着马赫数的增加，欧拉方程的解会产生冲击，这就需要额外的机制来稳定方案，例如以限制器的形式。除了实际实施限制器或人工粘性方法外，主要的挑战是如何平衡计算，因为在有问题的单元中限制震荡所涉及的额外计算会使它们比没有限制的普通DG单元更昂贵。此外，更好地应对不连续情况的额外数值通量也是一种选择。

对于超音速流动来说，一个必要的因素是适当的边界条件。与引言中讨论的并在程序中实现的亚音速流出边界不同，超音速流出边界的所有特征都是流出的，所以我们不想规定任何外部数据，[1.x.183] 。

在代码中，我们将简单地添加额外的语句 

[1.x.184] 

在 "local_apply_boundary_face() "函数中。

[1.x.185][1.x.186] 。


当对欧拉解的兴趣主要在于声波的传播时，围绕一个背景状态，即一个给定的密度、速度和能量（或压力）场，将欧拉方程线性化，并只计算对这些场的变化，往往是有意义的。这就是航空声学的广泛领域的设置。即使有时分辨率要求大大降低，但由于线性化引起了额外的条款，实施起来就变得有些复杂了。从代码的角度来看，在算子评估中，我们还需要为代码配备要线性化的状态。这一信息可以由分析函数（根据正交点的位置进行评估）或由类似于解决方案的矢量提供。基于该矢量，我们将创建一个额外的FEEvaluation对象，从中读取并提供正交点的场值。如果背景速度为零，密度为常数，线性化的欧拉方程就会进一步简化，可以等效地写成声波方程的形式。

在声音传播的背景下，一个挑战往往是边界条件的定义，因为计算域需要是有限的，而实际模拟往往跨越无限的（或至少是大得多的）物理域。传统的Dirichlet或Neumann边界条件会引起声波的反射，最终传播到感兴趣的区域，破坏了解决方案。因此，各种非反射边界条件或海绵层的变体，通常以[1.x.187]的形式出现--其中解决方案是无反射阻尼的 

-- 的形式，是很常见的。


[1.x.188][1.x.189] 。


如[2.x.361]所述，本教程程序中提出的求解器也可以通过添加粘性项扩展到可压缩的Navier-Stokes方程。为了尽量保持这里获得的性能，尽管有额外的椭圆项的成本，例如通过内部惩罚方法，可以像[2.x.362]教程程序中那样将基础从FE_DGQ转换为FE_DGQHermite。[1.x.190] [1.x.191] [2.x.363]。 

 [2.x.364] 
