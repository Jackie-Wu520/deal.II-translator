 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22 ][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43] 

 [2.x.3]  

[1.x.44] 


[1.x.45][1.x.46] [1.x.47] 


多孔介质中的多相流模拟是一个无处不在的问题，我们以前在 [2.x.4] 和 [2.x.5] 中已经以某种形式解决了这个问题。然而，正如在那里很容易看到的那样，它面临两个主要困难：数值精度和效率。第一个困难在静止求解器[2.x.6]中很容易看到：使用最低阶的Raviart-Thomas元素不可能产生高度精确的解。我们需要更精确的方法。第二个原因从时间依赖性[2.x.7]中可以看出：该程序慢得令人发指，没有希望在合理的时间范围内得到高度精确的三维解。

在这个程序中，为了克服这两个问题，有五个方面我们正在努力改进，以获得高性能的模拟器。

 2.x.8] [2.x.9] 高阶空间离散 [2.x.10] 自适应网格细化 [2.x.11] 自适应时间步进 [2.x.12] 运算器分离 [2.x.13] 高效求解器和预处理 [2.x.14  

本程序的大部分灵感来自于[2.x.15]，但这里讨论的几个技术是原创的。


[1.x.48][1.x.49] 


我们考虑的是两相不混杂、不可压缩的流体的流动。毛细管和重力效应被忽略，而粘性效应被假定为主导。这种流动的管理方程与[2.x.16]中使用的方程相同，为 

[1.x.50] 

其中[2.x.17]是第二（润湿）相的饱和度（体积分数在0和1之间），[2.x.18]是压力，[2.x.19]是渗透性张量，[2.x.20]是总流动性，[2.x.21]是孔隙率，[2.x.22]是润湿相的分流量，[2.x.23]是源项，[2.x.24]是总速度。总流动性、润湿相的分流量和总速度分别由以下公式给出 

[1.x.51] 

其中下标[2.x.25]分别代表湿润相和非湿润相。

为方便起见，饱和度方程中的孔隙度[2.x.26]可视为时间变量的比例因子，被设定为1。根据相对渗透率[2.x.27]和[2.x.28]对饱和度的依赖性的常用处方，我们使用 

[1.x.52] 



上面的多孔介质方程由饱和度的初始条件和压力的边界条件来增加。由于饱和度和压力梯度唯一地决定了速度，所以速度的边界条件是没有必要的。由于流动方程不包含时间导数，因此不需要速度和压力变量的初始条件。流场将边界分为流入或流出部分。具体来说，[1.x.53]，我们通过在流入边界上也强加饱和度变量的边界值，得出一个完整的模型[2.x.29] 。


[1.x.54][1.x.55] 。


正如在[2.x.30]中所看到的，一旦我们知道了流动变量，解决速度和压力的流动方程是程序中花费时间远大于饱和度变量的（显式）更新步骤的部分。另一方面，压力和速度对饱和度的依赖性很弱，因此可以考虑每隔几步只求解压力和速度，而每步都更新饱和度。如果我们能找到一个关于何时需要更新流动变量的标准，我们就把这种拆分称为 "自适应算子拆分 "方案。

在这里，我们使用以下后验标准来决定何时重新计算压力和速度变量（详细的推导和描述可以在[Chueh, Djilali and Bangerth 2011]中找到）。

[1.x.56] 

其中括号内的上标表示定义任何数量的饱和时间步数，[2.x.31]表示我们实际计算压力和速度的最后一步。如果[2.x.32]超过某个阈值，我们就重新计算流量变量；否则，我们在时间步骤[2.x.33]中跳过这个计算，只将饱和变量向前移动一个时间步骤。

简而言之，该算法允许我们执行若干长度为[2.x.34]的饱和时间步长，直到上述标准告诉我们重新计算速度和压力变量，导致一个长度为[1.x.57]的宏观时间步长。 ] 我们根据准则[1.x.58]选择受Courant-Friedrichs-Lewy(CFL)限制的(微观)步长，我们已经证实，对于下面讨论的饱和方程的有限元和时间步长方案的选择是稳定的([2.x.35]表示单元[2.x.36]的直径) 。其结果是一个方案，微观和宏观的时间步长都不统一，两者都是自适应选择。

[1.x.59][1.x.60] 

利用这种时间离散化，我们可以从IMPES方法中得到以下每个时间步长的方程组（见[2.x.37] ）。

[1.x.61] 




利用[2.x.38]这一事实，时间离散的饱和度方程变为 

[1.x.62] 



[1.x.63][1.x.64] 。


通过将定义总速度的方程[2.x.39]和以源项表示其发散的方程分别与测试函数[2.x.40]和[2.x.41]相乘，然后根据需要进行分项积分，问题的弱形式为。找到[2.x.42]，以便对所有测试函数[2.x.43]而言，存在[1.x.65] 。

这里，[2.x.44]代表[2.x.45]的单位外向法向量，压力[2.x.46]可以在边界的开放部分[2.x.47]弱化规定，而在那些规定了速度的部分（例如具有[2.x.48]的不透水边界），该术语完全消失，因为[2.x.49] 。

我们使用连续有限元来离散速度和压力方程。具体来说，我们使用混合有限元来确保同时对矢量变量（如流体速度）和标量变量（如压力）进行高阶逼近。对于鞍点问题，公认的是需要满足所谓的Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件[Brezzi 1991, Chen 2005]以确保压力-速度系统的稳定性。在本工作中，通过使用比压力高一阶的速度元素来满足这些稳定性条件，即[2.x.50]和[2.x.51] ，其中[2.x.52]，[2.x.53]是空间维度，[2.x.54]表示每个变量的张量积Lagrange多项式的空间[2.x.55] 。

[1.x.66][1.x.67] 。

为饱和方程选择的[2.x.56]元素在没有上卷或其他类型的稳定化的情况下不会导致稳定的离散化，并且在数值解中会出现虚假的震荡。添加一个人工扩散项是消除这些振荡的一种方法[Chen 2005]。另一方面，添加过多的扩散项会在解中涂抹尖锐的锋面，并且会有网格定位的困难[Chen 2005]。为了避免这些影响，我们使用了由[Guermond and Pasquetti 2008]提出并在[Chueh, Djilali, Bangerth 2011]和[Kronbichler, Heister and Bangerth, 2011]以及[2.x.57]中验证的人工扩散项。

这种方法将饱和方程的（离散）弱形式修改为 

[1.x.68] 

其中[2.x.58]是人工扩散参数，[2.x.59]是在域的边界上适当选择的数值通量（我们为此选择明显的全上风通量）。

按照[Guermond and Pasquetti 2008]（以及[Chueh, Djilali and Bangerth 2011]中的详细说明），我们将该参数作为一个片状常数函数设置在每个单元[2.x.60]上，直径[2.x.61]为[1.x.69]，其中[2.x.62]为稳定指数，[2.x.63]为用户定义的无维稳定常数。按照[Guermond and Pasquetti 2008]以及[2.x.64]中的实现，速度和饱和度全局归一化常数[2.x.65]以及残差[2.x.66]分别由[1.x.70 ]和[1.x.71]，其中[2.x.67]是用户定义的第二个无维常数，[2.x.68]是域的直径，[2.x.69]是整个计算域中目前饱和度的范围[2.x.70]。

这种稳定方案与更简单的方案相比有很多优势，如有限体积（或不连续Galerkin）方法或流线型上风Petrov Galerkin（SUPG）离散。特别是，人工扩散项主要作用于不连续点附近，因为在饱和度平稳的地区，残差很小。因此，它提供了一个更高的精度。另一方面，它是非线性的，因为 [2.x.71] 取决于饱和度 [2.x.72] 。我们通过明确地处理所有的非线性项来避免这一困难，这导致了以下在时间步长[2.x.73]的完全离散问题。

[1.x.72] 

其中[2.x.74]是从[2.x.75]和[2.x.76]线性外推到当前时间的速度[2.x.77]，如果[2.x.78]，而[2.x.79]是[2.x.80]如果[2.x.81] 。因此，该方程在[2.x.82]中是线性的，所需要的是用饱和空间上的质量矩阵来解决。

由于饱和度的Dirichlet边界条件只施加在流入边界上，上述方程左边的第三个项需要进一步分成两部分。

[1.x.73] 

其中[2.x.83]和[2.x.84]分别代表流入和流出的边界。我们使用上风公式选择数值，即[2.x.85]和[2.x.86]对应于从现在的单元取值，而[2.x.87]和[2.x.88]的数值是从邻近边界[2.x.89]取值。


[1.x.74][1.x.75] 。


自适应地选择网格以解决尖锐的饱和前沿是我们算法中实现效率的一个基本要素。在这里，我们使用[Chueh, Djilali and Bangerth 2011]中使用的相同的冲击型细化方法来选择那些应该被细化或粗化的单元。三角形的每个单元[2.x.90]的细化指标由[1.x.76]计算，其中[2.x.91]是在单元[2.x.93]中心评估的离散饱和变量的梯度。这种方法类似于可压缩流动问题中经常使用的方法，其中密度梯度被用来表示细化。也就是说，正如我们将在[1.x.77]的结尾处讨论的那样，这被证明不是一个非常有用的标准，因为它基本上到处都导致细化。我们在这里只是为了说明问题而展示它。


[1.x.78][1.x.79] 。


按照上面讨论的治理方程的离散化，我们得到一个时间步长[2.x.94]的线性方程组，形式如下。[1.x.80] 其中各个矩阵和向量的定义如下：速度用形状函数[2.x.95]，压力和饱和度用[2.x.96]。

[1.x.81] 

和[2.x.97]，如稳定传输方程的定义中给出的。

如果我们把左上角的[2.x.98]板块的矩阵视为一个板块，则上述线性系统为块状三角形形式。因此，我们可以首先求解速度和压力（除非我们决定用[2.x.99]代替速度），然后再求解饱和度变量。其中第一个步骤要求我们求解[1.x.82]，我们对这个线性系统应用广义最小残差（GMRES）方法[Saad和Schultz 1986]。速度-压力系统的理想先决条件是 

[1.x.83] 

其中[2.x.100]是该系统的Schur补码[Zhang 2005]。这个预处理程序是最佳的，因为 

[1.x.84] 

对其而言，可以证明GMRES在两次迭代中收敛。

然而，我们当然不能指望使用速度质量矩阵和Schur补数的精确求逆。因此，我们遵循[Silvester and Wathen 1994]最初为斯托克斯系统提出的方法。将其适用于当前的方程组，得到预处理程序 

[1.x.85] 

其中，斜线表示精确反矩阵的近似值。特别是，由于[2.x.101]是一个稀疏的对称和正定矩阵，我们为[2.x.102]选择了这个矩阵的稀疏不完全Cholesky分解的单一应用[Golub和Van Loan 1996]。我们注意到，对应于非混合形式的多孔介质流动算子的舒尔补，[2.x.103]和[2.x.104]应该是实际舒尔补矩阵的良好近似[2.x.105] 。由于这两个矩阵又都是对称和正定的，我们用[2.x.106]的不完全Cholesky分解来表示[2.x.107]。需要注意的是，[2.x.108]需要用迪里希特边界条件建立，以确保其可逆性。

一旦有了速度[2.x.109]，我们就可以把[2.x.110]和[2.x.111]组合起来，用以下方法解决饱和问题 

[1.x.86] 

其中质量矩阵[2.x.112]用共轭梯度法求解，再一次使用不完全的Cholesky分解作为预处理。

[1.x.87][1.x.88] 




 [2.x.113] 这里讨论的实现使用并扩展了这个库的[2.x.114]、[2.x.115]和[2.x.116]教程中的部分程序。特别是，如果你想了解它是如何工作的，请参考[2.x.117]对数学问题的讨论，以及[2.x.118]，大部分的实现都是来自于此。我们将不讨论已经在 [2.x.119] 中讨论过的实现的各个方面。

我们展示了一些两相流方程的数值结果，这些方程通过适当的初始条件和边界条件与两种不同的渗透率模型的选择相结合而增强。在所考虑的问题中，没有内部源项（ [2.x.120] ）。如上所述，定量的数值结果在[Chueh, Djilali and Bangerth 2011]中提出。

为了简单起见，我们选择了[2.x.121]，尽管所有的方法（以及我们的实现）在一般的非结构化网格上都应该同样工作。

初始条件只需要饱和变量，我们选择[2.x.122]，即多孔介质最初由非湿润（80%）和湿润（20%）相的混合物填充。这与[2.x.123]中的初始条件不同，我们选择了[2.x.124]，但由于复杂的数学原因，在那里的长篇评论中提到，目前使用基于熵的人工扩散项的方法在不对方法进行额外修改的情况下，不能收敛到这个初始条件的粘度解。因此，我们为目前的方案选择了这个修改过的版本。

此外，我们在边界上规定了一个线性压力。1.x.89] 压力和饱和度唯一地决定了一个速度，而速度决定了一个边界段是流入还是流出的边界。在边界的流入部分，[2.x.125] ，我们规定 

[1.x.90] 

换句话说，该领域被来自左边的湿润相淹没。对于边界的流出部分，不需要饱和的边界条件。

所有用于二维/三维案例的数值和物理参数都列在下表中。

 [2.x.126]  


[1.x.91][1.x.92] 。




 [2.x.127] [2.x.128] CC Chueh, N Djilali and W Bangerth.  [2.x.129] 三维异质多孔介质中两相流的h-适应性算子分割方法。 [2.x.130] SIAM科学计算杂志，第35卷（2013），第B149-B175页 

 [2.x.131] M. Kronbichler, T. Heister, and W. Bangerth [2.x.132] 通过现代数值方法进行高精度地幔对流模拟。 [2.x.133] Geophysics Journal International, vol. 191 (2012), pp. 

 [2.x.134] F Brezzi and M Fortin.  [2.x.135] [1.x.93].  [2.x.136] Springer-Verlag, 1991. 

 [2.x.137] Z Chen.  [2.x.138] [1.x.94].  [2.x.139] Springer, 2005. 

 [2.x.140] JL Guermond和R Pasquetti.  [2.x.141] 基于熵的非线性黏度，用于守恒定律的傅里叶近似。 [2.x.142] [1.x.95], 346(13-14): 801-806, 2008. 

 [2.x.143] CC Chueh, M Secanell, W Bangerth, and N Djilali.  [2.x.144] 异质多孔介质中瞬态两相流的多级自适应模拟。 [2.x.145] [1.x.96], 39:1585-1596, 2010. 

 [2.x.146] Y Saad和MH Schultz.  [2.x.147] Gmres: 用于解决非对称线性系统的广义最小残差算法。 [2.x.148] [1.x.97], 7(3):856-869, 1986. 

 [2.x.149] F Zhang.  [2.x.150] [1.x.98].  [2.x.151] Springer, 2005. 

 [2.x.152] D Silvester and A Wathen.  [2.x.153] 稳定的斯托克斯系统的快速迭代求解第二部分：使用一般块状先决条件。 [2.x.154] [1.x.99], 31(5):1352-1367, 1994. 

 [2.x.155] GH Golub和CF van Loan.  [2.x.156] [1.x.100].  [2.x.157] 第三版，约翰霍普金斯大学，1996年。

 [2.x.158] SE Buckley和MC Leverett。 [2.x.159] 沙子中流体位移的机制。 [2.x.160] [1.x.101], 146:107-116, 1942。

 [2.x.161] [1.x.102] [1.x.103] 。


[1.x.104] [1.x.105]。




像往常一样，第一步是要包括一些deal.II和C++头文件的功能。




列表中包括一些提供向量、矩阵和预处理类的头文件，这些头文件实现了各自Trilinos类的接口；关于这些的一些更多信息可以在 [2.x.162] 中找到。

[1.x.106] 



在这个顶层设计的最后，我们为当前项目开辟一个命名空间，下面的所有材料都将进入这个命名空间，然后将所有deal.II的名字导入这个命名空间。

[1.x.107] 




[1.x.108] [1.x.109]。




下面的部分直接取自[2.x.163]，所以没有必要重复那里的描述。

[1.x.110] 




[1.x.111] [1.x.112]。




在本教程中，我们仍然使用先前在[2.x.164]中使用的两个渗透率模型，所以我们再次避免对它们进行详细评论。

[1.x.113] 




[1.x.114] [1.x.115]。




所有物理量的实现，如总流动性[2.x.165]和水的部分流量[2.x.166]都来自于[2.x.167]，所以我们再次对它们不做任何评论。与[2.x.168]相比，我们增加了检查，以确保传递给这些函数的饱和度实际上是在物理上的有效范围内。此外，鉴于润湿相以速度[2.x.169]移动，很明显[2.x.170]必须大于或等于零，所以我们也断言，以确保我们为得到导数的公式而进行的计算是有意义的。

[1.x.116] 




[1.x.117] [1.x.118]。




在这第一部分中，我们定义了一些我们在构建线性求解器和预处理器时需要的类。这一部分与 [2.x.171] 中使用的基本相同。唯一不同的是，原来的变量名称stokes_matrix被另一个名称darcy_matrix取代，以配合我们的问题。

[1.x.119] 




[1.x.120] [1.x.121] 。




定义解决随时间变化的平流主导的两相流问题（或Buckley-Leverett问题[Buckley 1942]）的顶层逻辑的类，主要基于教程程序[2.x.172]和[2.x.173]，特别是[2.x.174]，我们在那里使用的一般结构与这里基本相同。正如在[2.x.175]中，在下面的实现中需要注意的关键例程是[2.x.176]函数。   


与[2.x.177]的主要区别是，由于考虑了自适应算子拆分，我们需要多几个成员变量来保存最近两次计算的Darcy（速度/压力）解，以及当前的解（直接计算，或从前两次计算中推算），我们需要记住最近两次计算的Darcy解。我们还需要一个辅助函数来计算出我们是否确实需要重新计算达西解。   


与[2.x.178]不同，这一步多用了一个AffineConstraints对象，叫做darcy_preconditioner_constraints。这个约束对象仅用于为Darcy预处理程序组装矩阵，包括悬挂节点约束以及压力变量的Dirichlet边界值约束。我们需要这个，因为我们正在为压力建立一个拉普拉斯矩阵，作为舒尔补数的近似值），如果应用边界条件，这个矩阵是正定的。   


这样在这个类中声明的成员函数和变量的集合与[2.x.179]中的相当相似。

[1.x.122] 



接下来我们将介绍一些辅助函数，这些函数在整个程序中的许多地方都会用到。

[1.x.123] 



接下来是成员变量，其中大部分与[2.x.180]中的变量相似，但与速度/压力系统的宏观时间步长有关的变量除外。

[1.x.124] 



在最后，我们声明一个变量，表示材料模型。与[2.x.181]相比，我们在这里把它作为一个成员变量，因为我们想在不同的地方使用它，所以有一个声明这样一个变量的中心位置，将使我们更容易用另一个类来取代一个类（例如用[2.x.183]取代[2.x.182]）。 

[1.x.125] 




[1.x.126] [1.x.127]。




这个类的构造函数是 [2.x.184] 和 [2.x.185] 中构造函数的扩展。我们需要添加涉及饱和度的各种变量。正如介绍中所讨论的，我们将再次使用[2.x.186]（Taylor-Hood）元素来表示Darcy系统，这是一个满足Ladyzhenskaya-Babuska-Brezzi（LBB）条件的元素组合[Brezzi and Fortin 1991, Chen 2005]，以及[2.x.187]元素表示饱和度。然而，通过使用存储Darcy和温度有限元的多项式程度的变量，可以很容易地持续修改这些元素的程度以及在其上使用的所有正交公式的下游。此外，我们还初始化了与算子分割有关的时间步进变量，以及矩阵组装和预处理的选项。

[1.x.128] 




[1.x.129] [1.x.130]。




这个函数设置了我们这里的DoFHandler对象（一个用于Darcy部分，一个用于饱和部分），以及将本程序中线性代数所需的各种对象设置为合适的尺寸。其基本操作与[2.x.188]所做的类似。   


该函数的主体首先列举了达西和饱和系统的所有自由度。对于Darcy部分，自由度会被排序，以确保速度优先于压力DoF，这样我们就可以将Darcy矩阵划分为[2.x.189]矩阵。   


然后，我们需要将悬挂节点约束和迪里切特边界值约束纳入darcy_preconditioner_constraints。 边界条件约束只设置在压力分量上，因为对应于非混合形式的多孔介质流算子的Schur补码预处理[2.x.190]，只作用于压力变量。因此，我们使用一个过滤掉速度分量的组件_掩码，这样就可以只对压力自由度进行缩减。   


这样做之后，我们计算各个块中的自由度数量。然后，这些信息被用来创建达西和饱和系统矩阵的稀疏模式，以及用于建立达西预处理的预处理矩阵。如同在[2.x.191]中，我们选择使用DynamicSparsityPattern的封锁版本来创建模式。因此，对于这一点，我们遵循与[2.x.192]相同的方式，对于成员函数的其他部分，我们不必再重复描述。

[1.x.131] 




[1.x.132] [1.x.133]。




接下来的几个函数专门用来设置我们在这个程序中必须处理的各种系统和预处理矩阵及右手边。





[1.x.134] [1.x.135] 




这个函数组装我们用于预处理达西系统的矩阵。我们需要的是速度分量上由[2.x.193]加权的矢量质量矩阵和压力分量上由[2.x.194]加权的质量矩阵。我们首先生成一个适当阶数的正交对象，即FEValues对象，可以给出正交点的数值和梯度（连同正交权重）。接下来我们为单元格矩阵和局部与全局DoF之间的关系创建数据结构。向量phi_u和grad_phi_p将保存基函数的值，以便更快地建立局部矩阵，正如在 [2.x.195] 中已经做过的那样。在我们开始对所有活动单元进行循环之前，我们必须指定哪些成分是压力，哪些是速度。   


本地矩阵的建立相当简单。只有一个由[2.x.196]加权的项（关于速度）和一个由[2.x.197]加权的拉普拉斯矩阵需要生成，所以局部矩阵的创建基本上在两行完成。由于该文件顶部的材料模型函数只提供了渗透率和迁移率的倒数，我们必须根据给定的值手工计算[2.x.198]和[2.x.199]，每个正交点一次。   


一旦本地矩阵准备好了（在每个正交点上循环计算本地矩阵的行和列），我们就可以得到本地DoF指数，并将本地信息写入全局矩阵。我们通过直接应用约束条件（即darcy_preconditioner_constraints）来做到这一点，该约束条件负责处理悬挂节点和零Dirichlet边界条件约束。这样做，我们就不必事后再做，以后也不必使用[2.x.200]和[2.x.201]这两个需要修改矩阵和向量项的函数，因此对于我们不能立即访问单个内存位置的特里诺斯类来说，很难编写。

[1.x.136] 




[1.x.137][1.x.138] 。




在调用上述函数组装预处理矩阵后，该函数生成将用于Schur补块预处理的内部预处理。前置条件需要在每个饱和时间步长时再生，因为它们取决于随时间变化的饱和度[2.x.202]。   


在这里，我们设置了速度-速度矩阵[2.x.203]和Schur补码[2.x.204]的预处理器。正如介绍中所解释的，我们将使用一个基于矢量矩阵[2.x.205]的IC预处理器和另一个基于标量拉普拉斯矩阵[2.x.206]的IC预处理器（它在频谱上与达西矩阵的舒尔补码接近）。通常，[2.x.207]类可以被看作是一个很好的黑箱预处理程序，不需要对矩阵结构和/或背后的算子有任何特别的了解。

[1.x.139] 




[1.x.140] [1.x.141]。




这是为达西系统组装线性系统的函数。   


关于实现的技术细节，其程序与 [2.x.208] 和 [2.x.209] 中的程序相似。我们重置矩阵和向量，在单元格上创建正交公式，然后创建相应的FEValues对象。   


有一件事需要评论：由于我们有一个单独的有限元和DoFHandler来处理饱和问题，我们需要生成第二个FEValues对象来正确评估饱和解。要实现这一点并不复杂：只需使用饱和结构，并为基函数值设置一个更新标志，我们需要对饱和解进行评估。这里唯一需要记住的是，两个FEValues对象使用相同的正交公式，以确保我们在两个对象的正交点上循环时得到匹配的信息。   


申报过程中，对数组大小、本地矩阵的创建、右手边以及与全局系统相比的本地道夫指数的向量进行了一些捷径。

[1.x.142] 



接下来我们需要一个向量，它将包含前一个时间层次的饱和解在正交点的值，以组装达西方程中的饱和依赖系数。     


我们接下来创建的向量集包含了基函数的评价以及它们的梯度，将用于创建矩阵。把这些放到自己的数组中，而不是每次需要时都向FEValues对象询问这些信息，这是为了加速装配过程而进行的优化，详见[2.x.210]。     


最后两个声明是用来从整个FE系统中提取各个块（速度、压力、饱和度）的。

[1.x.143] 



现在开始对问题中的所有单元进行循环。我们在这个装配例程中使用了两个不同的DoFHandlers，所以我们必须为使用中的两个对象设置两个不同的单元格迭代器。这可能看起来有点奇怪，但由于达西系统和饱和系统都使用相同的网格，我们可以假设这两个迭代器在两个DoFHandler对象的单元格中同步运行。     


循环中的第一条语句也是非常熟悉的，按照更新标志的规定对有限元数据进行更新，将局部数组清零，并在正交点处获得旧解的值。 在这一点上，我们还必须在正交点上获得前一个时间步长的饱和函数的值。为此，我们可以使用[2.x.211]（之前已经在[2.x.212]、[2.x.213]和[2.x.214]中使用），这个函数接收一个解向量并返回当前单元的正交点的函数值列表。事实上，它返回每个正交点的完整矢量值解，即不仅是饱和度，还有速度和压力。     


然后我们就可以在单元的正交点上循环进行积分。这方面的公式在介绍中已经讨论过了，很简单。     


一旦完成，我们就开始在局部矩阵的行和列上进行循环，并向矩阵提供相关的产物。     


循环所有单元的最后一步是将本地贡献输入到全局矩阵和向量结构中，并在local_dof_indices中指定位置。同样，我们让AffineConstraints类将单元矩阵元素插入到全局矩阵中，这已经浓缩了悬挂的节点约束。

[1.x.144] 




[1.x.145][1.x.146] 。




这个函数是为了组装饱和传输方程的线性系统。如果有必要，它会调用另外两个成员函数：assemble_saturation_matrix()和assemble_saturation_rhs()。前一个函数然后组装饱和度矩阵，只需要偶尔改变。另一方面，组装右手边的后一个函数必须在每个饱和时间步长时调用。

[1.x.147] 




[1.x.148][1.x.149] 




这个函数很容易理解，因为它只通过基函数phi_i_s和phi_j_s为饱和线性系统的左手边形成一个简单的质量矩阵。最后，像往常一样，我们通过在local_dof_indices中指定位置将局部贡献输入全局矩阵。这是通过让AffineConstraints类将单元矩阵元素插入全局矩阵来完成的，它已经浓缩了悬挂的节点约束。

[1.x.150] 




[1.x.151][1.x.152] 




这个函数是为了组装饱和传输方程的右手边。在进行这项工作之前，我们必须为达西系统和饱和系统分别创建两个FEValues对象，此外，还要为这两个系统创建两个FEFaceValues对象，因为在饱和方程的弱形式中我们有一个边界积分项。对于饱和系统的FEFaceValues对象，我们还需要法向量，我们使用update_normal_vectors标志来申请。   


接下来，在对所有单元进行循环之前，我们必须计算一些参数（例如global_u_infty、global_S_variation和global_Omega_diameter），这是人工粘度[2.x.215]需要的。这与[2.x.216]中的做法基本相同，所以你可以在那里获得更多信息。   


真正的工作开始于对所有饱和和Darcy单元的循环，以便将局部贡献放到全局矢量中。在这个循环中，为了简化实现，我们把一些工作分成两个辅助函数：assemble_saturation_rhs_cell_term和assemble_saturation_rhs_boundary_term。 我们注意到，我们在这两个函数中把细胞或边界贡献插入全局向量，而不是在本函数中。

[1.x.153] 




[1.x.154][1.x.155] 。




这个函数负责整合饱和方程右侧的单元项，然后将其组装到全局右侧向量中。鉴于介绍中的讨论，这些贡献的形式很清楚。唯一棘手的部分是获得人工黏度和计算它所需的一切。该函数的前半部分专门用于这项任务。   


该函数的最后部分是将局部贡献复制到全局向量中，其位置由local_dof_indices指定。

[1.x.156] 




[1.x.157][1.x.158] 。




下一个函数负责饱和方程右侧形式中的边界积分项。 对于这些，我们必须计算全局边界面上的上行通量，也就是说，我们只对全局边界的流入部分弱加迪里切特边界条件。如前所述，这在[2.x.217]中已经描述过了，所以我们不对其进行更多的描述。

[1.x.159] 




[1.x.160] [1.x.161]。




该函数实现了算子分割算法，即在每个时间步长中，它要么重新计算达西系统的解，要么从以前的时间步长中推算出速度/压力，然后确定时间步长的大小，再更新饱和度变量。其实现主要遵循 [2.x.218] 中的类似代码。除了run()函数外，它是本程序中的核心函数。   


在函数的开始，我们询问是否要通过评估后验准则来解决压力-速度部分（见下面的函数）。如果有必要，我们将使用GMRES求解器与Schur补充块预处理来求解压力-速度部分，如介绍中所述。

[1.x.162] 



另一方面，如果我们已经决定不想计算当前时间步长的达西系统的解，那么我们需要简单地将前两个达西解外推到与我们计算速度/压力相同的时间。我们做一个简单的线性外推，即给定从上次计算达西解到现在的宏观时间步长[2.x.219]（由[2.x.220]给出），以及[2.x.221]上一个宏观时间步长（由[2.x.222]给出），然后我们得到[2.x.223]，其中[2.x.224]和[2.x.225]是最近两个计算的达西解。我们只用两行代码就可以实现这个公式。     


请注意，这里的算法只有在我们至少有两个先前计算的达西解，我们可以从中推断出当前的时间，这一点通过要求重新计算前两个时间步骤的达西解来保证。

[1.x.163] 



用这样计算出来的速度矢量，根据介绍中讨论的CFL标准计算出最佳时间步长...... 

[1.x.164] 



...然后在我们处理时间步长的时候也要更新我们使用的宏观时间步长。具体而言，这涉及到 (i) 如果我们刚刚重新计算了达西解，那么之前的宏观时间步长现在是固定的，当前的宏观时间步长，到现在为止，只是当前（微观）时间步长。(ii) 如果我们没有重新计算达西解，那么当前宏观时间步长只是增长了[2.x.226] 。

[1.x.165] 



这个函数的最后一步是根据我们刚刚得到的速度场重新计算饱和解。这自然发生在每一个时间步骤中，我们不会跳过这些计算。在计算饱和度的最后，我们投射回允许的区间[2.x.227]，以确保我们的解保持物理状态。

[1.x.166] 




[1.x.167] [1.x.168]。




下一个函数是对网格进行细化和粗化。它的工作分三块进行。(i) 计算细化指标，方法是通过使用各自的时间步长（如果这是第一个时间步长，则取唯一的解决方案），从前两个时间步长中线性推断出的解决方案向量的梯度。(ii) 在梯度大于或小于某一阈值的单元中标记出细化和粗化的单元，保留网格细化的最小和最大水平。(iii) 将解决方案从旧网格转移到新网格。这些都不是特别困难。

[1.x.169] 




[1.x.170] [1.x.171] 




这个函数生成图形输出。它本质上是对 [2.x.228] 中实现的复制。

[1.x.172] 




[1.x.173] [1.x.174] [1.x.174]。





[1.x.175] [1.x.176] 。




这个函数实现了自适应算子拆分的后验标准。考虑到我们在上面实现其他函数的方式，并考虑到论文中得出的准则公式，这个函数是相对简单的。   


如果我们决定要采用原始的IMPES方法，在每个时间步长中求解Darcy方程，那么可以通过将阈值[2.x.229]（默认为[2.x.230]）设置为零来实现，从而迫使该函数总是返回真。   


最后，请注意，该函数在前两个时间步骤中无条件地返回真，以确保我们在跳过达西系统的解时总是至少解了两次，从而允许我们从最后两个解中推算出速度 [2.x.231] 。

[1.x.177] 




[1.x.178] [1.x.179] 。




下一个函数只是确保饱和值始终保持在 [2.x.232] 的物理合理范围内。虽然连续方程保证了这一点，但离散方程并没有。然而，如果我们允许离散解逃脱这个范围，我们就会遇到麻烦，因为像[2.x.233]和[2.x.234]这样的项会产生不合理的结果（例如[2.x.235]为[2.x.236]，这将意味着润湿液相的流动方向为[1.x.180]））。因此，在每个时间步骤结束时，我们只需将饱和场投射回物理上合理的区域。

[1.x.181] 




[1.x.182] [1.x.183]    


另一个更简单的辅助函数。计算总速度乘以分数流函数的导数的最大值，即计算 [2.x.237] 。这个项既用于时间步长的计算，也用于人工黏度中的熵-残留项的归一化。

[1.x.184] 




[1.x.185] [1.x.186] 。   


为了计算稳定化项，我们需要知道饱和变量的范围。与[2.x.238]不同的是，这个范围很容易被区间[2.x.239]所约束，但我们可以通过在正交点的集合上循环，看看那里的值是什么，从而做得更好。如果可以的话，也就是说，如果周围至少有两个时间步长，我们甚至可以把这些值外推到下一个时间步长。   


和以前一样，这个函数是以最小的修改取自[2.x.240] 。

[1.x.187] 




[1.x.188] [1.x.189] 。   


最后的工具函数用于计算给定单元上的人工黏度。如果你面前有它的公式，这并不特别复杂，看一下 [2.x.241] 中的实现。与那个教程程序的主要区别是，这里的速度不是简单的[2.x.242]，而是[2.x.243]，一些公式需要做相应的调整。

[1.x.190] 




[1.x.191] [1.x.192]。




除了[2.x.244]之外，这个函数是这个程序的主要功能，因为它控制了迭代的时间，以及何时将解写入输出文件和何时进行网格细化。   


除了启动代码通过[2.x.245]标签循环回到函数的开头之外，一切都应该是相对简单的。无论如何，它模仿了 [2.x.246] 中的相应函数。

[1.x.193] 




[1.x.194][1.x.195] 。




主函数看起来与所有其他程序中的几乎一样。对于使用Trilinos的程序，需要初始化MPI子系统--即使是那些实际上没有并行运行的程序--在 [2.x.247] 中有解释。

[1.x.196] 



这个程序只能以串行方式运行。否则，抛出一个异常。

[1.x.197] 

[1.x.198][1.x.199] 




这个程序的输出与[2.x.248]的输出其实没有什么不同：毕竟它解决的是同一个问题。更重要的是定量指标，如解决方案的准确性以及计算所需的时间。这些在本页顶部列出的两份出版物中都有详细的记录，我们在此不再重复。

也就是说，没有几张好的图片，任何教程程序都是不完整的，所以这里有一些3D运行的输出。

 [2.x.249]  


[1.x.200] [1.x.201][1.x.202] 。


人们对这个程序的主要反对意见是它仍然太慢了：在合理的细网格上进行的三维计算实在是太昂贵了，不可能以合理的快速周转来进行常规计算。这与我们写[2.x.250]时的情况相似，这个程序从那里得到了很多启发。解决办法也是类似的，因为它也是在那里。我们需要以类似于从[2.x.252]中导出[2.x.251]的方式来并行化程序。事实上，[2.x.253]中使用的所有技术也可以转移到这个程序中，使程序立即在几十或几百个处理器上运行。

一个不同的方向是使该程序与许多其他多孔介质的应用更加相关。具体来说，一个途径是去找多孔介质流动模拟器的主要用户，即石油工业。在那里，该领域的应用以多相流（即超过我们这里的两相）为主，以及它们之间可能发生的反应（或任何其他相的质量交换方式，如通过溶解和从油相中冒出的气体）。此外，气体的存在往往会导致流体的可压缩性效应。这些效应通常共同组成了广泛使用的 "黑油模型"。在考虑储层中石油的控制性燃烧以提高压力和温度时，多相之间的真正反应也在油藏模型中发挥作用。不过，这些问题要复杂得多，留给未来的项目去解决。

最后，从数学的角度来看，我们已经得出了在给定时间步长重新计算速度/压力解的标准，其假设是我们想把在当前时间步长得到的解与我们上次实际解决这个系统时计算的解进行比较。然而，在程序中，每当我们没有重新计算解决方案时，我们并不只是使用之前计算的解决方案，而是从之前两次求解系统的结果中推算出来。因此，该标准被悲观地表述为：我们真正应该比较的是在当前时间步长得到的解与外推的解。在这方面重新阐述该定理被留作练习。

还有其他方法可以扩展这个程序的数学基础；例如，人们可以说我们关心的不是速度，而是事实上的饱和度。因此，人们可能会问，我们在这里用来决定[2.x.254]是否需要重新计算的标准是否合适；例如，人们可能会提出，决定一个错误的速度场是否（以及多少）事实上影响了饱和方程的解也很重要。这自然会导致敏感性分析。

从算法的角度来看，我们在这里使用了工程中经常使用的细化标准，即通过观察解的梯度。然而，如果你检查解决方案，你会发现它几乎在所有地方都迅速导致细化，甚至在明显没有必要的区域：因此经常使用并不需要暗示它是一个有用的标准开始。另一方面，用一个不同的、更好的标准来取代这个标准应该不是很困难。例如，许多其他程序中使用的KellyErrorEstimator类当然也应该适用于当前的问题。[1.x.203][1.x.204][2.x.255]  

 [2.x.256] 
