 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17 ][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34] 

 [2.x.3]  

[1.x.35] 

[1.x.36] [1.x.37][1.x.38]。


本方案涉及[1.x.39]。

[1.x.40] 

这个方程出现在薄结构的建模中，如体育场的屋顶。当然，这些物体在现实中是三维的，其横向范围与垂直厚度的长宽比很大，但人们通常可以通过对内力在垂直方向上的变化做出假设，将这些结构非常准确地建模为二维的。这些假设导致了上面的方程式。

该模型通常有两种不同的类型，取决于施加什么样的边界条件。第一种情况。

[1.x.41] 

对应于薄结构的边缘连接到高度为[2.x.4]的墙顶，这样作用在结构上的弯曲力为[2.x.5]；在大多数物理情况下，我们会有[2.x.6]，对应于结构只是坐在墙顶。

在边界值的第二种可能情况下，我们将有 

[1.x.42] 

这对应于一个 "夹紧 "的结构，非零的[2.x.7]意味着与水平面有一定的角度。

正如拉普拉斯方程的迪里切特和诺依曼边界条件一样，当然也可以在边界的一部分有一种边界条件，而在其余部分有另一种边界条件。


[1.x.43][1.x.44] 


该方程的基本问题是，它的解有四个导数。在我们在[2.x.8]、[2.x.9]和其他几个教程中处理的拉普拉斯方程的情况下，人们乘以一个检验函数，进行积分，通过部分积分，最后在检验函数和检验函数上都只有一个导数--对于全局连续的函数，人们可以做到这一点，但在单元之间的界面上可能有结点。导数可能不在界面上定义，但那是在一个较低维的流形上（所以不在积分值中显示出来）。

但是对于双调方程来说，如果按照同样的程序，在整个领域（即所有单元的联盟）上使用积分，最终会在测试函数和试验函数上各有两个导数。如果使用通常的片状多项式函数，并在单元格界面上有结点，那么第一个导数将产生一个不连续的梯度，第二个导数在界面上有delta函数--但由于测试函数和试验函数的第二个导数都产生一个delta函数，我们将尝试对两个delta函数的乘积进行积分。例如，在1d中，[2.x.10]是通常的片状线性 "帽子函数"，我们会得到这样的积分 

[1.x.45] 

其中[2.x.11]是定义形状函数[2.x.12]的节点位置，[2.x.13]是网格大小（假设为均匀）。问题是，积分中的delta函数是用以下关系定义的 

[1.x.46] 

但这只有在以下情况下才行得通：(i) [2.x.14]实际上在[2.x.15]处定义良好，(ii)如果它是有限的。另一方面，一个形式的积分 

[1.x.47] 

是没有意义的。类似的推理可以适用于2d和3d的情况。

换句话说。这种试图在整个领域内进行积分，然后通过部分积分的方法是行不通的。

历史上，数值分析家试图通过发明 "C<sup>1</sup>连续 "的有限元来解决这个问题，也就是说，使用的形状函数不仅是连续的，而且还有连续的一导数。这是诸如阿吉里斯元素、克拉夫-托歇尔元素和其他元素的领域，这些元素都是在20世纪60年代末开发的。从二十一世纪的角度来看，它们的结构只能说是怪异的。如果想使用一般的网格，它们的实现也是非常麻烦的。因此，它们在很大程度上已经失去了作用，deal.II目前不包含这些形状函数的实现。


[1.x.48][1.x.49] 。


那么，如何解决这些问题呢？这在一定程度上取决于边界条件。如果有第一组边界条件，也就是说，如果方程是 

[1.x.50] 

那么下面的诀窍就会起作用（至少如果域是凸的，见下文）。与我们通过引入第二个变量从常规拉普拉斯方程得到[2.x.16]的混合拉普拉斯方程一样，我们在这里可以引入一个变量[2.x.17]，然后可以用下面的 "混合 "系统取代上面的方程。

[1.x.51] 

换句话说，我们最终得到的实质上是[2.x.18]的两个耦合的拉普拉斯方程组，每个方程组都有迪里希勒型边界条件。我们知道如何解决这样的问题，使用[2.x.19]或[2.x.20]的技术为这个系统构建良好的求解器和预处理器应该不是很困难。所以这种情况处理起来非常简单。

 [2.x.21] 值得指出的是，这只适用于边界有角的域，如果该域也是凸的--换句话说，如果没有重入角。  这听起来是一个相当随意的条件，但考虑到以下两个事实，它是有意义的。原始双调方程的解必须满足 [2.x.22] 。另一方面，上面的混合系统重述表明，[2.x.23]和[2.x.24]都满足[2.x.25]，因为这两个变量只解决一个泊松方程。换句话说，如果我们想保证混合问题的解[2.x.26]也是原来的偏谐方程的解，那么我们需要能够以某种方式保证[2.x.27]的解实际上比只是[2.x.28]更平稳。这一点可以作如下论证。对于凸域，[1.x.52]意味着，如果右侧[2.x.29]，那么[2.x.30]如果域是凸的并且边界足够光滑。(如果域的边界足够光滑，也可以保证这一点--但边界没有角的域在现实生活中不是很实用。)   我们知道[2.x.31]，因为它解决了方程[2.x.32]，但我们仍然留下了边界凸性的条件；我们可以证明多边形的凸域足以保证[2.x.33]在这种情况下的实现（光滑的有界凸域将导致[2.x.34]，但我们不需要这么多规则）。另一方面，如果域不是凸的，我们不能保证混合系统的解在[2.x.35]中，因此可能得到一个不能等于原始双调方程的解。

更复杂的情况是，如果我们有 "钳制 "的边界条件，也就是说，如果方程看起来像这样。

[1.x.53] 

混合系统的相同技巧在这里不起作用，因为我们最终会对[2.x.36]有[1.x.54]迪里切特和诺伊曼边界条件，但对[2.x.37]没有。


在20世纪90年代和21世纪初，这一难题的解决方案随着非连续加尔金法的出现而出现。与使用[1.x.55]形状函数处理拉普拉斯方程，通过惩罚不连续的大小来获得每个形状函数上有一个导数的方程的方案一样，我们可以使用使用[1.x.56]（但不是[2.x.38]连续）形状函数的方案，惩罚导数的跳跃，以获得每个形状函数上有两个导数的方案。与拉普拉斯方程的内部惩罚（IP）方法相类似，这种用于双调方程的方案通常被称为[2.x.39]IP（或C0IP）方法，因为它使用[2.x.40]（连续但不可连续微分）形状函数与内部惩罚公式。


[1.x.57][1.x.58] 。


我们以Susanne Brenner和Li-Yeng Sung在 "C [2.x.42] 多边形域上线性四阶边界值问题的内部惩罚方法"[2.x.43]中提出的[2.x.41]IP方法为基础，该方法是针对具有 "钳制 "边界条件的双谐波方程而推出的。

如前所述，该方法依赖于使用[2.x.44]Lagrange有限元，其中[2.x.45]的连续性要求被放宽并被内部惩罚技术所取代。为了推导这个方法，我们考虑一个[2.x.46]形状函数[2.x.47]，它在[2.x.48]上消失。我们引入符号[2.x.49]作为[2.x.50]的所有面的集合，[2.x.51]作为边界面的集合，而[2.x.52]作为内部面的集合，以便在下面进一步使用。由于[2.x.53]的高阶导数在每个界面[2.x.54]上有两个值（由两个单元[2.x.55]共享），我们通过在[2.x.56]上定义以下单值函数来应对这种不连续性。

[1.x.59] 

为[2.x.57]（即梯度和二阶导数矩阵），其中[2.x.58]表示从[2.x.60]到[2.x.61]指向[2.x.59]的单位向量法线。在文献中，这些函数分别被称为 "跳跃 "和 "平均 "操作。

为了得到[2.x.62]IP的近似值[2.x.63]，我们将偏谐方程左乘以[2.x.64]，然后对[2.x.65]进行积分。如上所述，我们不能用这些形状函数对[2.x.66]的所有部分进行积分，但我们可以对每个单元单独进行积分，因为形状函数只是每个单元的多项式。因此，我们首先在每个网格单元[2.x.67]上使用下面的分项积分公式。

[1.x.60] 

在这一点上，我们有两个选择。我们可以对域项的[2.x.68]再进行一次积分，得到 

[1.x.61] 

由于各种原因，这被证明是一个对我们的目的没有用的变化。

相反，我们要做的是认识到[2.x.69]，我们可以将这些操作重新排序为[2.x.70]，我们通常写成[2.x.71]来表示这是二阶导数的 "Hessian "矩阵。通过这种重新排序，我们现在可以整合发散，而不是梯度算子，我们得到以下结果。

[1.x.62] 

这里，冒号表示对其左边和右边的矩阵指数的双重收缩，也就是两个张量之间的标量乘积。两个向量[2.x.72]的外积得到了矩阵[2.x.73] 。

然后，我们对所有单元格[2.x.74]进行求和，并考虑到这意味着每个内部面在求和中出现两次。因此，如果我们把所有的东西分成单元格内部的积分之和和单元格界面的单独之和，我们就可以使用上面定义的跳跃和平均运算符。还有两个步骤。首先，由于我们的形状函数是连续的，形状函数的梯度可能是不连续的，但连续性保证了实际上只有梯度的法向分量是不连续的，而切向分量是连续的。其次，当网格大小为零时，产生的离散公式并不稳定，为了得到一个稳定的公式，收敛到正确的解，我们需要添加以下条款。

[1.x.63] 

然后，在对出现的情况进行抵消后，我们得出以下双调方程的C0IP公式：找到[2.x.75]，使[2.x.76]在[2.x.77]上和 

[1.x.64] 

其中 

[1.x.65] 

和 

[1.x.66] 

这里，[2.x.78]是惩罚参数，它既弱化了边界条件的执行 

[1.x.67] 

在边界界面[2.x.79]上，也确保在极限[2.x.80]，[2.x.81]收敛为[2.x.82]的连续函数。 [2.x.83]被选择为足够大，以保证方法的稳定性。我们将在下面的程序中讨论我们的选择。


[1.x.68][1.x.69] 。

在多边形域上，双调方程的弱解[2.x.84]住在[2.x.85]中，其中[2.x.86]是由[2.x.87]的角的内角决定。例如，只要[2.x.88]是凸的，[2.x.89]；[2.x.90]可能小于1，如果域有重心角，但如果所有内角之一接近[2.x.93]，[2.x.91]就接近于[2.x.92] 。

现在假设[2.x.94]的IP解[2.x.95]被[2.x.96]的形状函数近似为多项式程度[2.x.97]。然后，上面概述的离散化产生了下面讨论的收敛率。


[1.x.70] 

理想情况下，我们希望测量 "能量准则 "的收敛性 [2.x.98] 。然而，这并不可行，因为同样，离散解[2.x.99]并没有两个（弱）导数。相反，我们可以定义一个离散的（[2.x.100] IP）半规范，它 "等同于 "能量规范，如下所示。

[1.x.71] 



在这个半规范中，上面提到的论文中的理论得出，我们可以期望 

[1.x.72] 

与我们知道的拉普拉斯方程的通常离散化的收敛率所期望的差不多。

当然，只有在精确解足够光滑的情况下，这才是真的。事实上，如果[2.x.101]有[2.x.102]，[2.x.103]其中有[2.x.104]，那么[2.x.105]IP方法的收敛率是[2.x.106] 。换句话说，只有当解平滑到[2.x.107]时，才能期待最佳收敛率；这只有在以下情况下才会发生：(i) 域是凸的，边界足够平滑；(ii) [2.x.108] 。当然，在实践中，解决方案是什么就是什么（与我们选择的多项式程度无关），那么最后一个条件可以等同于说，如果[2.x.110]不大，那么选择[2.x.109]大肯定没有意义。换句话说，[2.x.111]唯一合理的选择是[2.x.112]，因为更大的多项式度数不会导致更高的收敛阶数。

在这个程序中，我们有点懒得去实际实现这个等价的seminorm--尽管它不是很困难，而且会成为一个很好的练习。相反，我们将在程序中简单地检查一下 "坏的"[2.x.113]语义准则是什么？

[1.x.73] 

产生的结果。从理论上看，这个准则的收敛率当然不可能比[2.x.114]的收敛率高[1.x.74]，因为它只包含必要项的一个子集，但至少可以想象到它会更好。还有一种情况是，即使程序中存在一个错误，我们也能得到最佳收敛率，而这个错误只会在[2.x.115]中出现的额外条款中显示出次优的收敛率。但是，人们可能希望，如果我们在破碎规范和下面讨论的规范中得到最优速率，那么这个程序确实是正确的。结果部分将证明，我们在所有显示的规范中都得到了最优率。


[1.x.75] 

在 [2.x.116] -规范中的最佳收敛率是 [2.x.117] 提供 [2.x.118] 。更多细节可以在 [2.x.119] 的定理4.6中找到。

在下面的程序中，默认是选择 [2.x.120] 。在这种情况下，该定理并不适用，事实上，人们只能得到[2.x.121]而不是[2.x.122]，我们将在结果部分展示。


[1.x.76] 

鉴于我们在最好的情况下期望[2.x.123]等同于[2.x.124]半规则的规范，以及[2.x.125]等同于[2.x.126]规范，人们可能会问在[2.x.127]半规则中会发生什么，它是介于其他两个规范之间。一个合理的猜测是，我们应该期待[2.x.128] 。可能在某个地方有一篇论文证明了这一点，但我们也验证了这个猜想在下面的实验中是真实的。




[1.x.77][1.x.78] 。


我们注意到，对于具有其他边界条件的偏谐方程--例如，对于第一组边界条件即[2.x.130]和[2.x.131]上的[2.x.132]--的IP方法的推导，可以通过对[2.x.133]和[2.x.134]的适当修改得到，在书中的章节[2.x.135]中描述。


[1.x.79][1.x.80] 。


剩下要描述的最后一步是这个程序解决的问题。像往常一样，三角函数是一个既好又坏的选择，因为它不在我们可能寻求解的任何多项式空间中，同时又比实数解通常更平滑（这里，它在[2.x.136]中，而实数解在凸多边形域上通常只在[2.x.137]左右，如果域不是凸的，则在[2.x.138]和[2.x.139]之间）。但是，由于我们没有办法用相对简单的公式来描述现实问题的解决方案，所以我们只是用下面的方法，在域[2.x.140]的单位平方上。

[1.x.81] 

因此，我们需要选择以下的边界条件。

[1.x.82] 

右手边很容易计算为 

[1.x.83] 

该程序有[2.x.141]和[2.x.142]类，可以编码这些信息。[1.x.84][1.x.85] 。


[1.x.86] [1.x.87]。




前面几个include文件已经在前面的例子中使用过了，所以我们在这里不再解释它们的含义。程序的主要结构与例如[2.x.143]的结构非常相似，因此我们包含了许多相同的头文件。







[1.x.88] 



最有趣的两个头文件将是这两个。

[1.x.89] 



其中第一个文件负责提供FEInterfaceValues类，该类可用于评估数量，如形状函数（或其梯度）在细胞间界面的跳跃或平均。这个类在评估C0IP公式中出现的惩罚项时将相当有用。










[1.x.90] 



在下面的命名空间中，让我们定义精确解，我们将与数值计算的解进行比较。它的形式是[2.x.144]（只实现了2d情况），该命名空间还包含一个对应于产生该解的右手边的类。

[1.x.91] 




[1.x.92] [1.x.93]。   


下面是本教程程序的主要类。它具有许多其他教程程序的结构，其内容和后面的构造函数应该没有什么特别令人惊讶的地方。

[1.x.94] 



接下来是创建初始网格（一次精炼的单元格）和设置每个网格的约束、向量和矩阵的函数。同样，这两个函数与以前的许多教程程序基本没有变化。

[1.x.95] 




[1.x.96] [1.x.97]    


下面几段代码更有意思。它们都与线性系统的装配有关。虽然组装单元内部项的难度不大--这在本质上就像组装拉普拉斯方程的相应项一样，你已经在[2.x.145]或[2.x.146]中看到了这是如何工作的，例如，困难在于公式中的惩罚项。这需要在单元格的界面上对形状函数的梯度进行评估。因此，至少需要使用两个FEFaceValues对象，但如果其中一个面是自适应细化的，那么实际上需要一个FEFaceValues和一个FESubfaceValues对象；我们还需要跟踪哪些形状函数在哪里，最后我们需要确保每个面只被访问一次。所有这些对于我们真正想要实现的逻辑（即双线性形式中的惩罚项）来说都是一笔不小的开销。因此，我们将利用FEInterfaceValues类--这是deal.II中的一个辅助类，它允许我们抽象出两个FEFaceValues或FESubfaceValues对象，直接访问我们真正关心的东西：跳跃、平均数等。   


但这还没有解决我们的问题，即当我们在所有单元格和它们的所有面中循环时，必须跟踪我们已经访问过哪些面。为了使这个过程更简单，我们使用了[2.x.147]函数，它为这个任务提供了一个简单的接口：基于WorkStream命名空间文档中概述的想法，[2.x.148]需要三个函数对单元、内部面和边界面进行工作。这些函数在从头开始的对象上工作，以获得中间结果，然后将其计算结果复制到复制数据对象中，由一个复制器函数将其复制到全局矩阵和右侧对象中。   


然后，下面的结构提供了这种方法所需的从头开始和复制对象。你可以查阅WorkStream命名空间以及[2.x.149]"多处理器并行计算 "模块，以了解更多关于它们通常如何工作的信息。

[1.x.98] 



更有趣的部分是我们实际组装线性系统的地方。从根本上说，这个函数有五个部分。

- 定义 "cell_worker "λ函数，这是一个定义在 "assemble_system() "函数中的小函数，它将负责计算单个单元上的局部积分。它将在`ScratchData`类的副本上工作，并将其结果放入相应的`CopyData`对象中。

- 定义`face_worker'lambda函数，对单元格之间界面上的所有项进行积分。

- 定义`boundary_worker'函数，对位于域的边界上的单元格面做同样的工作。

- 定义`copier'函数，负责将前三个函数的所有数据复制到单个单元的复制对象中，并复制到全局矩阵和右侧。   


第五部分是我们将所有这些汇集到一起的地方。   


让我们轮流看一下这些组装所需的每一块。

[1.x.99] 



第一部分是在细胞内部进行组装的`cell_worker`。它是一个（lambda）函数，以一个细胞（输入）、一个抓取对象和一个复制对象（输出）为参数。它看起来像许多其他教程程序中的装配函数，或者至少是所有单元格的循环主体。     


我们在这里整合的术语是单元格的贡献 

[1.x.100] 

对全局矩阵的贡献，以及 

[1.x.101] 

对右手边向量的贡献。     


我们使用与组装[2.x.150]相同的技术来加速该函数。我们不在最里面的循环中调用`fe_values.shape_hessian(i, qpoint)`，而是创建一个变量`hessian_i`，在循环中对`i`进行一次评估，在循环中对`j`重新使用如此评估的值。为了对称，我们对变量`hessian_j`也做了同样的处理，尽管它确实只用了一次，而且我们可以在计算两个项之间标量乘积的指令中留下对`fe_values.shape_hessian(j,qpoint)`的调用。

[1.x.102] 



下一个构建模块是在网格的每个内部面组装惩罚项。正如[2.x.151]文档中所描述的，这个函数接收到的参数表示一个单元和其相邻的单元，以及（对于这两个单元中的每一个）我们必须整合的面（以及潜在的子面）。同样，我们也得到了一个从头开始的对象，以及一个用于放置结果的副本对象。     


这个函数本身有三个部分。在顶部，我们初始化FEInterfaceValues对象，并创建一个新的[2.x.152]对象来存储我们的输入。这将被推到`copy_data.face_data`变量的末尾。我们需要这样做，因为我们为一个给定的单元整合的面（或子面）的数量因单元而异，这些矩阵的大小也不同，取决于面或子面邻近的自由度是什么。正如[2.x.153]文档中所讨论的，每次访问一个新的单元时，复制对象都会被重置，因此我们推送到`copy_data.face_data()`末尾的内容实际上就是后来的`copier`函数在复制每个单元的贡献到全局矩阵和右侧对象时所能看到的。

[1.x.103] 



第二部分涉及到确定惩罚参数应该是什么。通过观察双线性形式中各种项的单位，很明显，惩罚必须具有[2.x.154]的形式（即超过长度尺度的一个），但应该如何选择无维数[2.x.155]并不先验。从拉普拉斯方程的不连续Galerkin理论来看，人们可能猜想正确的选择是[2.x.156]是正确的选择，其中[2.x.157]是所用有限元的多项式程度。我们将在本方案的结果部分更详细地讨论这个选择。       


在上面的公式中，[2.x.158]是单元格[2.x.159]的大小。但这也不是很简单的事情。如果使用高度拉伸的单元格，那么一个更复杂的理论说，[2.x.160]应该被单元格[2.x.161]的直径取代，该直径是有关边缘方向的法线。 事实证明，在deal.II中有一个函数用于此。其次，当从一个面的两个不同侧面看时，[2.x.162]可能是不同的。       


为了安全起见，我们取这两个值的最大值。我们将注意到，如果使用自适应网格细化产生的悬空节点，这种计算方式有可能需要进一步调整。

[1.x.104] 



最后，像往常一样，我们在正交点和指数`i`和`j`上循环，把这个面或子面的贡献加起来。然后将这些数据存储在上面创建的`copy_data.face_data`对象中。至于单元格工作者，如果可能的话，我们将平均数和跳跃的评估从循环中拉出来，引入局部变量来存储这些结果。然后组件只需要在最里面的循环中使用这些局部变量。关于这段代码实现的具体公式，回顾一下，双线性形式的接口项如下。

[1.x.105] 



[1.x.106] 



第三件事是对处于边界的面做同样的装配。当然，想法和上面一样，唯一不同的是，现在有惩罚项也进入了右手边。     


和以前一样，该函数的第一部分只是设置了一些辅助对象。

[1.x.107] 



从正面看，由于我们现在只处理与面相邻的一个单元（因为我们在边界上），惩罚因子[2.x.163]的计算大大简化了。

[1.x.108] 



第三部分是条款的组合。由于这些条款包含了矩阵和右手边的条款，所以现在稍微复杂一些。前者与上面所说的内部面完全相同，如果我们只是适当地定义了跳跃和平均（这就是FEInterfaceValues类所做的）。后者需要我们评估边界条件[2.x.164]，在当前情况下（我们知道确切的解决方案），我们从[2.x.165]中计算出来。然后，要添加到右手边矢量的项是 [2.x.166] 。

[1.x.109] 



第4部分是一个小函数，它将上面的单元格、内部和边界面装配程序产生的数据复制到全局矩阵和右手向量中。这里真的没有什么可做的。我们分配单元格矩阵和右侧贡献，就像我们在其他几乎所有的教程程序中使用约束对象那样。然后，我们还必须对面矩阵贡献做同样的事情，这些贡献已经获得了面（内部和边界）的内容，并且`面_工作`和`边界_工作`已经添加到`copy_data.face_data`数组中。

[1.x.110] 



在设置了所有这些之后，剩下的就是创建一个scratch和copy数据对象，并调用[2.x.167]函数，然后翻阅所有的单元格和面，调用各自的worker，然后是copyer函数，将东西放入全局矩阵和右侧。作为一个额外的好处，[2.x.168]以并行方式完成所有这些工作，使用你的机器恰好有多少个处理器核心。

[1.x.111] 




[1.x.112] [1.x.113]。   


表演到此基本上结束了。其余的函数并不太有趣或新颖。第一个函数只是使用直接求解器来求解线性系统（另见[2.x.169] ）。

[1.x.114] 



下一个函数评估了计算出的解和精确解之间的误差（在这里我们知道精确解，因为我们已经选择了右手边和边界值的方式，所以我们知道相应的解）。在下面的前两个代码块中，我们计算了[2.x.170]准则和[2.x.171]半准则的误差。

[1.x.115] 



现在也计算一下[2.x.172]半规范误差的近似值。实际的[2.x.173]半规范要求我们对解[2.x.174]的二阶导数进行积分，但考虑到我们使用的拉格朗日形状函数，[2.x.175]在单元间的界面上当然有结点，因此二阶导数在界面上是奇异的。因此，我们实际上只对单元的内部进行积分，而忽略了界面的贡献。这不是*等同于问题的能量准则，但是仍然给了我们一个关于误差收敛速度的概念。     


我们注意到，我们可以通过定义一个等同于能量准则的准则来解决这个问题。这将涉及到不仅要像我们下面所做的那样将细胞内部的积分相加，而且还要为[2.x.176]的导数在界面上的跳跃增加惩罚项，并对这两种项进行适当的缩放。我们将把这个问题留给以后的工作。

[1.x.116] 



同样无趣的是生成图形输出的函数。它看起来和[2.x.177]中的那个一模一样，比如说。

[1.x.117] 



`run()`函数的情况也是如此。就像在以前的程序中一样。

[1.x.118] 




[1.x.119] [1.x.120] 




最后是`main()'函数。同样，这里没有什么可看的。它看起来和以前的教程程序中的一样。有一个变量，可以选择我们要用来解方程的元素的多项式程度。因为我们使用的C0IP公式要求元素的度数至少为2，所以我们用一个断言来检查，无论为多项式度数设置什么都是有意义的。

[1.x.121] 

[1.x.122][1.x.123] 。


我们用介绍中讨论的右手边和边界值运行程序。这些将产生域[2.x.179]上的解[2.x.178] 。我们用[2.x.180]、[2.x.181]和[2.x.182]元素来测试这个设置，我们可以通过`main()`函数中的`fe_degree`变量来改变。随着网格的细化，[2.x.183]的收敛率、[2.x.184]的近似值率和[2.x.185]的近似值收敛率对于[2.x.187]应该是2、2、1左右（如介绍中所讨论的[2.x.188]的规范为次优）；对于[2.x.189]是4、3、2；而对于[2.x.190]是5、4、3。

从文献来看，并不清楚惩罚参数[2.x.191]应该是什么。例如，[2.x.192]指出它需要大于1，并选择[2.x.193] 。FEniCS/Dolphin教程选择它为[2.x.194] ，见https://fenicsproject.org/docs/dolfin/1.6.0/python/demo/documented/biharmonic/python/documentation.html 。 [2.x.195]使用的[2.x.196]值大于Kirchhoff板的元素所属的边数（见他们的第4.2节）。这表明也许[2.x.197], [2.x.198], 太小了；另一方面，[2.x.199]的值将是合理的，其中[2.x.200]是多项式的程度。通过与拉普拉斯方程的不连续Galerkin公式相比较，人们期望最后一个选择是可行的（例如，见[2.x.201]和[2.x.202]中的讨论），而且它在这里也将证明是可行的。但是我们应该检查[2.x.203]的哪个值是正确的，我们将在下面这样做；改变[2.x.204]在`assemble_system()`中定义的两个`face_worker`和`boundary_worker`函数中很容易。


[1.x.124][1.x.125][1.x.126][1.x.127] 


我们用不同的细化网格运行代码，得到以下收敛率。

 [2.x.205] 我们可以看到[2.x.206]的收敛率约为2，[2.x.207] -seminorm收敛率约为2，[2.x.208] -seminorm收敛率约为1。后两者与理论上的预期收敛率相符；对于前者，我们没有定理，但鉴于介绍中的评论，对其为次优的情况并不感到惊讶。


[1.x.128][1.x.129][1.x.130][1.x.131] 




 [2.x.209] 我们可以看到，[2.x.210]的收敛率约为4，[2.x.211] -seminorm收敛率约为3，而[2.x.212] -seminorm收敛率约为2。当然，这符合我们的理论预期。


[1.x.132][1.x.133][1.x.134][1.x.135] 


 [2.x.213] 我们可以看到，[2.x.214]规范收敛率约为5，[2.x.215] -seminorm收敛率约为4，而[2.x.216] -seminorm收敛率约为3。在最细的网格上，[2.x.217]规范收敛率比我们的理论预期小得多，因为线性求解器由于舍入而成为限制因素。当然，在这种情况下，[2.x.218]的误差也已经非常小了。


[1.x.136][1.x.137][1.x.138][1.x.139] 


为了与上面的结果进行比较，现在让我们也考虑一下我们简单地选择[2.x.219]的情况。

 [2.x.220] 虽然[2.x.221]的规范收敛率或多或少地遵循了理论上的预期，但[2.x.223] -seminorm和[2.x.224] -seminorm似乎并没有像预期那样收敛。比较[2.x.225]和[2.x.226]的结果，很明显[2.x.227]是一个更好的惩罚。鉴于[2.x.228]对于[2.x.229]元素来说已经太小了，如果用[2.x.230]元素重复实验，结果更加令人失望，这可能就不奇怪了。我们再次只得到2、1、0的收敛率--也就是说，不比[2.x.231]元素好（尽管误差的大小更小）。然而，也许令人惊讶的是，当使用[2.x.232]元素时，人们获得了或多或少的预期收敛顺序。无论如何，这种不确定性表明，[2.x.233]充其量是一个有风险的选择，最坏的情况是一个不可靠的选择，我们应该选择[2.x.234]更大的。


[1.x.140][1.x.141][1.x.142][1.x.143] 


由于[2.x.235]显然太小，人们可能猜想[2.x.236]实际上可能效果更好。下面是在这种情况下得到的结果。

 [2.x.237] 在这种情况下，收敛率或多或少符合理论预期，但与[2.x.238]的结果相比，变化更大。同样，我们可以对[2.x.239]和[2.x.240]元素重复这种实验。在这两种情况下，我们会发现我们获得了大致的预期收敛率。那么，更感兴趣的可能是比较误差的绝对大小。在上表中，对于[2.x.241]情况，最细网格上的误差在[2.x.242]和[2.x.243]情况下是可比的，而对于[2.x.244]，[2.x.245]的误差远远大于[2.x.246]。对于[2.x.247]的情况也是如此。


[1.x.144][1.x.145] 。


关于应该使用哪种 "合理 "的惩罚参数选择的结论是，[2.x.248]产生了预期的结果。因此，它是目前编写的代码所使用的。


[1.x.146][1.x.147] 。


对这个程序有一些明显的扩展，这些扩展是有意义的。

- 该程序使用了一个正方形域和一个均匀的网格。真正的问题不是这样的，我们应该验证在其他形状的域上的收敛性，特别是在弯曲的边界上。人们也可能对使用自适应网格细化来解决规则性较差的区域感兴趣。

- 从理论的角度来看，上面的收敛结果只使用了 "破碎的"[2.x.249]半规范[2.x.250]，而不是 "等效的 "规范[2.x.251] 。这足以让我们相信，这个程序并没有从根本上被破坏。然而，测量我们有理论结果的实际规范的误差可能是有趣的。例如，使用FEInterfaceValues类与[2.x.252]结合，实现这一补充应该不会过于困难，其精神与我们用于装配线性系统的精神相同。


[1.x.148] [1.x.149]。


  类似于实施中解决的 "夹持 "边界条件，我们将推导出[2.x.253]IP有限元方案，用于简支板。  [1.x.150] 

  我们用测试函数[2.x.254]乘以偏谐方程，并对[2.x.255]进行积分，得到。  [1.x.151] 



  对所有单元格[2.x.256]进行求和，因为[2.x.257]的法线方向在两个单元格共享的每条内边上都指向相反的方向，[2.x.258]在[2.x.259]上，[1.x.152] 

  并根据单元格界面上的跳跃定义，[1.x.153] 。

  我们将域的内部面和边界面分开，[1.x.154] 。

  其中[2.x.260]是内部面的集合。  这导致我们得出[1.x.155]。



  为了使离散问题对称化和稳定化，我们加入对称化和稳定化项。  我们最终得到双调方程的[2.x.261]IP有限元方案：找到[2.x.262]，使[2.x.263]在[2.x.264]和[1.x.156] 上 

  其中[1.x.157] 

  和[1.x.158]。

  这个边界案例的实现与 "钳制 "版本类似，只是在系统组装时不再需要 "边界_工人"，并且根据配方改变右手边。[1.x.159] [1.x.160] [2.x.265]  

 [2.x.266] 
