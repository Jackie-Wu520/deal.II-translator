 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] , [2.x.3] , [2.x.4] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14 ][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28] 

 [2.x.5]  

[1.x.29] 

 [2.x.6]  


[1.x.30] [1.x.31] 


[1.x.32][1.x.33]。


在本教程中，我们考虑了层流体系中的混合问题。这类问题出现在从化学工程到发电（如涡轮机械）等广泛的应用中。混合问题特别难以用数值解决，因为它们通常涉及一个容器（有固定的边界，可能还有复杂的几何形状，如挡板），由域[2.x.7]表示，和一个（或多个）沉浸和旋转的叶轮（由域[2.x.8]表示）。我们希望解决流动方程的领域是这两个领域之间的（与时间有关的）差异，即。 [2.x.9] . 

对于旋转叶轮，使用任意拉格朗日欧拉公式（其中流体域--连同网格! 在这种情况下，除非只考虑小的时间（即小的流域变形），否则不可能使用任意拉格朗日欧拉公式（在这种情况下，流域--连同网格--被平滑地变形以跟随浸入固体的变形）。如果想跟踪叶轮多次旋转时的流动演变，所产生的变形网格就会过于扭曲而无用。

在这种情况下，一个可行的替代策略是使用非匹配方法（类似于我们在[2.x.10]中所做的），其中一个背景固定网格（可能会或不会在时间上进行局部细化以更好地捕捉固体运动）与一个旋转的独立网格相耦合。

为了保持与[2.x.11]中使用的相同符号，我们使用[2.x.12]来表示[2.x.13]中代表流体和叶轮容器的域，并且我们在[2.x.15 ]来表示整个叶轮（当它的`spacedim`度量非负值时，也就是说，当我们可以把它表示为维数`dim`等于`spacedim`的网格时），薄叶轮的同维度表示，或者只是整个叶轮的边界。

域[2.x.16]被嵌入到[2.x.17]（[2.x.18]）中，它是不匹配的：一般来说，它不与体积网格的任何特征对齐。我们在[2.x.19]上求解一个偏微分方程，通过一些惩罚技术在嵌入域[2.x.20]上强制执行一些问题的解决条件。在当前情况下，条件是流体在[2.x.21]上各点的速度等于固体叶轮在该点的速度。

我们在这里描述的技术在文献中使用了许多名称之一：[1.x.34]和[1.x.35]等。 其主要原理是两个网格的离散化保持完全独立。在本教程中，这种方法被用来求解由斯托克斯方程描述的粘性流体的运动，该流体被一个刚性的非变形叶轮搅动。

因此，[2.x.22]中求解的方程是蠕动流的斯托克斯方程（即[2.x.23]中的流动），并且在与叶轮相关的移动*嵌入域*[2.x.24]上应用无滑动边界条件。然而，这个教程可以很容易地扩展到其他方程（例如，纳维-斯托克斯方程、线性弹性方程等）。它可以被看作是[2.x.25]的一个自然扩展，它可以通过MPI使用分布式并行计算架构解决大型问题。

然而，与[2.x.26]相反，[2.x.27]上的Dirichlet边界条件是弱加的，而不是通过使用Lagrange乘法器，并且我们集中处理两个完全分布式三角形的耦合（这种组合在[2.x.28]的实现中是不可能的）。

当人们想在嵌入域上执行条件时，有两种有趣的情况出现 [2.x.29] 。

- 嵌入域[2.x.30]的几何维度`dim`与域[2.x.31]相同（`spacedim`），也就是说，[2.x.32]的spacedim维度不为零。在这种情况下，对[2.x.33]施加Dirichlet边界的边界条件是通过体积惩罚完成的。如果施加的惩罚只取决于速度，这通常被称为[2.x.34]惩罚，而如果惩罚同时取决于速度及其梯度，则是[2.x.35]惩罚。2.x.36] 惩罚的情况与Darcy型方法非常相似。对[2.x.37]和[2.x.38]两种惩罚方法都进行了广泛的分析（例如，见[2.x.39]）。

- 嵌入域[2.x.40]的内在维度`dim`小于[2.x.41]的维度（`spacedim`），因此它的spacedim维度为零；例如，它是一条嵌入二维域的曲线，或一个嵌入三维域的曲面。当然，这在物理上是不可能的，但是如果金属片的厚度可以忽略不计的话，我们可以把在流体中运动的非常薄的金属片视为本质上的低维。在这种情况下，通过应用[1.x.36]方法（见[2.x.43]）对[2.x.42]施加弱边界条件。

这两种方法都有非常相似的要求，并导致高度相似的计算公式。因此，我们几乎以同样的方式对待它们。

在本教程中，我们对[2.x.44]的进一步细节不感兴趣：我们假设嵌入域的尺寸（`dim`）总是比嵌入域的尺寸[2.x.45]（`spacedim`）小一或相等。

我们将解决以下微分问题：给定[2.x.47]上的一个足够规则的函数[2.x.46]，找到[2.x.48]的解。

[1.x.37] 



这个方程，我们通过缩放时间单位的方式将其规范化，使粘度的数值为1，描述了缓慢的粘性流动，如蜂蜜或岩浆。本教程的主要目的是说明如何用惩罚方法，以弱的方式将速度场条件[2.x.49]强加于非匹配的[2.x.50]。关于斯托克斯问题的更广泛的讨论，包括体力、不同的边界条件和求解策略，可以在 [2.x.51] 中找到。

让我们首先考虑整个领域中的斯托克斯问题 [2.x.52] 。我们寻找一个速度场[2.x.53]和一个压力场[2.x.54]，满足斯托克斯方程的同质边界条件[2.x.55]。

斯托克斯方程的微弱形式首先通过将其写成矢量形式[1.x.38] 得到 

与矢量值测试函数[2.x.56]形成左边的点积，并在域[2.x.57]上积分，得到以下方程组。[1.x.39] 

这对所有测试函数[2.x.58]都必须成立。


通过部分积分并利用[2.x.59]的边界条件，我们得到以下变分问题：[1.x.40] 。



其中[2.x.60]代表[2.x.61]的标量积。这与[2.x.62]中使用的变分形式相同。

这种变异形式没有考虑到嵌入域。与[2.x.63]相反，我们并不强行执行[2.x.64]对[2.x.65]的约束，而是通过惩罚项弱行执行。

对这种弱的边界条件的分析取决于[2.x.66]的间隔维度是正的（如果`dim`等于`spacedim`）还是零（如果`dim`小于`spacedim`）。我们讨论这两种情况。


[1.x.41][1.x.42] 


在这种情况下，我们假设[2.x.67]是实际叶轮的边界，即嵌入二维域的封闭曲线或三维域的封闭表面。这种方法的思路首先是考虑在[2.x.68]上弱加迪里切特边界条件，遵循尼采方法。这是通过在流体域上使用以下修改后的公式来实现的，其中没有对[2.x.69]上的测试函数施加强条件。

[1.x.43] 



对[2.x.70]的积分是低维积分。可以证明（见[2.x.71]），存在一个正的常数[2.x.72]，所以如果[2.x.73]，边界的弱强加条件将是一致和稳定的。在[2.x.74]上的前两个附加积分（上式中的第二行）在通过部分积分后自然出现，此时我们不假设[2.x.75]在[2.x.76]上是零。

上文等式中的第三行包含两个条款，是为了确保弱形式的一致性，还有一个稳定条款，是为了强制执行边界条件，其误差与近似误差一致。一致性项和稳定项是用实际的边界数据添加到右边的 [2.x.77] 。

当[2.x.78]满足[2.x.80]上的条件[2.x.79]时，[2.x.81]上的所有一致性和稳定性积分都被抵消，就剩下通常的斯托克斯流的弱形式，也就是说，上述表述是一致的。

我们注意到，可以使用另一种（非对称的）表述。

[1.x.44] 

注意第三行和第四行的第一个项的不同符号。在这种情况下，稳定性和一致性条件成为 [2.x.82] 。在对称情况下，[2.x.83]的值取决于[2.x.84]，一般选择[2.x.85]，[2.x.86]是衡量被整合面的大小，[2.x.87]是一个常数，以便[2.x.88] 。这就像人们通常用Nitsche惩罚方法来执行Dirichlet边界条件一样。

另一方面，非对称方法与人们对非连续Galerkin方法的非对称内部惩罚方法（"NIPG "方法[2.x.89]）执行连续性的方式有关。即使非对称情况在稳定参数的可能选择方面似乎更有优势，我们还是选择了对称离散化，因为在这种情况下，可以证明对偶问题也是一致的，导致解决方案不仅能量规范以正确的顺序收敛，而且其[2.x.90]规范也是如此。此外，得到的矩阵仍然是对称的。

上述公式是在假设领域被精确离散化的情况下工作的。然而，如果叶轮的变形是一个刚体运动，就有可能人为地将斯托克斯问题的解扩展到螺旋桨本身，因为刚体运动也是斯托克斯问题的解。我们的想法是在[2.x.91]内解决同样的问题，在[2.x.92]上施加同样的边界条件，使用同样的惩罚技术，并用在[2.x.94]上全局连续的测试函数[2.x.93]来测试。

这导致了以下（中间）公式。[1.x.45] 

其中跳跃项，用[2.x.95]表示，是相对于法向量[2.x.96]的一个固定方向计算的。2的系数出现在[2.x.97]前面，因为我们看到[2.x.98]的每一部分两次，一次来自流体内部，一次来自在其中移动的障碍物内部。对于[2.x.99]上的所有其他积分，我们对[2.x.100]的每一部分都访问了两次，但符号相反，因此得到了跳跃项）。

这里我们注意到，与不连续的Galerkin方法不同，测试和试验函数在[2.x.101]上是连续的。此外，如果[2.x.102]不与单元边界对齐，所有的跳跃项也是零，因为一般来说，有限元函数空间在每个单元内都是平滑的，如果[2.x.103]穿过一个单元，只在有限的点上与它的边界相交，所有在[2.x.104]上的贡献，除了稳定化的，可以从公式中忽略，导致以下变分公式的最终形式。

[1.x.46] 



在[2.x.105]中，约束条件的施加需要以拉格朗日乘数的形式增加新的变量。本教程的程序不是这种情况。使用Nitsche方法施加边界条件只修改了系统矩阵和右手边，没有增加额外的未知数。然而，嵌入域上的速度矢量[2.x.106]不会与规定的速度[2.x.107]完全匹配，而只能达到与有限元方法的插值误差相同的数值误差。此外，与[2.x.108]一样，我们仍然需要在不匹配的嵌入网格上进行积分，以构建施加边界条件所需的边界项[2.x.109] 。


[1.x.47][1.x.48] 。


在这种情况下，[2.x.110]具有相同的尺寸，但被嵌入到[2.x.111]中。我们可以把它看作是一个在流体中移动的厚物体。在[2.x.112]惩罚的情况下，额外的惩罚项可以被解释为[2.x.113]内的达西项，结果是。

[1.x.49] 



这里，[2.x.114]上的积分只是体积的一部分的积分。因此，[2.x.115]的惩罚包括增加一个体积项，约束流体的速度与[2.x.116]内刚体的速度相一致。在这种情况下，[2.x.117]必须被选择得足够大，以确保[2.x.118]中的迪里希特边界条件得到充分尊重，但又不能太高，以保持系统矩阵的适当调节。

[2.x.119]的惩罚可以用类似的方式构建，在惩罚中加入粘性成分，以阻尼[2.x.120]内的速度梯度。

[1.x.50] 



注意[2.x.121]的惩罚（`dim`等于`spacedim`）和Nitsche的惩罚（`dim`等于`spacedim-1`）导致了完全相同的数值实现，这要感谢deal.II的独立维度能力。


[1.x.51][1.x.52] 。


在本教程中，嵌入网格[2.x.122]和嵌入网格都是用[2.x.123]来描述的。 这两个三角形可以通过GridGenerator命名空间中的函数或者通过读取其他应用程序（例如GMSH，见[2.x.124]中的讨论）生成的网格文件来构建。这比之前在 [2.x.125] 中所做的略微更普遍。

无论是在 "dim=spacedim "还是 "dim<spacedim "的情况下，增加浸没边界法，只是在系统矩阵和系统的右手边引入了额外的项，这些项是在[2.x.126]上积分的结果。这并没有改变必须解决的问题的变量数量。因此，挑战是与必须进行的积分有关 [2.x.127] 。

在有限元中，我们把这个积分分成来自用于离散化[2.x.128]的所有单元的贡献，我们把[2.x.129]上的积分转化为参考元素[2.x.130]上的积分，其中[2.x.131]是从[2.x.132]到[2.x.133]的映射，并使用正交公式计算[2.x.134]上的积分。比如说。

[1.x.53] 

计算这个和是不容易的，因为我们必须评估[2.x.135]。一般来说，如果[2.x.136]和[2.x.137]没有对齐，那么[2.x.138]这个点相对于[2.x.139]来说是完全任意的，除非我们想出一个办法，将[2.x.140]的所有基函数插在[2.x.141]上的一个任意点，否则我们无法计算出所需的积分。


为了评估[2.x.142]，需要采取以下步骤（如下图所示）。

- 对于[2.x.144]中的一个给定单元[2.x.143]，计算实点[2.x.145]，其中[2.x.146]是用于[2.x.147]上的积分的正交点之一。这是最容易的部分。 [2.x.148]给了我们所有正交点的实空间位置。

- 找到[2.x.149]中[2.x.150]所在的单元。我们将称这个单元为[2.x.151] 。

- 找出[2.x.152]内[2.x.153]的参考坐标。为此，我们需要将参考元素[2.x.155]转换为元素[2.x.156]：[2.x.157]的映射[2.x.154]的逆向。

- 在这一点上评估 [2.x.159] 网格的基函数 [2.x.158] [2.x.160] 。这也是比较简单的，使用FEValues。


 [2.x.161]  

在 [2.x.162] 中，上面的第二到第四步是通过依次调用来计算的。

- [2.x.163] 然后是 

- [2.x.164] 然后我们 

- 构建一个自定义正交公式，包含参考单元格中的点，然后 

- 构建一个FEValues对象，使用给定的正交公式，并以第一步获得的单元格进行初始化。

虽然这种方法对目前的情况可行，但它不容易用于使用分布式三角的平行模拟。事实上，由于嵌入域[2.x.165]单元上的正交点的位置与嵌入三角形的位置不一致，而且[2.x.166]是不断移动的，这就要求代表[2.x.167]的三角形被完整地存储在所有处理器中。随着处理器的数量和[2.x.168]中单元格数量的增加，这将导致内存方面的严重瓶颈。因此，在这一步骤中寻求另一种策略。


[1.x.54][1.x.55] 


记住，对于惩罚方法（[2.x.169]或[2.x.170]）和Nitsche方法，我们要计算被正交所近似的积分。也就是说，我们需要计算[1.x.56]。 如果你跟随上面的讨论，那么你会记得[2.x.171]和[2.x.172]是定义在流体网格上的形状函数。唯一定义在实体网格上的是。 [2.x.173] ，是实体单元上正交点的位置，是[2.x.174]的一部分，[2.x.175]是其雅各布系数的行列式，[2.x.176]是相应的正交重量。

现在要认识到的重要部分是这样的。 [2.x.177]是正交公式的一个属性，不随时间变化。此外，[2.x.178]的雅各布矩阵本身随着固体障碍物在流体中的移动而变化，但由于固体被认为是不变形的（它只平移和旋转，但不扩张），雅各布矩阵的行列式保持不变。因此，乘积[2.x.179]（我们通常用`JxW`表示）在每个正交点上保持不变。因此，我们唯一需要跟踪的是位置[2.x.180]--但这些位置随着实体域的速度移动。

换句话说，我们实际上根本不需要保持实体网格。我们所需要的只是位置[2.x.181]和相应的`JxW`值。由于这两个属性都是附着在实体材料上的点属性（或点向量），它们可以被理想化为一组不相连的无限小的 "粒子"，它们随着实体的运动携带所需的`JxW`信息。deal.II有能力以ParticleHandler类的形式在大规模并行计算中分配和存储这样一组粒子（关于实现的细节见[2.x.182] ），我们将在本教程中使用这一功能。

因此，这一步采取的方法如下。

- 为域 [2.x.184] 创建一个 [2.x.183] 。

- 在[2.x.186]上的正交点位置创建[2.x.185] 。

- 调用[2.x.187]函数，将粒子分布在处理器上，*遵循实体三角剖分*。

- 将 "JxW "值作为一个 "属性 "附加到每个[2.x.188]对象。

这种结构的生成相对昂贵，但每次模拟必须只生成一次。一旦生成了[2.x.189]并将所需信息附加到粒子上，就可以利用粒子在ParticleHandler内按单元分组的事实，对[2.x.190]进行积分，使我们能够。

- 在[2.x.191]中至少包含一个粒子的所有单元上进行循环操作 

- 在给定单元中的所有粒子上循环操作 

- 计算积分并填充全局矩阵。

由于[2.x.192]可以管理粒子从一个处理器到另一个处理器的交换，嵌入的三角结构可以通过移动粒子而被移动或变形。与这种位移相关的唯一约束是，颗粒的位移距离不应大于一个单元的大小。这是因为这是[2.x.193]能够跟踪离开当前单元的粒子现在所处的单元的极限。

一旦整个问题（斯托克斯问题和沉没边界施加）被集合起来，最终的鞍点问题由迭代求解器解决，应用于舒尔补数[2.x.194]（其构造例如在[2.x.195]中描述），我们使用LinearOperator类构建[2.x.196]。


[1.x.57][1.x.58] 


我们在这里解决的问题是对斯托克斯流的时间可逆性的演示。这在科学教育实验中经常用泰勒-库埃特流和染料液滴来说明，在流体以周期性的方式位移后，染料液滴又恢复到原来的形状。

[1.x.59] 



在本问题中，一个非常粘稠的流体被一个叶轮的旋转所搅动，在二维中，叶轮的模型是一个矩形网格。叶轮旋转了一定的圈数，之后流动被逆转，从而在相反的方向上进行相同圈数的旋转。我们回顾一下，由于斯托克斯方程是自交的，蠕动流是可逆的。因此，如果叶轮运动在相反的方向上被逆转，流体应该回到其原来的位置。在本例中，通过插入一圈被动的示踪粒子来说明这一点，这些粒子被流体平移并返回到原来的位置，从而证明了流动的时间可逆性。


[1.x.60][1.x.61] 。


本教程程序使用了一些关于对流体内部的非匹配界面施加速度条件的技术。关于更多的背景材料，你可能想查一下以下参考资料。 [2.x.197] , [2.x.198] , [2.x.199] , [2.x.200] , [2.x.201] 。[1.x.62] [1.x.63] 。


[1.x.64] [1.x.65] 其中大部分已在其他地方介绍过，我们只对新的进行评论。靠近顶部的开关允许在PETSc和Trilinos线性代数功能之间进行选择，与 [2.x.202] 和 [2.x.203] 中的开关类似。







[1.x.66] 



这些是与 [2.x.204] 有关的唯一新的包含文件。在本教程中，实体和流体之间的非匹配耦合是通过一个中间数据结构来计算的，该结构可以跟踪实体的正交点在流体网格中的位置如何演变。这个数据结构需要跟踪描述实体域的每个单元上的正交点的位置、正交权重，如果实体域是同维度的，还需要跟踪每个点的法向量。




Deal.II通过ParticleHandler类在Particles命名空间中提供这些设施。ParticleHandler是一个允许你管理粒子集合的类（类型为[2.x.205]的对象，代表具有一些附加属性（如ID）的点的集合，浮动在[2.x.206]命名空间中的方法和类允许人们轻松实现Particle-In-Cell方法和分布式三角形的粒子追踪。




我们 "滥用 "这个数据结构来存储嵌入周围流体网格中的实体正交点的位置信息，包括积分权重，以及可能的表面法线。我们之所以使用这个额外的数据结构，是因为实体网格和流体网格可能是不重叠的，如果我们使用两个独立的三角计算对象，就会在并行进程中独立分布。




为了耦合这两个问题，我们依靠ParticleHandler类，在每个粒子中存储一个实体正交点的位置（通常不与任何流体正交点对齐）、其权重以及耦合这两个问题可能需要的任何其他信息。然后这些位置与固体叶轮的（规定）速度一起传播。




实体正交点的所有权最初是从实体网格本身的MPI分区中继承的。这样产生的粒子后来通过使用ParticleHandler类的方法分配到流体网格。这允许MPI进程之间透明地交换关于流体单元和实体正交点之间的重叠模式的信息。

[1.x.67] 



在生成网格时，我们允许从文件中读取网格，如果deal.II的构建支持OpenCASCADE，我们也允许读取CAD文件，并将其作为网格的流形描述符（见[2.x.207]中对OpenCASCADE命名空间中的各种流形描述符的详细描述) 

[1.x.68] 




[1.x.69] [1.x.70] 




与我们在[2.x.208]中所做的类似，我们设置了一个持有我们问题的所有参数的类，并从ParameterAcceptor类派生出来，以简化参数文件的管理和创建。   


ParameterAcceptor范式要求所有参数都可以被ParameterAcceptor方法写入。为了避免出现很难追踪的错误（比如写成`time = 0`而不是`time == 0`），我们在一个外部类中声明所有的参数，该类在实际的`StokesImmersedProblem`类之前被初始化，并将其作为`const`引用传递给主类。   


该类的构造函数负责该类的成员与ParameterHandler中的相应条目之间的连接。由于使用了[2.x.209]方法，这种连接是微不足道的，但要求这个类的所有成员都是可写的。

[1.x.71] 



然而，由于这个类将作为 "const "引用传递给StokesImmersedProblem类，我们必须确保我们仍然可以在这里定义的Function类派生的对象中正确设置时间。为了做到这一点，我们声明[2.x.210]和[2.x.211]成员都是 "可变 "的，并定义以下的小辅助方法，将其时间设置为正确的值。

[1.x.72] 



该类的其余部分主要由描述模拟及其离散化细节的成员变量组成。下面的参数是关于输出的位置、空间和时间离散化（默认是[2.x.212]Taylor-Hood离散化，该离散化对速度使用2度的多项式），以及在我们再次生成图形输出之前应该经过多少时间步骤。

[1.x.73] 



我们允许每个网格独立地进行细化。在本教程中，实体网格上没有物理学的解析，其速度被作为基准点给出。然而，在本教程中加入一些弹性模型，并将其转化为一个完全成熟的FSI求解器，是相对简单的事情。

[1.x.74] 



为了提供对流体领域的粗略描述，我们使用extract_rtree_level()方法应用于流体三角结构中每个局部拥有的单元的边界盒树。树的级别越高，提取的边界盒数量就越多，对流体领域的描述也就越准确。然而，大量的边界盒也意味着巨大的通信成本，因为边界盒的收集是由所有进程收集的。

[1.x.75] 



方程中使用的唯一两个数值参数是流体的粘度，以及Nitsche公式中使用的惩罚项[2.x.213]。

[1.x.76] 



默认情况下，我们创建一个没有着色的hyper_cube，并且我们使用同质的Dirichlet边界条件。在这个集合中，我们存储了在设置边界条件时使用的边界ID。

[1.x.77] 



我们在此说明另一种从参数文件中创建Triangulation的方法，该方法[2.x.214]接收GridGenerator命名空间中的函数名称，其参数为一个字符串，代表参数的元组。     


在[2.x.215]类中详细解释了将参数从字符串解析成字符串的机制，该类用于将字符串转换为大多数基本STL类型（向量、映射、图元）和基本deal.II类型（点、张量、BoundingBox等）。     


一般来说，可以用等级1的统一元素表示的对象（即[2.x.216] Point<dim>, [2.x.217] 等）是用逗号分隔的。额外的等级采取分号，允许你将字符串解析为[2.x.218]或例如[2.x.219]类型的对象，如`0.0, 0.1; 0.1, 0.2`。这个字符串可以被解释为两个Point对象的向量，或者一个双数向量的向量。     


当条目不统一时，比如在元组的情况下，我们用冒号来分隔各个条目。例如，像`5: 0.1, 0.2`这样的字符串可以用来解析一个类型为[2.x.220] Point<2>>的对象或者一个[2.x.221] [2.x.222] 的对象。      


在我们的例子中，大多数参数是点对象（代表中心、角、细分元素等）、整数值（细分的数量）、双倍值（半径、长度等）或布尔选项（如许多GridGenerator函数采取的`colorize`选项）。     


在下面的例子中，我们设置了合理的默认值，但这些值可以在运行时通过选择GridGenerator命名空间的任何其他支持的函数来改变。如果GridGenerator函数失败，本程序将把网格的名称解释为vtk网格文件名，把参数解释为从manifold_id到描述域的几何形状的CAD文件的映射。每个CAD文件都将被分析，并根据CAD文件本身的内容生成OpenCASCADE命名空间的Manifold。     


为了尽可能的通用，我们对每一个生成的网格都要这样做：流体网格、固体网格，但也包括也使用三角法生成的示踪粒子。

[1.x.78] 



同样地，我们允许不同的局部细化策略。特别是，我们限制了细化水平的最大数量，以控制流体网格的最小尺寸，并保证它与实体网格兼容。细化级数的最小值也得到了控制，以确保在流动的大部分地区有足够的精度。此外，我们根据流体速度场的标准误差估计器进行局部细化。     


我们允许用户选择两种最常见的细化策略，即 "固定数 "或 "固定分数"，这些策略参考了[2.x.223]和[2.x.224]的方法。      


细化可以每隔几步时间进行，而不是连续进行，我们通过`细化_频率`参数来控制这个值。

[1.x.79] 



最后，以下两个函数对象被用来控制斯托克斯流的源项和我们移动固体物体的角速度。在一个更现实的模拟中，固体速度或其变形将来自于固体域上的辅助问题的解决。在这个例子中，我们把这部分放在一边，只是在浸没的固体上沿Z轴施加一个固定的旋转速度场，由一个可以在参数文件中指定的函数控制。

[1.x.80] 



剩下的任务是声明我们在输入文件中可以接受哪些运行时参数。我们把参数分成不同的类别，通过把它们放在ParameterHandler类的不同部分。我们首先在全局范围内声明StokesImmersedProblem使用的所有全局参数。

[1.x.81] 



下一节专门讨论用于创建各种网格的参数。我们将需要三种不同的三角形。流体网格 "用于定义流体领域，"固体网格 "定义固体领域，"粒子网格 "用于分布一些示踪粒子，这些粒子随速度漂移，只作为被动示踪物使用。

[1.x.82] 



最后的任务是修正右侧函数的默认尺寸，并定义一个有意义的默认角速度，而不是零。

[1.x.83] 



一旦角速度被提供为一个函数对象，我们就通过下面这个派生自函数类的类来重构点状实体速度。它通过假设实体以给定的角速度绕原点（或三维中的[2.x.225]轴）旋转，提供实体在给定位置的速度值。

[1.x.84] 



我们假设角速度是沿Z轴方向的，也就是说，我们把实际的角速度模拟成二维旋转，而不考虑`spacedim`的实际值。

[1.x.85] 



同样地，我们假设实体位置可以在每个时间步长明确计算，利用角速度的知识。我们计算固体粒子的确切位置，假设固体的旋转量等于时间步长乘以在`p'点计算的角速度。

[1.x.86] 




[1.x.87] [1.x.88] 




现在我们准备介绍我们教程程序的主类。像往常一样，除了构造函数外，我们只留下一个公共入口：`run()`方法。其他的都是 "私有 "的，并通过run方法本身进行访问。

[1.x.89] 



下一节包含了该类的 "私有 "成员。第一个方法类似于前面例子中的方法。然而，它不仅负责生成流体的网格，而且还负责生成固体的网格。第二个方法是计算最大的时间步长，保证每个粒子最多移动一个单元。这对于确保[2.x.226]能够找到粒子最终所在的单元是很重要的，因为它只能从一个单元看向它的近邻（因为在并行设置中，每个MPI进程只知道它拥有的单元以及它们的近邻）。

[1.x.90] 



接下来的两个函数初始化该类中使用的[2.x.227]对象。我们有两个这样的对象。一个代表被动追踪器，用于绘制流体粒子的轨迹，而另一个代表固体的材料粒子，它们被放置在固体网格的正交点上。

[1.x.91] 



设置的其余部分分为两部分。以下两个函数中的第一个函数创建了每次模拟需要的所有对象，而另一个函数则设置了所有需要在每个细化步骤中重新初始化的对象。

[1.x.92] 



装配例程与其他Stokes装配例程非常相似，但Nitsche限制部分除外，它利用其中一个粒子处理程序在流体域的非匹配部分进行积分，对应于固体的位置。我们将这两部分分成两个独立的函数。

[1.x.93] 



其余的函数求解线性系统（看起来与[2.x.228]中的线性系统几乎相同），然后对解进行后处理。refine_and_transfer()方法仅在每一个 "refinement_frequency "步骤中被调用，以适应网格，并确保所有在细化前的时间步骤中计算的场都正确地转移到新的网格中。这包括矢量场，以及粒子信息。同样地，我们只在每一个`输出_频率`的步骤中调用两个输出方法。

[1.x.94] 



然后让我们继续讨论该类的成员函数。第一个是处理从参数文件中读取的运行时参数。如前所述，我们通过使其成为一个 "const "引用，确保我们不能从这个类中修改这个对象。

[1.x.95] 



然后还有MPI通信器对象，如果程序是并行运行的，我们将用它来让进程在网络上发送信息，还有`pcout`对象和定时器信息，也被[2.x.229]采用，例如。

[1.x.96] 



接下来是与 [2.x.230] 有关的主要创新之一。这里我们假设固体和流体都是完全分布的三角形。这使得问题可以扩展到非常大的自由度，代价是要沟通所有非匹配三角形之间的重叠区域。这一点特别棘手，因为我们没有对两个三角形的各个子域的相对位置或分布做出假设。特别是，我们假设每个进程只拥有 "solid_tria "的一部分，以及 "fluid_tria "的一部分，不一定在同一个物理区域，也不一定重叠。     


原则上，我们可以尝试创建初始分区，使每个过程的子域在固体和流体区域之间重叠。然而，这种重叠在模拟过程中会被破坏，我们将不得不一次又一次地重新分配DoF。我们在本教程中采用的方法更加灵活，而且成本也不高。我们在模拟开始时进行两次全对全的通信，以交换每个处理器的几何占用信息（近似的）（通过边界框的集合完成）。     


这个信息被[2.x.231]类用来交换（使用某对某的通信模式）所有的粒子，因此每个进程都知道生活在它所拥有的流体子域所占区域上的粒子。     


为了把重叠的区域联系起来，我们利用了ParticleHandler类中实现的设施。

[1.x.97] 



接下来是对使用中的有限元的描述，以及适当的正交公式和相应的DoFHandler对象。对于目前的实现，只有`fluid_fe`是真正必要的。为了完整起见，也为了便于扩展，我们还保留了`solid_fe`，但它被初始化为FE_Nothing有限元空间，即没有自由度的空间。     


我们将这两个有限元空间声明为[2.x.232]对象，而不是普通的成员变量，以便在 "StokesImmersedProblemParameters "被初始化后生成它们。特别是，它们将在 "initial_setup() "方法中被初始化。

[1.x.98] 



与[2.x.233]中的做法类似，我们使用一个块系统来处理问题的斯托克斯部分，并且非常密切地遵循那里的做法。

[1.x.99] 



利用这种自由度的划分，我们就可以定义描述有关线性系统所需的所有对象。

[1.x.100] 



让我们转到这个程序的粒子方面。有两个[2.x.234]对象用于耦合固体和流体，以及描述被动追踪器。在许多方面，这些对象的作用类似于离散化中使用的DoFHandler类，也就是说，它们提供了一个粒子的枚举，并允许查询每个粒子的信息。

[1.x.101] 



对于每个示踪粒子，我们需要计算其当前位置的速度场，并使用离散时间步进方案更新其位置。我们使用分布式线性代数对象来做这件事，这些对象存储了每个粒子的位置或速度的坐标。也就是说，这些向量有`tracer_particle_handler.n_global_particles() * spacedim`项，我们将以一种方式来存储这些向量的一部分，以便在所有进程中进行划分。(隐含地，我们在这里假设每个粒子的`spacedim'坐标被存储在向量的连续条目中)。因此，我们需要确定每个向量条目的所有者是谁。我们将这个所有者设定为等于在时间[2.x.235]产生该粒子的进程。这个信息被储存在每个进程的`locally_owned_tracer_particle_coordinates`索引集中。     


一旦粒子被分配到与拥有粒子所在区域的进程相匹配，我们将需要从该进程读取相应的速度场的权限。我们通过填充一个只读的速度矢量场来实现这一点，该矢量场包含了幽灵项中的相关信息。这是通过`locally_relevant_tracer_particle_coordinates`索引集来实现的，该索引集记录了模拟过程中的变化情况，也就是说，它记录了当前进程拥有的粒子最终在哪里，以及谁拥有最终在我的子域中的粒子。     


虽然这不是最有效的策略，但我们保持这种方式是为了说明事情在真正的流体-结构相互作用（FSI）问题上是如何运作的。如果一个粒子与一个特定的固体自由度相联系，我们就不能自由选择谁拥有它，我们必须把这个信息传达给周围的人。我们在这里说明了这一点，并表明通信模式是点对点的，就算法的总成本而言可以忽略不计。     


然后，基于这些细分定义的向量被用来存储粒子的速度（只读，有幽灵条目）和它们的位移（读/写，没有幽灵条目）。

[1.x.102] 



本教程程序的关键点之一是两个独立的[2.x.236]物体之间的耦合，其中一个物体可能相对于另一个物体运动和变形（可能有较大的变形）。当流体和实体的三角形都是[2.x.237]类型时，每个进程只能访问这两个三角形中每个单元的局部拥有的部分。如上所述，一般情况下，本地拥有的域是不重叠的。     


为了允许不重叠的[2.x.238]对象之间有效地交换信息，该库的一些算法要求用户以每个进程的轴对齐边界盒集合的形式，提供三角形的本地拥有部分所占区域的粗略描述，这些边界盒提供了域的本地拥有部分的全覆盖。这种信息就可以用于这样的情况：人们需要向已知位置周围的单元格的所有者发送信息，而不知道这个所有者实际上是谁。但是，如果我们知道每个进程拥有的几何区域或体积的边界盒集合，那么我们就可以确定可能拥有该位置所在单元的所有进程的一个子集：即其边界盒包含该点的所有进程。与其向所有进程发送与该位置相关的信息，不如只向具有点对点通信基元的一小部分进程发送信息。你会注意到，这也允许典型的时间与内存的权衡：我们愿意存储的关于每个进程拥有的区域的数据越多--以更精细的边界盒信息的形式--我们必须执行的通信就越少。     


我们通过收集一个向量（长度为[2.x.239]的BoundingBox对象的向量）来构建这些信息。我们使用extract_rtree_level()函数填充这个向量，并允许用户选择要提取的树的哪一级。这个 "级别 "对应的是与边界框重叠的区域应该有多粗/多细。     


作为一个例子，这是由extract_rtree_level()函数应用于一个二维超球，分布在三个过程中所提取的东西。每张图片中，绿色显示的是与每个进程上的三角形局部拥有的单元相关的边界盒，紫色显示的是从rtree中提取的边界盒。     


 [2.x.240] [2.x.241] [2.x.242]。      


我们将这些盒子存储在一个全局成员变量中，在每个细化步骤中都会更新。

[1.x.103] 




[1.x.104] [1.x.105]。





[1.x.106] [1.x.107]。




在构造函数中，我们创建了mpi_communicator以及流体和实体的三角形和dof_handler。使用mpi_communicator，构建ConditionalOStream和TimerOutput对象。

[1.x.108] 



为了生成网格，我们首先尝试使用deal.II GridGenerator命名空间中的函数，通过利用[2.x.243]如果这个函数失败，那么我们使用以下方法，名称被解释为文件名，参数被解释为从流形ID到CAD文件的映射，并使用OpenCASCADE命名空间设施转换为流形描述符。在顶部，我们把文件读成一个三角图。

[1.x.109] 



如果我们走到这一步，那么三角图已经读完了，我们就可以给它附加正确的流形描述了。只有在deal.II支持OpenCASCADE的情况下，我们才会执行接下来的几行代码。对于地图中的每个条目，我们尝试打开相应的CAD文件，分析它，并根据其内容，选择一个[2.x.244]（如果CAD文件包含一个`TopoDS_Edge'或一个`TopoDS_Wire'）或一个[2.x.245]，如果文件包含一个面。请注意，如果CAD文件不包含单一的线、边或面，在生成Manifold时将会抛出一个断言。     


我们使用[2.x.246]类来为我们完成从字符串到流形ID和文件名之间的映射的转换。

[1.x.110] 



现在我们检查 "形状 "中包含多少个面。OpenCASCADE本质上是三维的，所以如果这个数字是零，我们就把它解释为线型流形，否则就解释为[2.x.247]在`spacedim`=3时，或[2.x.248]在`spacedim`=2时。

[1.x.111] 



我们使用这个技巧，因为[2.x.249]只在spacedim=3下实现。上面的检查确保了事情的实际运作是正确的。

[1.x.112] 



我们也允许基于单个NURBS补丁的二维空间的曲面描述。要做到这一点，CAD文件必须包含一个单一的`TopoDS_Face`。

[1.x.113] 



现在让我们把东西放在一起，并制作所有必要的网格。如上所述，我们首先尝试在内部生成网格，如果我们失败了（即，如果我们最终进入 "catch "子句），那么我们就继续使用上述函数。   


我们对流体和固体网格都重复这个模式。

[1.x.114] 




[1.x.115] [1.x.116] 




一旦实体和流体网格被创建，我们开始填充[2.x.250]对象。我们要处理的第一个对象是用来跟踪流体中的被动追踪器的。这些东西只是沿途传送，从某种意义上说，它们的位置并不重要：我们只是想用它们来观察流体被传送的位置。我们可以使用任何我们选择的方式来确定它们的初始位置。一个方便的方法是将初始位置创建为我们所选择的形状的网格顶点，这个选择由参数文件中的一个运行时参数决定。   


在这个实现中，我们使用FE_Q有限元空间的支持点来创建追踪器，这些支持点定义在一个临时网格上，然后被丢弃。在这个网格中，我们只保留与支撑点相关的[2.x.251]对象（存储在[2.x.252]类中）。   


[2.x.253]类提供了插入一组粒子的可能性，这些粒子实际生活在活动过程所拥有的域的一部分。然而，在这种情况下，这个功能是不够的。作为任意网格（与流体网格不匹配）上的FE_Q对象的本地拥有的支持点所产生的粒子没有理由位于流体网格的本地拥有的子域的同一物理区域内。事实上，这种情况几乎不会发生，特别是由于我们要跟踪粒子本身发生了什么。   


在粒子入室方法（PIC）中，通常的习惯是将粒子的所有权分配给粒子所在的过程。在本教程中，我们说明了一种不同的方法，如果想跟踪与粒子相关的信息，这种方法是有用的（例如，如果一个粒子与一个特定的自由度相关，而这个自由度是由一个特定的过程所拥有的，不一定是在任何特定时间拥有该粒子所在的流体单元的同一个过程）。在这里使用的方法中，粒子的所有权在开始时被分配一次，每当原始所有者需要从拥有粒子所在单元的进程中获得信息时，就会发生一对一的通信。我们确保使用初始粒子分布来设置粒子的所有权，并在程序的整个执行过程中保持相同的所有权。   


有了这个概述，让我们看看这个函数做了什么。在顶部，我们创建了一个临时的三角形和DoFHandler对象，我们将从中获取初始粒子位置的节点位置。

[1.x.117] 



这就是事情开始变得复杂的地方。由于我们可以在并行环境中运行这个程序，每个并行进程现在都会创建这些临时三角形和DoFHandler。但是，在完全分布式三角形中，活动进程只知道本地拥有的单元，而不知道其他进程是如何分布自己的单元的。这对于上面创建的临时三角形以及我们想嵌入粒子的流体三角形都是如此。另一方面，一般来说，这两个三角形的局部已知部分不会重合。也就是说，我们将从临时网格的节点位置创建的粒子的位置是任意的，并且可能落在当前进程无法访问的流体三角结构的区域内（即流体领域中细胞是人工的区域）。为了了解将这些粒子发送给谁，我们需要对流体网格在处理器中的分布有一个（粗略的）概念。     


我们通过以下方式来构建这一信息：首先建立一个以本地拥有的单元为边界的盒子索引树，然后提取该树的第一层之一。

[1.x.118] 



现在每个进程都有一个完全包围所有本地拥有的进程的界线盒集合（但可能与其他进程的界线盒重叠）。然后，我们在所有参与的进程之间交换这一信息，以便每个进程都知道所有其他进程的边界盒。     


有了这些知识，我们就可以将`tracer_particle_handler`初始化到流体网格，并从（临时）tracer particles triangulation的支持点生成粒子。这个函数调用使用了我们刚刚构建的`global_bounding_boxes`对象，以确定将位置来自`particles_dof_handler`的本地拥有部分的粒子发送到哪里。在这个调用结束时，每个粒子将被分配到正确的进程（即拥有粒子所在的流体单元的进程）。在这一点上，我们也将它们的编号输出到屏幕上。

[1.x.119] 



每个如此创建的粒子都有一个唯一的ID。在下面的算法中的某个时刻，我们将需要包含每个粒子的位置和速度信息的向量。这个向量的大小为`n_particles * spacedim`，我们必须以一种方式来存储这个向量的元素，以便每个并行进程 "拥有 "那些对应于它所拥有的粒子坐标的元素。换句话说，我们必须在所有进程中划分0和`n_particles * spacedim`之间的索引空间。我们可以通过查询`tracer_particle_handler`的本地相关粒子的ID来做到这一点，并构建需要的索引，将所有粒子的位置和速度存储在一个（平行分布的）矢量中，其中我们隐含地假设我们将每个位置或速度的坐标存储在`spacedim`连续的矢量元素中（这就是[2.x.254]函数的作用）。

[1.x.120] 



在模拟开始时，所有粒子都在它们的原始位置。当粒子移动时，它们可能会穿越到另一个进程所拥有的领域的某个部分。如果发生这种情况，当前的进程就会正式保持对粒子的 "所有权"，但可能需要从粒子落地的进程中读取访问。我们将这一信息保存在另一个索引集中，该索引集存储了当前进程的子域中的所有粒子的索引，不管它们是否一直在这里。     


保留这个索引集使我们能够利用线性代数类来进行所有关于粒子的位置和速度的通信。这模拟了在固体域中解决另一个问题的情况下会发生的情况（如在流体-结构相互作用中。在后一种情况下，实体域上的额外DOFs将被耦合到流体域中发生的情况。

[1.x.121] 



最后，我们要确保在细化时，粒子被正确转移。在进行局部细化或粗化时，粒子将降落在另一个单元。原则上我们可以在细化后重新分配所有的粒子，然而这将是过于昂贵的。     


[2.x.255]类有一种方法可以在细化时将信息从一个单元转移到它的子单元或它的父单元，而不需要重构整个数据结构。这是通过向三角结构注册两个回调函数来实现的。这些函数将在细化即将发生和刚刚发生时收到一个信号，并将以最小的计算成本将所有信息转移到新的细化网格中。

[1.x.122] 



与我们对被动追踪器所做的类似，我们接下来设置追踪实体网格正交点的粒子。这里的主要区别是，我们还想给每个粒子附加一个权重值（正交点的 "JxW "值），这样我们即使不直接访问原始实体网格也可以计算积分。   


这是通过利用[2.x.256]类的 "属性 "概念实现的。我们可以（以一种有效的内存方式）在一个[2.x.258]对象内为每个[2.x.257]对象存储任意数量的`双`数。我们利用这种可能性来存储实体网格的正交点的JxW值。   


在我们的例子中，我们只需要为每个粒子存储一个属性：实体网格上的积分的JxW值。这在构造时被作为最后一个参数传递给solid_particle_handler对象 

[1.x.123] 



我们在本地生成的粒子数等于本地拥有的单元总数乘以每个单元中使用的正交点的数量。我们将所有这些点存储在一个向量中，并将其相应的属性存储在一个向量的向量中。

[1.x.124] 



我们以处理示踪粒子的同样方式进行，重新使用计算出的包围盒。然而，我们首先检查`global_fluid_bounding_boxes`对象是否已经被填充。这里当然应该是这样的，因为这个方法是在初始化示踪粒子的方法之后调用的。然而，我们要确保，如果将来有人决定（无论出于什么原因）先初始化实体粒子处理程序，或者只复制教程的这一部分，当事情没有按照预期进行时，会抛出一个有意义的异常。     


由于我们已经存储了正交点的位置，我们可以使用这些位置直接使用`solid_particle_handler`插入粒子，而不必通过[2.x.259]函数。

[1.x.125] 



和前面的函数一样，我们最后要确保在细化时，粒子被正确转移。

[1.x.126] 




[1.x.127] [1.x.128]。




我们设置了有限元空间和整个步骤中使用的正交公式。对于流体，我们使用Taylor-Hood元素（例如[2.x.260] ）。由于我们没有解决固体领域的任何方程，所以产生了一个空的有限元空间。这个程序的一个自然扩展是解决流体结构的相互作用问题，这就要求`solid_fe`使用更有用的FiniteElement类。   


像其他许多函数一样，我们在这里存储了进行操作所需的时间。当前的函数把它的时间信息放到一个标签为 "初始设置 "的部分。在不同的函数中对这个定时器进行了许多其他的调用。它们允许监测每个单独函数的绝对和相对成本，以确定瓶颈。

[1.x.129] 



我们接下来构建分布式块状矩阵和向量，用于解决问题中出现的线性方程。这个函数改编自[2.x.261]，我们参考这个步骤进行彻底解释。

[1.x.130] 




[1.x.131][1.x.132] 




我们组装系统矩阵、预处理矩阵和右手边。该代码改编自[2.x.262]，基本上是[2.x.263]也有的，如果你知道斯托克斯方程是什么样子的，那就是相当标准的。

[1.x.133] 



下面的方法是处理因对叶轮施加速度而产生的惩罚项的方法。从某种意义上说，它是本教程的核心，但它相对简单。这里我们利用`solid_particle_handler`来计算Nitsche限制或嵌入域中的惩罚。

[1.x.134] 



我们对所有的局部粒子进行循环。虽然这可以直接通过循环所有的单元来实现，但这将迫使我们循环许多不包含粒子的单元。因此，我们在所有的粒子上循环，但是，我们得到粒子所在的单元格的参考，然后在该单元格内循环所有的粒子。这使得我们能够跳过不包含粒子的单元格，但又能集合每个单元格的局部矩阵和rhs来应用Nitsche的限制。一旦我们完成了一个单元格上的所有粒子，我们就将`粒子`迭代器推进到当前单元格上的粒子的末端（这是`while`循环主体的最后一行）。

[1.x.135] 



我们从粒子本身得到一个指向粒子所在单元的迭代器。然后，我们就可以像通常那样，在系统矩阵和右手边组装附加项了。

[1.x.136] 



因此，然后让我们得到位于这个单元格上的单元格的集合，并对它们进行迭代。从每个粒子中，我们收集该粒子的位置和参考位置，以及附加在该粒子上的额外信息。在本例中，这些信息是用于生成粒子的正交点的 "JxW"。         


利用这些信息，我们可以将正交点的贡献加入到local_matrix和local_rhs中。我们可以通过使用每个粒子的参考位置，轻松地评估每个粒子位置上的形状函数值。

[1.x.137] 




[1.x.138][1.x.139] 。




这个函数用FGMRES求解线性系统，有一个对角线块的预处理和一个对角线块的代数多网格（AMG）方法。该预处理程序对[2.x.264]（即速度-速度）块应用V循环，对[2.x.265]块应用质量矩阵的CG（这是我们对舒尔补码的近似值：上面组装的压力质量矩阵）。

[1.x.140] 




[1.x.141] [1.x.142] 。




我们以完全标准的方式来处理网格细化问题。

[1.x.143] 




[1.x.144] [1.x.145]。




我们使用deal.II的标准并行功能在流体域上输出结果（速度和压力）。编写一个压缩的vtu文件，将所有处理器的信息聚集在一起。另外写一个`.pvd`记录，将物理时间与vtu文件联系起来。

[1.x.146] 



同样，我们通过[2.x.266]对象将粒子（无论是来自实体还是追踪器）写成单一的压缩vtu文件。这个简单的对象不写附加在粒子上的 "属性 "信息，而只写它们的id--但是，无论如何，我们并不关心这些粒子位置的 "JxW "值，所以我们可能想要可视化的信息并没有丢失。

[1.x.147] 




[1.x.148][1.x.149] 




这个函数现在负责协调整个模拟过程。它与其他时间相关的教程程序非常相似--以[2.x.267]或[2.x.268]为例。在开始时，我们输出一些状态信息，同时将所有当前参数保存到输出目录中的一个文件中，以便于重现。

[1.x.150] 



然后我们开始时间循环。我们在第一个循环中初始化模拟的所有元素 

[1.x.151] 



在第一个时间步长后，我们在每个时间步长的开始时对固体体进行位移，以考虑到它已经移动的事实。

[1.x.152] 



为了更新系统的状态，我们首先插值示踪粒子位置的流体速度，并采用天真的显式欧拉方案对无质量示踪粒子进行漂移。

[1.x.153] 



使用这些新的位置，我们就可以组装斯托克斯系统并求解它。

[1.x.154] 



有了适当的频率，我们就可以把固体粒子、示踪粒子和流体域的信息写进文件，以便进行可视化，并通过调整网格来结束时间步骤。

[1.x.155] 




[1.x.156][1.x.157] 。




代码的其余部分，即`main()`函数，是标准的，除了对输入参数文件的处理。我们允许用户指定一个可选的参数文件作为程序的参数。如果没有指定，我们就使用默认文件 "parameters.prm"，如果不存在，我们就创建这个文件。文件名首先被扫描为字符串 "23"，然后是 "3"。如果文件名包含字符串 "23"，问题类将分别以模板参数2和3进行实例化。如果只找到字符串 "3"，那么两个模板参数都被设置为3，否则都被设置为2。




如果程序被调用时没有任何命令行参数（即`argc==1`），那么我们默认只使用 "参数.prm"。

[1.x.158] 

[1.x.159][1.x.160]。


运行本程序的目录中包含一些样本参数文件，你可以用它们来重现本节介绍的结果。如果你没有在命令行中指定参数文件作为参数，程序将默认尝试读取文件"`parameters.prm`"，并执行二维版本的代码。正如在源代码的讨论中所解释的那样，如果你的文件名包含字符串 "23"，那么程序将运行一个三维的问题，其中有一个共维的沉浸固体。如果文件名中包含 "3"，那么它将运行一个三维问题，同维度的沉浸实体为零，否则它将运行一个二维问题，同维度的沉浸实体为零。

不管具体的参数文件名是什么，如果指定的文件不存在，当你执行程序时，你会得到一个异常，即找不到这样的文件。

[1.x.161] 



然而，正如错误信息已经指出的，触发该异常的代码也将生成指定的文件（"`parameters.prm`"在本例中），该文件仅仅包含该程序关心的所有参数的默认值（对于正确的尺寸和辅助尺寸，根据文件名中是否包含字符串 "23 "或 "3"）。通过检查默认参数文件，我们看到以下内容。

[1.x.162] 



如果你现在运行程序，你会在参数`Output directory`（默认为当前目录）指定的目录中得到一个名为`parameters_22.prm`的文件，其中包含上述参数的简短版本（没有注释和文档），记录了所有用于运行程序的参数。

[1.x.163] 



首先创建`parameters.prm`文件（程序第一次运行时），然后创建`output/parameters_22.prm`（每次用现有的输入文件运行程序时），其理由是你可能想把大多数参数保留为默认值，只修改其中的一小部分，同时仍然能够重现结果，检查特定模拟使用了哪些参数。一般来说，将用于模拟的参数文件与模拟输出一起存储是很好的科学实践，这样你就可以在以后的时间里重复同样的运行，如果需要的话。

另一个原因是输入文件可能只包含那些与默认值不同的参数。例如，你可以在这个教程程序中使用以下（完全有效的）参数文件。

[1.x.164] 

你可以用Q3/Q2的Taylor-Hood有限元来运行程序，运行101步，使用Nitsche惩罚为`10`，并将所有其他参数保持为默认值。输出目录不仅包含了这些参数的记录，而且包含了仿真中使用的所有参数。你可以在生成的文件`parameters_22.prm`中检查所有其他的参数。


[1.x.165][1.x.166] 


默认的问题是生成一个同维度的零叶轮，由一个旋转的矩形网格组成，在一个方向上旋转半个时间单位，在相反方向上旋转半个时间单位，恒定的角速度等于 [2.x.269] 。因此，叶轮做了半个旋转，并返回到原来的位置。下面的动画显示了速度的大小，固体叶轮和示踪粒子的运动。


 [2.x.270]  

在一个核心上，程序的输出将看起来像下面这样。

[1.x.167] 



你可能会注意到，组装耦合系统比组装斯托克斯部分更昂贵。这在很大程度上取决于用于应用Nitsche限制的高斯点（固体粒子）的数量。在目前的情况下，所使用的示踪粒子的数量相对较少。因此，跟踪它们的运动是相对便宜的。

下面的影片显示了解决方案随时间变化的情况。

[1.x.168] 



这部电影显示了灰色的旋转障碍物（实际上是用足够大的点绘制的固体粒子的叠加，使它们重叠），[1.x.169]为浅色（包括在模拟过程中特定时间形成的角顶点），而示踪粒子为蓝色调。

仿真结果显示，在结束时间，示踪粒子已经在一定程度上回到了原来的位置，尽管它们已经被流场所扭曲。下面的图片比较了粒子在一个时间单位的流动后的初始和最终位置。

 [2.x.271]  

在这种情况下，我们看到在叶轮扫过的体积之外的示踪剂颗粒已经回到了非常接近它们的初始位置，而在扫过的体积内的颗粒则稍微变形了一些。这种变形是非物理性的。它是由用于平移粒子的显式欧拉方案引起的数值误差、由虚构领域引起的精度损失以及最后由斯托克斯方程的离散化误差引起的。前两个错误是造成这种变形的主要原因，它们可以通过使用更细的网格和更低的时间步长来缓解。


[1.x.170][1.x.171] 


为了玩一玩，我们将虚构的领域复杂化（取自https://grabcad.com/library/lungstors-blower-1），并在三个空间维度上运行共维一模拟，使用以下"`参数_23.prm`"文件。

[1.x.172] 



在这种情况下，定时输出有点不同。

[1.x.173] 



现在，求解器在三维空间中占用了大部分的求解时间，就运行时间而言，粒子运动和Nitsche装配仍然相对不重要。




[1.x.174] 




[1.x.175][1.x.176][1.x.177] 。


目前的教程程序显示了流体和固体之间的单向耦合，其中固体运动是强加的（而不是求解的），并通过利用固体正交点的位置和权重在固体域中读取。

代码的结构已经允许人们通过利用读取固体网格正交点上流体速度值的可能性来实现双向耦合。为了提高MPI通信模式的效率，我们应该将正交点的所有权保持在实体处理器上，该处理器拥有创建正交点的单元。在目前的代码中，通过使用实体分区而不是初始流体分区来定义用于交换正交点信息的向量索引集就足够了。

这使得本教程程序中使用的技术与教程[2.x.272]中介绍的技术相结合，可以解决带有分布式拉格朗日乘数的流体结构相互作用问题，在[2.x.273]对象上。

上面的时间显示，目前的预处理策略对Nitsche惩罚的效果并不好，如果我们想瞄准更大的问题，应该想出一个更好的预处理方法。此外，应该实施检查点重启策略，以允许较长的模拟被中断和恢复，例如在[2.x.274]教程中就有这样做。[1.x.178] [1.x.179] [2.x.275]。 

 [2.x.276] 
