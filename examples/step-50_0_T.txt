 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] , [2.x.3] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14 ][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27] 

 [2.x.4]  

[1.x.28] 

 [2.x.5]  

 [2.x.6] 作为本程序的先决条件，你需要同时安装p4est和PETSc或Trilinos库。在[1.x.29]文件中描述了deal.II与这些附加库的安装情况。


[1.x.30] [1.x.31][1.x.32] 。




这个例子显示了deal.II中的多级函数在并行、分布式网格上的应用，并给出了几何多栅和代数多栅方法的比较。代数多网格(AMG)的预处理程序与 [2.x.7] 中使用的相同。考虑了两种几何多网格（GMG）的预处理方法：一种是类似于 [2.x.8] 中的基于矩阵的版本（但用于并行计算），一种是 [2.x.9] 中讨论的无矩阵版本。我们的目标是找出哪种方法能导致大型并行计算的最佳解算器。

本教程是基于 [2.x.10] 中的一个数值例子。请参阅该出版物，以了解交易.II中多网格实现的详细背景。我们将在下面的文字中总结一些结果。

代数多网格方法显然是最容易用deal.II实现的，因为诸如[2.x.11]和[2.x.12]这样的类本质上是黑箱预处理，即使是并行计算，也只需要几行就可以设置。另一方面，几何多网格方法需要对整个代码库进行修改--不是很多，但必须知道自己在做什么。

这个程序的结果将显示，代数和几何多栅方法的性能大致相当[1.x.33]，而无矩阵的几何多栅方法对于这里所考虑的问题来说要好得多。另一个结论是，当每个处理器的未知数小于20,000个时，基于矩阵的几何多网格方法确实不能很好地扩展。


[1.x.34][1.x.35] 。


我们考虑变系数拉普拉斯的弱式公式 

[1.x.36] 

在域[2.x.13]（二维为L形域，三维为Fichera角）上，如果[2.x.15]，则[2.x.16]。换句话说，[2.x.17]是沿着域的边缘或面跑到重合角的小，这在下图中会看到。

边界条件在整个边界上是[2.x.18]，右手边是[2.x.19] 。我们使用连续的[2.x.20]元素来表示离散的有限元空间[2.x.21]，并使用基于残差的、单元的后验误差估计器[2.x.22]，来自[2.x.23]，有 

[1.x.37] 

来适应性地细化网格。这是KellyErrorEstimator类中使用的Kelly误差估计器的概括，该类驱动大多数其他教程程序中的网格细化）。下图显示了二维的求解和细化： [2.x.24] 在三维中，求解看起来类似（见下文）。在左边你可以看到解决方案，在右边我们展示了靠近域中心的[2.x.25]的切片，显示了自适应细化的网格。 [2.x.26]在二维和三维中，你都可以看到自适应细化拾取了角部奇点和粘度跳跃的内部奇点，而沿分离两个粘度的线的界面（正确）没有被细化，因为它被充分解决了。这是因为由系数的跳跃导致的解的扭结与单元格界面对齐。


[1.x.38][1.x.39] 


如上所述，本程序的目的是展示代数和几何多网格方法在这个问题上的应用，并做到并行计算。使算法扩展到大型并行机器的一个重要组成部分是确保每个处理器有相同的工作量。更准确地说，重要的是没有一小部分处理器比其他处理器有更多的工作，因为如果是这样的话，很大一部分处理器会闲置，等待小部分处理器完成。相反，一小部分处理器的工作大大超过[1.x.40]并不是一个问题，因为大多数处理器继续生产，只有一小部分处理器在完成工作后闲置。) 

对于活跃的网格，我们使用[2.x.27]类，就像在[2.x.28]中做的那样，它使用外部库[1.x.41]中的功能在处理器之间分配活跃单元。对于多级层次结构中的非活动单元，deal.II实现了我们所说的 "第一子规则"，对于层次结构中的每个单元，我们递归地将一个单元的父级分配给第一个子单元的所有者。下面的数字给出了这样一个分布的例子。这里的左图表示使用空间填充曲线划分的二维网格样本的活动单元（这也是p4est用来划分单元的方法）；中间的图片给出了活动网格的树状表示；右图给出了单元的多级层次结构。颜色和数字代表不同的处理器。树上的圆形节点是非活动单元，使用 "长子规则 "进行分配。

 [2.x.29]  

在这个例子的屏幕输出中，包括了一个 "分区效率 "的数值，这个数值由[2.x.30]给出，将用[2.x.31]表示，量化了在多网格层次结构的每一层上没有完美工作平衡所产生的开销。这种不平衡在上面的例子中很明显：虽然[2.x.32]层在三个处理器中的四个单元是尽可能的平衡，但粗略的[2.x.33]层只有一个处理器的工作，而[2.x.34]层只有两个处理器的工作，其中一个的工作是另一个的三倍。

对于定义[2.x.35]，需要注意的是，由于我们使用局部平滑来定义多网格层次（见[2.x.36]"多网格论文 "中对局部平滑的描述），一个单元的细化水平与该单元的多网格水平相对应。现在，让[2.x.37]为[2.x.38]层的单元数（包括活动和非活动单元），[2.x.39]为进程[2.x.40]所拥有的子集。我们还将用[2.x.41]表示处理器的总数量。假设任何一个处理器的工作量与该处理器拥有的单元格数量成正比，每个处理器的最佳工作量为 

[1.x.42] 

接下来，假设每一层的工作都是同步的（即在V型循环的每一层，在进入下一层之前，所有的处理器都必须完成工作），每一层的极限工作由以下公式给出 

[1.x.43] 

和总的并行复杂性 

[1.x.44] 

然后我们将[2.x.42]定义为最佳分区与当前分区的并行复杂度的比率 

[1.x.45] 

对于上面的例子分布，我们有 

[1.x.46] 

然后，该值[2.x.43] [2.x.44]代表我们预期GMG方法（vmults、assembly等）由于网状分区的不平衡而与完全负载平衡的工作负载相比在时间上的系数增加。我们将在下面的结果部分报告一连串的网格，并与观察到的减速进行比较，因为我们的处理器数量越来越大（通常，负载不平衡也会变大）。

这些考虑因素在[2.x.45]中得到了更详细的考虑，其中包含了对分区效率模型和不平衡对GMG V-周期时间的影响的全面讨论。总之，[2.x.46]的值在很大程度上取决于所使用的局部网格细化程度，对于全局细化的网格有一个最佳值[2.x.47]。通常对于自适应细化的网格，用于分配单个网格的处理器数量对[2.x.48]有负面影响，但只到一个平移点，即处理器数量增加时，不平衡度保持相对稳定，进一步细化对[2.x.49]的影响很小。最后，[2.x.50]被证明可以准确地表示出对V型周期的计时所预期的并行扩展的减慢。

应该注意的是，在多级网格之间有可能存在一些异步工作，特别是纯粹的近邻MPI通信，而且可以构建一个自适应网格，由于异步工作 "掩盖 "了不平衡，效率模型将远远高估V型周期的减慢（这假设了各级的同步性）。然而，对于大多数现实的自适应网格来说，预期这种异步工作只会掩盖非常小的一部分不平衡，效率模型会很好地描述减速。


[1.x.47][1.x.48] 。


上面的考虑表明，我们必须期待在deal.II中实现的几何多网格算法的可扩展性有一定的限制，因为即使在网格的最细层是完全负载平衡的情况下，较粗的层也可能不是这样。同时，较粗层的权重较小（[2.x.51]对[2.x.52]的贡献较小），因为较粗层的单元较少，因此对整体运行时间的贡献不如较细层的大。换句话说，较粗层次的不平衡可能不会导致大的影响。

当然，代数多网格方法是基于一种完全不同的方法来创建层次结构的。特别是，他们纯粹是在分析系统矩阵的基础上创建这些层次，并且在作为[2.x.53]和[2.x.54]类基础的hypre和ML/MueLu包中都实现了非常复杂的算法，以确保问题在每个层次上都得到良好的负载平衡。在某种意义上，这些算法比几何多网格方法更简单，因为它们只处理矩阵本身，而不是所有的网格、邻居、父母和其他几何实体的内涵。同时，为了使代数多网格方法能够扩展到非常大的问题，人们也做了很多工作，包括将在某一层次上工作的处理器数量减少到所有处理器的一个子集，如果不这样的话，处理器花在计算上的时间会比花在通信上的时间少。(人们可能会注意到，在几何多网格算法中也有可能实现这些相同的想法，在这些算法中，人们有目的地将一些处理器闲置在较粗的层次上，以减少通信量。只是目前deal.II没有这样做。) 

然而，这些并不是我们在这里通常需要担心的问题。在大多数情况下，我们使用代数多网格方法作为黑箱方法。




[1.x.49][1.x.50] 


如上所述，这个程序可以使用三种不同的方法来求解线性系统：基于矩阵的几何多栅（"MB"），无矩阵几何多栅（"MF"），以及代数多栅（"AMG"）。这个程序所在的目录有后缀为".prm "的输入文件，适用于所有这三个选项，以及2d和3d。

你可以按以下方式执行该程序 

[1.x.51] 

你可以像[1.x.51]那样执行程序，这将从给定的输入文件（这里是`mg_mb_2d.prm`）获取运行时参数。

该程序的目的是并行运行，你可以使用如下命令实现这一点 

[1.x.52] 

如果你想，例如，在四个处理器上运行。(也就是说，如果你有这么多的处理器，程序也可以用`-np 28672`来运行)。[1.x.53] [1.x.54] 。


[1.x.55] [1.x.56] 




包含文件是 [2.x.55] , [2.x.56] , 和 [2.x.57] 的组合。







[1.x.57] 



我们使用与[2.x.58]相同的策略，在PETSc和Trilinos之间切换。







[1.x.58] 



如果你已经安装了PETSc和Trilinos，并且你喜欢在本例中使用PETSc，请将下面的预处理程序定义注释进去或退出。

[1.x.59] 



以下文件用于组装误差估计器，如 [2.x.59] 。

[1.x.60] 




[1.x.61] [1.x.62]。




MatrixFree操作符必须使用[2.x.60]矢量类型。这里我们定义了复制到Trilinos向量的操作，以便与基于矩阵的代码兼容。注意，目前PETSc矢量类型不存在这种功能，所以必须安装Trilinos才能使用本教程中的MatrixFree求解器。

[1.x.63] 



让我们继续讨论我们要解决的问题的描述。我们把右手边的函数设置为1.0。[2.x.61] 返回VectorizedArray的函数被无矩阵代码路径所使用。

[1.x.64] 



接下来的这个类表示扩散系数。我们使用一个可变系数，在任何一个至少有一个坐标小于-0.5的点上为100.0，而在所有其他点上为1.0。如上所述，一个单独的value()返回一个VectorizedArray，用于无矩阵代码。一个@p average()函数计算了一组点的算术平均。

[1.x.65] 



当在MatrixFree框架中使用一个系数时，我们还需要一个函数，为这里的MatrixFree操作符参数提供的一组单元格创建一个系数值表。

[1.x.66] 




[1.x.67] [1.x.68] 




我们将使用ParameterHandler来在运行时传入参数。 结构[2.x.62]解析并存储这些参数，以便在整个程序中进行查询。

[1.x.69] 




[1.x.70] [1.x.71]。




这是该程序的主类。它看起来与 [2.x.63] , [2.x.64] , 和 [2.x.65] 非常相似。对于MatrixFree的设置，我们使用[2.x.66]类，它在内部定义了`local_apply()`, `compute_diagonal()`, 和`set_coefficient()`函数。请注意，多项式的度数是这个类的一个模板参数。这对无矩阵代码来说是必要的。

[1.x.72] 



我们将在整个程序中使用以下类型。首先是基于矩阵的类型，然后是无矩阵类。对于无矩阵的实现，我们使用[2.x.67]中的水平运算符。

[1.x.73] 



关于构造函数的唯一有趣的部分是，除非我们使用AMG，否则我们会构造多网格的层次结构。为此，我们需要在这个构造函数完成之前解析运行时参数。

[1.x.74] 




[1.x.75] [1.x.76] 




与[2.x.68]和[2.x.69]不同，我们将设置分成两部分：setup_system()和setup_multigrid()。下面是大多数教程中常见的主动网格的典型setup_system()函数。对于无矩阵，主动网格的设置类似于 [2.x.70] ；对于基于矩阵（GMG和AMG求解器），其设置类似于 [2.x.71] 。

[1.x.77] 




[1.x.78] [1.x.79] 矩阵式求解器。




该函数为无矩阵和基于矩阵的GMG做多级设置。无矩阵设置类似于[2.x.72]，而基于矩阵的设置类似于[2.x.73]，只是我们必须使用适当的分布式稀疏模式。




在AMG方法中没有调用该函数，但为了安全起见，该函数的主 "开关 "语句还是确保该函数只在已知的多重网格设置下运行，如果该函数被调用到两种几何多重网格方法以外的地方，则抛出一个断言。

[1.x.80] 




[1.x.81] [1.x.82] 




汇编分为三个部分：`assemble_system()`，`assemble_multigrid()`，和`assemble_rhs()`。这里的`assemble_system()`函数组装并存储（全局）系统矩阵和基于矩阵的方法的右手边。它类似于 [2.x.74] 中的装配。




注意，无矩阵方法不执行这个函数，因为它不需要装配矩阵，而是在assemble_rhs()中装配右手边。

[1.x.83] 




[1.x.84] [1.x.85] 




下面的函数为基于矩阵的GMG方法组装和存储多级矩阵。这个函数与[2.x.75]中的函数类似，只是在这里它适用于分布式网格。这个区别在于增加了一个条件，即我们只在本地拥有的水平单元上进行组装，并为每个被建立的矩阵调用压缩（）。

[1.x.86] 




[1.x.87] [1.x.88] 




这个三要素中的最后一个函数为无矩阵方法组装右手边的向量--因为在无矩阵框架中，我们不需要组装矩阵，只需要组装右手边就可以了。我们可以通过从上面的`assemble_system()`函数中提取处理右手边的代码来实现，但是我们决定全部采用无矩阵方法，并使用这种方式进行装配。




结果是一个类似于[2.x.77]中 "使用[2.x.76]避免解决约束 "一节中的函数。




这个函数的原因是MatrixFree算子不考虑非同质的Dirichlet约束，而是将所有Dirichlet约束视为同质的。为了说明这一点，这里的右手边被组装成残差[2.x.78]，其中[2.x.79]是除Dirichlet值以外的零向量。然后在求解的时候，我们可以得出解决方案是 [2.x.80] 。这可以看作是对初始猜测为 [2.x.81] 的线性系统进行的牛顿迭代。下面`solve()`函数中的CG解计算了[2.x.82]，调用`constraints.distribution()`（直接在后面）增加了[2.x.83] 。




显然，由于我们考虑的是一个零Dirichlet边界的问题，我们可以采取类似于[2.x.84] `assemble_rhs()`的方法，但是这个额外的工作允许我们在选择时改变问题的声明。




这个函数在积分循环中有两个部分：通过提交梯度的负值将矩阵 [2.x.85] 的负值应用于 [2.x.86] ，通过提交值 [2.x.87] 添加右手边的贡献。我们必须确保使用`read_dof_values_plain()`来评估[2.x.88]，因为`read_dof_vaues()`会将所有Dirichlet值设为0。




最后，system_rhs向量的类型是[2.x.89]，但MatrixFree类只对[2.x.90]起作用，因此我们必须使用MatrixFree函数性计算右手边，然后使用`ChangeVectorType`命名空间中的函数将其复制到正确类型。

[1.x.89] 




[1.x.90] [1.x.91] 




这里我们设置了多网格预处理程序，测试了单个V型循环的时间，并解决了线性系统。不出所料，这是三种方法差别最大的地方之一。

[1.x.92] 



无矩阵GMG方法的求解器与[2.x.91]相似，除了加入一些接口矩阵，完全与[2.x.92]类似。

[1.x.93] 



将[2.x.93]中的求解向量和右手边复制到[2.x.94]中，这样我们就可以解决。

[1.x.94] 



1个V型周期的计时。

[1.x.95] 



求解线性系统，更新解的重影值，复制回[2.x.95]并分配约束。

[1.x.96] 



基于矩阵的GMG方法的求解器，类似于[2.x.96]，只是使用了雅可比平滑器，而不是SOR平滑器（该平滑器没有并行实现）。

[1.x.97] 



1个V型周期的计时。

[1.x.98] 



解决线性系统和分配约束。

[1.x.99] 



AMG方法的求解器，类似于 [2.x.97] 。

[1.x.100] 



为1个V型周期计时。

[1.x.101] 



解决线性系统和分配约束。

[1.x.102] 




[1.x.103] [1.x.104] 




我们使用FEInterfaceValues类来组装一个误差估计器，以决定哪些单元需要细化。请看介绍中对单元和面积分的确切定义。为了使用该方法，我们为[2.x.98]定义了Scratch和Copy对象，下面的大部分代码在本质上与[2.x.99]中已经设置的一样（或者至少在精神上相似）。

[1.x.105] 



残余单元格的汇编器 [2.x.100]  

[1.x.106] 



脸部术语的汇编器 [2.x.101]  

[1.x.107] 



我们需要对每个内部面进行一次组装，但我们需要确保两个进程都能对本地拥有的单元格和幽灵单元格之间的面项进行组装。这可以通过设置[2.x.102]标志来实现。我们需要这样做，因为我们在这里没有交流误差估计器的贡献。

[1.x.108] 




[1.x.109] [1.x.110]。




我们使用存储在向量[2.x.103]中的单元估计器，并细化固定数量的单元（这里选择的是每一步中大约两倍的DoF数量）。

[1.x.111] 




[1.x.112] [1.x.113] 




output_results()函数与许多教程中的函数相似（例如，见[2.x.104]）。

[1.x.114] 




[1.x.115] [1.x.116]。




和大多数教程一样，这个函数调用上面定义的各种函数来设置、组合、求解和输出结果。

[1.x.117] 



我们只输出GMG方法的水平单元数据（与下面的DoF数据相同）。请注意，分区效率对于AMG来说是不相关的，因为在计算过程中没有分布或使用层次结构。

[1.x.118] 



只为GMG设置多级层次结构。

[1.x.119] 



对于无矩阵方法，我们只组装右手边。对于这两种基于矩阵的方法，我们同时组装活动矩阵和右手边，对于基于矩阵的GMG，只组装多级矩阵。

[1.x.120] 




[1.x.121] [1.x.122] 




这是一个类似于[2.x.105]的主函数，但我们要求用户传递一个.prm文件作为唯一的命令行参数（参见[2.x.106]和ParameterHandler类的文档中关于参数文件的完整讨论）。

[1.x.123] 

[1.x.124][1.x.125] 。


当你使用以下命令运行程序时 

[1.x.126] 

屏幕输出应该如下。

[1.x.127] 

这里，"solve() "函数的时序被分成三部分：设置多网格预处理程序，执行单一的多网格V型循环，以及CG求解器。被计时的V型循环对整个求解来说是不必要的，只是为了让人们了解AMG和GMG的不同成本。同样应该注意的是，当使用AMG求解器时，"工作量不平衡 "不包括在输出中，因为不需要粗网格的层次结构。

本节的所有结果都是在英特尔至强铂金8280（Cascade Lake）节点上收集的，这些节点有56个核心，每个节点有192GB，支持AVX-512指令，允许在8个双倍数上进行矢量化（矢量化仅用于无矩阵计算）。代码是用gcc 7.1.0和intel-mpi 17.0.3编译的。Trilinos 12.10.1被用于基于矩阵的GMG/AMG计算。

然后，我们可以用[2.x.107]所在目录中提供的输入文件来调用程序，收集各种信息。使用这些文件，并调整网格细化步骤的数量，我们可以得出程序的扩展性如何的信息。

下表给出了该程序在256M DoFs和7,168个处理器上的弱扩展时间。(回顾一下，弱缩放在增加处理器数量的同时保持每个处理器的自由度数量不变；也就是说，它考虑的是越来越大的问题。) 这里，[2.x.108]是介绍中的分区效率（也等于1.0/工作量不平衡），"Setup "是设置、设置多重网格、装配和装配多重网格的组合，"Prec "是预处理程序的设置。理想情况下，所有的时间在各个求解器的每个问题大小上保持不变，但是由于分区效率从最大问题大小到最小问题大小从0.371下降到0.161，我们期望看到GMG的时间大约增加[2.x.109]倍。事实上，这与我们真正得到的结果非常接近。

 [2.x.110]  

另一方面，最后一组列中的代数多重网格相对来说不受网格层次不平衡度增加的影响（因为它不使用网格层次），时间的增长反而是由文献中记载的其他因素驱动的（最明显的是代数多重网格方法的某些部分的算法复杂度似乎是[2.x.111]而不是几何多重网格的[2.x.112]）。

上表的短语是，无矩阵的几何多栅方法似乎是解决这个方程的最快方法，即使不是以巨大的优势。另一方面，基于矩阵的方法始终是最差的。

下图提供了每种方法的强大扩展结果，也就是说，我们在越来越多的处理器上解决同一个问题。具体来说，我们考虑在56至28672个处理器上，经过16个网格细化周期（32M DoFs）和19个周期（256M DoFs）后的问题。

 [2.x.113]  

虽然基于矩阵的GMG求解器和AMG的规模相似，求解时间也相似（至少在每个处理器有大量未知数的情况下--比如几万个），但无矩阵的GMG求解器的规模要好得多，求解较细问题的时间与求解较粗网格的AMG求解器大致相同，处理器数量仅为后者的1/8。反之，在相同数量的处理器上，它可以用大约八分之一的时间解决同样的问题。


[1.x.128][1.x.129] 。


[1.x.130][1.x.131] 。


有限元度目前是硬编码为2，见主类的模板参数。这很容易改变。为了测试，最好能切换到一个有参考解的测试问题。这样，你就可以比较错误率了。

[1.x.132][1.x.133] 


一个更有趣的例子是涉及到一个更复杂的粗略网格（见[2.x.114]的启发）。这种情况下的问题是，网格层次的最粗层次实际上是相当大的，我们必须考虑如何有效地解决粗层次的问题。对于代数多网格方法来说，这不是一个问题，因为它们只是继续建立越来越粗的矩阵层次，而不管它们的几何来源）。

在这里的程序中，我们只是用共轭梯度法解决粗级问题，没有任何预处理。如果粗略问题真的很小，这是可以接受的--例如，如果粗略网格有一个单元，那么粗略网格问题在2D中是[2.x.115]矩阵，在3D中是[2.x.116]矩阵；对于我们在当前程序的[2.x.117]形域上使用的粗略网格，这些尺寸在2D中是[2.x.118]，在3D中是[2.x.119]。但是，如果粗略的网格由数百或数千个单元组成，这种方法将不再起作用，并可能开始支配每个V形单元的整体运行时间。一个常见的方法是使用代数多网格预处理程序来解决粗网格问题；然而，这将需要组装粗矩阵（即使是无矩阵版本）作为AMG实现的输入。[1.x.134] [1.x.135] [2.x.120]  

 [2.x.121] 
