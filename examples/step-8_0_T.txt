 [2.x.0][2.x.1] 。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17] 

[1.x.18] [1.x.19] [1.x.20] 




在现实生活中，大多数偏微分方程实际上是方程组。因此，解通常是矢量值的。deal.II库支持这类问题（见[2.x.3]模块中的大量文档），我们将证明那大多是相当简单的。唯一比较复杂的问题是在组装矩阵和右手边，但这些也很容易理解。

 [2.x.4]  

在这个教程程序中，我们将想解决[1.x.21]的问题。它们是拉普拉斯方程的扩展，有一个矢量值的解决方案，描述了受力的刚体在每个空间方向的位移。当然，力也是矢量值的，意味着在每个点上都有一个方向和一个绝对值。

人们可以用多种方式来写弹性方程。其中[2.x.5]是每一点的向量值位移，[2.x.6]是力，[2.x.7]是编码应力-应变关系的第4级张量（即，它有四个指数）--实质上，它代表胡克斯定律中的[1.x.23]，将位移和力联系起来。 在许多情况下，如果我们想要模拟的物体的变形是由不同的材料组成的，那么[2.x.8]将取决于[2.x.9]。

虽然上述方程的形式是正确的，但这并不是它们通常的推导方式。事实上，位移的梯度[2.x.10]（一个矩阵）没有物理意义，而它的对称版本[1.x.24]却有，通常被称为 "应变"。这里和下文中，[2.x.11] 。我们还将使用[1.x.25]，即只要同一个指数在一个方程中出现两次，就意味着对这个指数进行求和；但是，我们将不区分上级和下级指数）。) 有了这个应变的定义，弹性方程就读作[1.x.26]，你可以认为这是拉普拉斯方程对矢量值问题的更自然的概括。首先显示的形式等同于这种形式，因为张量[2.x.12]具有某些对称性，即[2.x.13] ，因此[2.x.14] 。

当然，我们也可以把这些方程写成组件形式。[1.x.27] 

在许多情况下，我们知道所考虑的材料是各向同性的，在这种情况下，通过引入两个系数[2.x.15]和[2.x.16]，系数张量减少为[1.x.28] 。

然后，弹性方程可以以更简单的形式重写。[1.x.29]，然后各自的双线性形式是[1.x.30]，或者也可以把第一项写成分量上的和。[1.x.31] 

 [2.x.17] 按照写法，如果位移很小，我们可以假设[1.x.32]有效，上述方程一般被认为是对三维物体位移的正确描述。在这种情况下，上面的指数[2.x.18]都在集合[2.x.19]上运行（或者，在C++源中，在[2.x.20]上）。然而，按照目前的情况，程序是在2D中运行的，虽然上面的方程在这种情况下也有数学意义，但它们只能描述一个真正的二维实体。特别是，它们不是对[2.x.21]方向无限大的体的[2.x.22]截面的适当描述；这与其他许多二维方程相反，这些方程可以通过假设体在[2.x.23]-方向上有无限大的范围，并且解函数不依赖于[2.x.24]坐标而得到。另一方面，也有二维弹性模型的方程；例如，见维基百科关于[1.x.33]、[1.x.34]和[1.x.35]的文章。

但让我们回到最初的问题上。我们如何组装这样一个方程的矩阵？在[2.x.25]模块的文档中给出了一个很长的答案，其中有许多不同的选择。从历史上看，下面所示的解决方案是该库早期唯一可用的解决方案。事实证明，它也是最快的。另一方面，如果百分之几的计算时间并不重要，还有比下面讨论的更简单、更直观的方法来组装线性系统，但这些方法直到本教程程序首次编写的几年后才可用；如果你对它们感兴趣，可以看一下[2.x.26]模块。

让我们回到如何组装线性系统的问题上来。首先我们需要一些关于形状函数在矢量值有限元情况下如何工作的知识。基本上，这归结为以下几点：让[2.x.27]为我们建立矢量元素的标量有限元素的形状函数的数量（例如，我们将对矢量值有限元素的每个分量使用双线性函数，所以标量有限元素是我们在以前的例子中已经使用过的[2.x.28]元素，以及两个空间维度的[2.x.29]）。此外，让[2.x.30]为矢量元素的形状函数的数量；在两个空间维度上，我们需要[2.x.31]矢量的每个分量的形状函数，所以[2.x.32] 。然后，矢量元素的[2.x.33]个形状函数具有[1.x.36]的形式，其中[2.x.34]是[2.x.35]个单位矢量，[2.x.36]是告诉我们[2.x.37]的哪个分量是不为零的函数（对于每个矢量形状函数，只有一个分量是不为零，其他都是零）。 [2.x.38]描述了形状函数的空间依赖性，它被认为是标量元素的第[2.x.39]个形状函数。当然，虽然[2.x.40]的范围是[2.x.41]，但函数[2.x.42]和[2.x.43]的范围分别为[2.x.44]（在二维）和[2.x.45]。

例如（尽管这种形状函数的顺序不被保证，你也不应该依赖它），下面的布局可以被库使用。[1.x.37] 

这里 [1.x.38] [1.x.39] 。

除了非常罕见的情况，你不需要知道标量元素的哪个形状函数[2.x.46]属于矢量元素的一个形状函数[2.x.47]。因此，让我们定义[1.x.40]，通过它我们可以把向量形状函数写成[1.x.41]，现在你可以安全地忘记函数[2.x.48]，至少在这个例子程序的其余部分。

现在使用这个矢量形状函数，我们可以把离散的有限元解写成 [1.x.42] ，标量系数 [2.x.49] 。如果我们定义一个模拟函数[2.x.50]作为测试函数，我们可以把离散问题写成如下。找出系数[2.x.51]，使[1.x.43]的系数符合要求。

如果我们把双线性形式的定义和[2.x.52]和[2.x.53]的表示插入这个公式。[1.x.44] 

我们注意到，在这里和下文中，指数[2.x.54]在空间方向上运行，即[2.x.55] ，而指数[2.x.56]在自由度上运行。

因此，单元格[2.x.57]上的局部刚度矩阵有以下条目。[1.x.45] 其中[2.x.58] 现在是局部自由度，因此[2.x.59] 。在这些公式中，我们总是取矢量形状函数[2.x.60]的一些分量，当然这些分量是如下给出的（见其定义）。[1.x.46]带有克朗克符号 [2.x.61] 。由于这个原因，我们可以删除一些对[2.x.62]和[2.x.63]的和：[1.x.47] 。



同样，单元格[2.x.64]对右手边向量的贡献是[1.x.48] 。



这就是我们将实现局部刚度矩阵和右手向量的形式。

作为最后的说明：在[2.x.65]示例程序中，我们将重新审视这里提出的弹性问题，并将展示如何在计算机集群上以%并行方式解决它。因此，所产生的程序将能够以更高的精度来解决这个问题，而且如果需要的话，效率更高。此外，在[2.x.66]，[2.x.67]"[2.x.68]"，以及其他一些后来的教程程序中，我们将重新审视一些向量值问题，并展示一些技术，这些技术可能使实际通过上面显示的所有东西更简单，与[2.x.69]等。[1.x.49] [1.x.50]。


[1.x.51] [1.x.52]。




像往常一样，前几个include文件已经是众所周知的了，所以我们将不再评论它们。

[1.x.53] 



在这个例子中，我们需要矢量值的有限元。对这些的支持可以在下面的include文件中找到。

[1.x.54] 



我们将用常规的Q1元素组成矢量值有限元素，像往常一样，可以在这里找到。

[1.x.55] 



这又是C++。

[1.x.56] 



最后一步和以前的程序一样。特别是，就像在[2.x.70]中一样，我们把这个程序所特有的一切都打包到一个自己的命名空间中。

[1.x.57] 




[1.x.58] [1.x.59] 




除了名字之外，主类与[2.x.71]的例子相比几乎没有变化。   


唯一的变化是为[2.x.72]变量使用了一个不同的类。我们现在使用的不是FE_Q这样的具体的有限元类，而是一个更通用的类，FESystem。事实上，FESystem本身并不是一个真正的有限元，因为它没有实现自己的形状函数。相反，它是一个可以用来将其他几个元素堆叠在一起形成一个矢量值的有限元的类。在我们的例子中，我们将组成[2.x.73]对象的矢量值元素，如下图中这个类的构造函数。

[1.x.60] 




[1.x.61] [1.x.62]。




在进入主类的实现之前，我们声明并定义描述右手边的函数。这一次，右手边是矢量值，就像解决方案一样，所以我们将更详细地描述为此所需的变化。   


为了防止出现返回向量没有被设置为正确大小的情况，我们对这种情况进行测试，否则将在函数开始时抛出一个异常。请注意，强制要求输出参数已经具有正确的大小是deal.II中的一个惯例，并且几乎在所有地方都强制执行。原因是，否则我们将不得不在函数开始时检查，并可能改变输出向量的大小。这很昂贵，而且几乎总是不必要的（对函数的第一次调用会将向量设置为正确的大小，随后的调用只需要做多余的检查）。此外，如果我们不能依赖向量已经具有正确大小的假设，检查并可能调整向量的大小是一个不能被删除的操作；这是与Assert调用的契约，如果程序是在优化模式下编译的，则完全可以删除。   


同样，如果由于某种意外，有人试图在只有一个空间维度的情况下编译和运行程序（在这种情况下，弹性方程没有什么意义，因为它们还原为普通的拉普拉斯方程），我们在第二个断言中终止程序。然而，该程序在三维空间中也能正常工作。

[1.x.63] 



该函数的其余部分实现了对力值的计算。我们将使用一个位于(0.5,0)和(-0.5,0)点周围的两个小圆圈（或球体，在3D中）的X方向的恒定（单位）力，以及位于原点周围的Y方向的力；在3D中，这些中心的Z分量也是零。     


为此，让我们首先定义两个对象来表示这些区域的中心。注意，在构建点对象时，所有分量都被设置为零。

[1.x.64] 



如果[2.x.74]处于围绕这些点之一的半径为0.2的圆（球）中，那么将X方向的力设置为1，否则为0。

[1.x.65] 



同样，如果[2.x.75]在原点附近，那么将Y方向的力设置为1，否则为0。

[1.x.66] 




[1.x.67] [1.x.68] 。





[1.x.69] [1.x.70]。




下面是主类的构造函数。如前所述，我们想构造一个由多个标量有限元组成的矢量值有限元（即，我们想构造矢量值元素，使其每个矢量分量由一个标量元素的形状函数组成）。当然，我们想堆叠在一起的标量有限元的数量等于解函数的分量数量，由于我们考虑每个空间方向上的位移，所以是[2.x.76]。FESystem类可以处理这个问题：我们传递给它我们想组成系统的有限元，以及它的重复频率。







[1.x.71] 



事实上，FESystem类还有几个构造函数，可以进行更复杂的操作，而不仅仅是将几个相同类型的标量有限元堆叠在一起；我们将在后面的例子中了解这些可能性。










[1.x.72] [1.x.73]。




设置方程组与[2.x.77]例子中使用的函数相同。DoFHandler类和这里使用的所有其他类都完全知道我们要使用的有限元是矢量值的，并且照顾到了有限元本身的矢量值性。事实上，它们不知道，但这不需要困扰你：因为它们只需要知道每个顶点、直线和单元有多少个自由度，而且它们不问这些自由度代表什么，即所考虑的有限元是矢量值的还是例如在每个顶点有几个自由度的标量Hermite元）。

[1.x.74] 




[1.x.75][1.x.76] 。




这个程序中最大的变化是在创建矩阵和右手边，因为它们是取决于问题的。我们将一步步走过这个过程[2.x.78]，因为它比以前的例子要复杂一些。   


然而，这个函数的前几部分和以前一样：设置一个合适的正交公式，为我们使用的（矢量值的）有限元以及正交对象初始化一个FEValues对象，并声明一些辅助数组。此外，我们还声明了永远相同的两个缩写。 [2.x.79] 和 [2.x.80] 。每个单元的自由度数量，我们现在显然是从组成的有限元中询问，而不是从底层的标量Q1元中询问。这里，它是[2.x.81]乘以Q1元素的每单元自由度数，尽管这不是我们需要关心的明确知识。

[1.x.77] 



正如之前的例子所显示的那样，我们需要一个地方来存储一个单元上所有正交点的系数值。在目前情况下，我们有两个系数，lambda和mu。

[1.x.78] 



那么，我们也可以省略上述两个数组，因为我们将对lambda和mu使用常数系数，可以这样声明。它们都代表函数总是返回常量值1.0。尽管我们可以在矩阵的组合中省略各自的系数，但为了演示，我们在这里使用它们。

[1.x.79] 



和上面的两个常数函数一样，我们将在每个单元格中只调用一次函数right_hand_side，以使事情变得更简单。

[1.x.80] 



现在我们可以开始对所有单元格进行循环。

[1.x.81] 



接下来我们得到正交点的系数值。同样，对于右手边也是如此。

[1.x.82] 



然后将局部刚度矩阵的条目和右手边的向量组合起来。这几乎是一对一地遵循本例介绍中描述的模式。 为数不多的评论之一是，我们可以计算数字[2.x.82] ，即使用下面的[2.x.84]函数调用形状函数[2.x.83]的唯一非零向量分量的索引。         


(通过访问[2.x.86]函数返回值的[2.x.85]变量，你可能已经猜到其中还有更多内容。事实上，该函数返回一个[2.x.87]int，无符号int@></code>，其中第一个元素是[2.x.88]，第二个元素是介绍中也指出的值[2.x.89]，即这个形状函数在这个组件中所有非零的形状函数中的索引，即介绍中的字典[2.x.90]。然而，这并不是我们通常感兴趣的数字）。)          


有了这些知识，我们就可以把本地矩阵的贡献集合起来。

[1.x.83] 



第一个项是[2.x.91] 。注意，[2.x.92]返回正交点q_point处第i个形状函数的唯一非零分量的梯度。梯度的分量[2.x.93]是第i个形状函数的唯一非零矢量分量相对于comp(i)th坐标的导数，由附加的括号访问。

[1.x.84] 



第二个项是[2.x.94] 。我们不需要访问梯度的具体分量，因为我们只需要计算两个梯度的标量乘积，其中<tt>operator*</tt>的重载版本负责，就像以前的例子一样。                         


注意，通过使用<tt>?:</tt>操作符，我们只在<tt>component_i</tt>等于<tt>component_j</tt>时才这样做，否则会加上一个零（编译器会将其优化掉）。

[1.x.85] 



组装右手边的内容也和介绍中讨论的一样。

[1.x.86] 



从局部自由度到全局矩阵和右手向量的转移并不取决于所考虑的方程，因此与之前所有的例子相同。

[1.x.87] 




[1.x.88][1.x.89] 。




解算器并不关心方程组的来源，只要它保持正定和对称（这是使用CG解算器的要求），而这个方程组确实是这样的。因此，我们不需要改变任何东西。

[1.x.90] 




[1.x.91][1.x.92] 。




对网格进行细化的函数与[2.x.95]中的例子相同。正交公式再次适应于线性元素。请注意，误差估计器默认情况下是将从有限元解的所有分量中得到的估计值相加，也就是说，它使用所有方向上的位移，权重相同。如果我们希望网格只适应x方向的位移，我们可以给函数传递一个额外的参数，告诉它这样做，而不考虑其他所有方向的位移作为误差指标。然而，对于目前的问题来说，考虑所有的位移分量并给予同等权重似乎是合适的。

[1.x.93] 




[1.x.94][1.x.95] 。




输出的情况大多与以前的例子中已经显示的一样。唯一的区别是，求解函数是矢量值的。DataOut类会自动处理这个问题，但我们必须给求解向量的每个组件一个不同的名字。   


要做到这一点，[2.x.96]函数需要一个字符串的矢量。由于分量的数量与我们工作的维数相同，我们使用下面的[2.x.97]语句。   


我们注意到，一些图形程序对变量名称中允许的字符有限制。因此，deal.II只支持所有程序都支持的这些字符的最小子集。基本上，这些字符是字母、数字、下划线和其他一些字符，但特别是没有空格和减号/横线。否则，该库将抛出一个异常，至少在调试模式下是这样。   


在列出了1d、2d和3d的情况后，如果我们遇到一个我们没有考虑到的情况，让程序死亡是一种很好的风格。记住，如果第一个参数中的条件不满足，Assert宏就会产生一个异常。当然，条件[2.x.98]永远不可能被满足，所以只要程序运行到默认语句，就会中止。

[1.x.96] 



在为解向量的不同组成部分设置了名称之后，我们可以将解向量添加到计划输出的数据向量列表中。请注意，下面的函数需要一个字符串向量作为第二个参数，而我们在以前所有例子中使用的函数在那里接受一个字符串。事实上，我们之前使用的函数会将单个字符串转换成只有一个元素的向量，并将其转发给另一个函数）。

[1.x.97] 




[1.x.98] [1.x.99]。




例如，[2.x.99]函数与[2.x.100]中做的事情相同。这一次，我们使用平方[-1,1]^d作为域，在开始第一次迭代之前，我们对它进行全局细化四次。   


细化的原因有点意外：我们使用QGauss正交公式，在每个方向上有两个点用于整合右手边；这意味着每个单元上有四个正交点（在二维）。如果我们只对初始网格进行一次全局细化，那么在域上每个方向上就只有四个正交点。然而，右侧函数被选择为相当局部的，在这种情况下，纯属偶然，恰好所有的正交点都位于右侧函数为零的点上（用数学术语来说，正交点恰好在右侧函数的[1.x.100]之外的点上）。这样一来，用正交计算的右手向量将只包含零（尽管如果我们完全用积分计算右手向量的话，它当然会是非零的），方程组的解就是零向量，即一个处处为零的有限元函数。从某种意义上说，我们不应该对这种情况的发生感到惊讶，因为我们选择了一个完全不适合当前问题的初始网格。   


不幸的是，如果离散解是常数，那么KellyErrorEstimator类计算的误差指标对每个单元来说也是零，对[2.x.101]的调用将不会标记任何单元进行细化（如果每个单元的指示误差是零，为什么要这样做？因此，下一次迭代中的网格也将只由四个单元组成，同样的问题再次发生。   


结论需要是：虽然我们当然不会选择非常适合准确解决问题的初始网格，但我们至少必须选择它，使它有机会捕捉到解决方案的重要特征。在这种情况下，它需要能够看到右手边的情况。因此，我们进行了四次全局细化。当然，任何更大数量的全局细化步骤也是可以的）。

[1.x.101] 




[1.x.102] [1.x.103]。




在上面最后一行关闭了[2.x.102]的名字空间后，下面是程序的主要功能，又和[2.x.103]中一模一样（当然，除了改变了类名）。

[1.x.104] 

[1.x.105][1.x.106] 。




关于这个程序的结果，除了看起来很好之外，没有什么可说的。所有图片都是用VisIt从程序写入磁盘的输出文件中制作的。前两张图片显示了[2.x.104]-和[2.x.105]-位移的标量分量。

 [2.x.106]  


你可以清楚地看到[2.x.107]-位移在[2.x.108]和[2.x.109]周围的来源，以及[2.x.110]-位移在原点的来源。

人们经常想做的是将位移显示为一个矢量场，也就是说，每个点的矢量都能说明位移的方向和大小。不幸的是，这就有点复杂了。为了理解为什么会这样，请记住，我们刚刚将我们的有限元定义为两个分量的集合（在[2.x.111]维度）。我们没有说过这不仅仅是一个压力和一个浓度（两个标量），而是说这两个分量实际上是一个矢量值量的组成部分，即位移。如果没有这方面的知识，DataOut类就会假定我们打印的所有单个变量都是独立的标量，然后VisIt和Paraview就会忠实地假定这确实是这样的。换句话说，一旦我们把数据写成标量，这些程序中就没有任何东西可以让我们把这两个标量字段粘贴到一起作为一个矢量字段。我们要攻击这个问题的地方是根源，即在[2.x.112]。我们不会在这里这样做，而是让读者参考[2.x.113]程序，在那里我们展示了如何在一个更普遍的情况下这样做。尽管如此，我们还是忍不住要生成数据，以显示如果按照[2.x.114]中讨论的方式实施，会是什么样子。矢量场看起来是这样的（VisIt和Paraview随机选择几百个顶点来绘制矢量；从每个单独的顶点绘制矢量会使图片无法阅读）。

 [2.x.115]  


我们注意到，由于[2.x.118]和[2.x.119]的力相对于这些轴是对称的，所以人们可能直观地期望解是关于[2.x.116]-和[2.x.117]轴的对称性。然而，作为矢量的力是不对称的，因此也不是解决方案。[1.x.107] [1.x.108] [2.x.120]。 

 [2.x.121] 
