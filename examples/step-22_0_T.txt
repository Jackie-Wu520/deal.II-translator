 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] , [2.x.3] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22 ][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43][1.x.44] 

 [2.x.4]  

[1.x.45] 




[1.x.46] [1.x.47] [1.x.48] 


这个程序处理斯托克斯方程组，其非维度形式如下。[1.x.49] 

其中[2.x.5]表示流体的速度，[2.x.6]是其压力，[2.x.7]是外力，[2.x.8]是对称梯度的第2级张量；其成分定义为[2.x.9] 。

斯托克斯方程描述了缓慢移动的粘性流体的稳态运动，如蜂蜜、地幔中的岩石，或其他惯性不起作用的情况。如果流体的运动速度足够快，与粘性摩擦力相比，惯性力很重要，那么斯托克斯方程就不再有效；考虑到惯性效应，就会产生非线性纳维-斯托克斯方程。然而，在这个教程程序中，我们将专注于更简单的斯托克斯系统。

请注意，当推导出更一般的可压缩纳维-斯托克斯方程时，扩散被建模为应力张量的发散[1.x.50] 。

其中[2.x.10]是流体的粘性。有了[2.x.11]的假设（假设粘度不变，通过除以[2.x.12]使方程非立体化），并假设不可压缩性（[2.x.13]），我们就可以得到上面的表述。[1.x.51] 

一个不同的公式使用拉普拉斯算子（[2.x.14]）而不是对称梯度。这里一个很大的区别是，速度的不同分量并不耦合。如果你假定解的额外正则性[2.x.15]（第二偏导存在并且是连续的），这些公式是等价的。[1.x.52] 

这是因为[2.x.16]中[2.x.17]的第1项是由。[1.x.53] 

如果你不能假设上述的规律性，或者你的粘度不是常数，那么这个等价关系就不再成立。因此，我们决定在本教程中坚持使用物理上更精确的对称张量表述。


为了得到良好的处理，我们将不得不在方程中加入边界条件。一旦我们讨论方程的微弱形式，哪些边界条件是容易做到的就会变得清晰。

这里所涉及的方程属于矢量值问题的范畴。这个主题的顶层概述可以在[2.x.18]模块中找到。


[1.x.54][1.x.55] 


方程的弱形式可以通过将其写成矢量形式得到[1.x.56] 。

从左边开始与一个矢量值测试函数[2.x.19]形成点积，并在域[2.x.20]上进行积分，得到以下方程组。[1.x.57] 

这对所有测试函数[2.x.21]都必须成立。

一般来说，一个好的经验法则是，如果[1.x.58]减少公式中任何变量上的导数，那么[1.x.59]实际上是用部分积分来做。这是由[1.x.60]的理论引起的，特别是强和[1.x.61]之间的区别）。我们已经为拉普拉斯方程做了这个工作，在那里我们对第二导数进行了分项积分，得到了在测试和试验函数上都只有一个导数的弱表述。

在目前的情况下，我们对第二项进行分项积分。[1.x.62] 

同样地，我们对第一项进行分项积分，得到[1.x.63] 

其中两个张量之间的标量乘积在此定义为[1.x.64] 。

利用这一点，我们现在将对变量的要求降低到[2.x.22]的一阶导数和[2.x.23]完全没有导数。

因为像[2.x.24]这样的一般张量和[2.x.25]这样的对称张量之间的标量积等于两者的对称形式之间的标量积，我们也可以把上面的双线性形式写成如下。[1.x.65] 

我们将在下一节处理边界项，但从双线性形式的域项[1.x.66]中已经可以看出 

我们将在下一节处理边界项，但从双线性形式的域项[1.x.66]已经可以看出，斯托克斯方程产生了一个对称的双线性形式，因此也产生了一个对称的（如果是不确定的）系统矩阵。


[1.x.67][1.x.68] 。


 [2.x.26] ( [2.x.27] )  

刚刚得出的弱形式立即为我们提供了施加边界条件的不同可能性。 [2.x.28] [2.x.29] Dirichlet速度边界条件。在一个部分上[2.x.30]我们可以对速度施加迪里希特条件[2.x.31] 。

    [1.x.69] 

    因为检验函数[2.x.32]来自解变量的切线空间，我们有[2.x.33]在[2.x.34]上，因此有[1.x.70]。

    换句话说，像往常一样，强加的边界值并没有出现在弱形式中。

    值得注意的是，如果我们在整个边界上施加Dirichlet边界值，那么压力只确定到一个常数。这方面的算法实现将使用类似的工具，正如在 [2.x.35] 中看到的那样。

 [2.x.36] 诺伊曼型或自然边界条件。在边界的其余部分[2.x.37]，让我们把边界条款重新写成如下。    [1.x.71] 

    换句话说，在边界的诺伊曼部分，我们可以为总应力规定值。    [1.x.72] 

    如果边界被细分为Dirichlet和Neumann部分[2.x.38]，这就导致了以下弱形式。    [1.x.73] 




 [2.x.39] 罗宾型边界条件。罗宾式边界条件是迪里切特和诺依曼边界条件的混合体。它们将读作[1.x.74] 

    有一个等级2的张量（矩阵） [2.x.40] 。相关的弱形式是[1.x.75] 。



 [2.x.41] 局部边界条件。可以通过只对速度的某些分量强制执行Dirichlet和Neumann边界条件来结合它们中的每一个。例如，施加人工边界条件的一种方法是要求流动垂直于边界，即切向分量[2.x.42]为零，从而约束速度的[2.x.43]-1分量。剩下的分量可以通过要求法向应力的法向分量为零来约束，产生以下一组边界条件。    [1.x.76] 



    另一种情况是希望水流是[1.x.77]而不是垂直于边界（在deal.II中，[2.x.44]函数可以帮你做到这一点）。这种情况经常发生在自由边界的问题上（例如，在河流或湖泊的表面，如果流动的垂直力不足以使表面实际变形），或者如果边界对流体没有施加明显的摩擦力（例如，在地幔和地核的界面上，两种流体因密度不同而相遇，但它们的粘度都很小，不会对彼此产生很大的切向应力）。    在公式中，这意味着[1.x.78] 

    第一个条件（需要强加）固定速度的一个分量，第二个条件（将在弱形式下强制执行）固定其余两个分量。 [2.x.45]  

尽管有这么多的可能性，我们在本教程中只使用迪里希特和（同质的）诺伊曼边界条件。


[1.x.79][1.x.80] 


如上所述，在[2.x.46]和[2.x.47]上具有狄里奇和诺依曼边界条件的方程的弱形式是这样的：找到[2.x.48]，以便[1.x.81] 

为所有测试函数 [2.x.49] 。

这些方程代表一个对称的[1.x.82]。众所周知，那么只有当我们寻找解决方案的函数空间必须满足某些条件时，解决方案才存在，这些条件通常被称为Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件。上面的连续函数空间满足这些条件。然而，当我们将方程离散化，用有限维空间中的有限元函数取代连续变量和检验函数时[2.x.50]，我们必须确保[2.x.51]也满足LBB条件。这与我们在 [2.x.52] 中必须做的事情类似。

对于斯托克斯方程，有许多可能的选择来确保有限元空间与LBB条件兼容。我们在这里使用的一个简单而准确的选择是[2.x.53]，即对速度使用比压力高一阶的元素。

这就导致了以下的离散问题：找到[2.x.54]，使[1.x.83] 

为所有测试函数 [2.x.55] 。组建与该问题相关的线性系统遵循[2.x.56]"[2.x.57]"、[2.x.58]中使用的相同路线，并在[2.x.59]模块中详细解释。




[1.x.84][1.x.85] 。


离散方程的微弱形式自然导致了速度场和压力场的节点值的以下线性系统。[1.x.86] 

与[2.x.60]和[2.x.61]一样，我们将通过形成舒尔补数来解决这个方程组，即我们将首先找到[1.x.87]的解[2.x.62]。

然后是[1.x.88]。

我们这样做的方式与我们在之前的这些教程程序中的做法几乎完全一样，即我们再次使用相同的类[2.x.63]和[2.x.64]。然而，有两个显著的区别。

 [2.x.65] [2.x.66] 首先，在混合拉普拉斯方程中，我们必须处理如何对舒尔补数[2.x.67]进行预处理的问题，它在频谱上等同于压力空间上的拉普拉斯算子（因为[2.x.68 ]代表梯度算子，[2.x.69]代表其邻接算子[2.x.70]，而[2.x.71]代表身份（直到材料参数[2.x.72]为止），因此[2.x.73]类似于[2.x.74]）。因此，对于小的网格尺寸来说，矩阵的条件很差，我们不得不为Schur补数想出一个精心设计的预处理方案。

 [2.x.75] 其次，每次我们与[2.x.76]相乘时，我们必须用质量矩阵[2.x.77]来解决。然而，这并不特别困难，因为质量矩阵总是有很好的条件的，所以使用CG和一点点预处理就能简单地反转。 [2.x.78] 换句话说，[2.x.79]的内部求解器的预处理很简单，而[2.x.80]的外部求解器的预处理很复杂。

在这里，情况几乎完全相反。差异源于这样一个事实，即舒尔补码的核心矩阵不是来自身份算子，而是来自拉普拉斯算子的变体，[2.x.81]（其中[2.x.82]是对称梯度），作用于一个矢量场。在对这个问题的研究中，我们主要遵循D. Silvester和A. Wathen的论文。"稳定的斯托克斯系统的快速迭代解第二部分。使用一般块状先决条件"。(SIAM J. Numer. Anal., 31 (1994), pp. 1352-1367)，可在线查阅[1.x.89]。原则上，舒尔补码核心的矩阵的差异有两个后果。

 [2.x.83] [2.x.84] 首先，它使外部预处理变得简单：Schur补充对应于压力空间上的算子[2.x.85]；忘记我们处理的是对称梯度而不是常规梯度的事实，Schur补充是类似于[2.x.86]的东西，即使在数学上不完全简洁，在谱上也等同于身份算子（一个启发式的论证是把算子换算成[2.x.87]）。事实证明，用CG方法直接解决这个Schur补数并不容易：在没有预处理的情况下，Schur补数矩阵的条件数取决于最大和最小单元的大小比，而且仍然需要50-100次CG迭代。然而，有一个简单的解决办法：用压力空间上的质量矩阵进行预处理，我们就可以减少到5-15次CG迭代，几乎不受网格结构的影响（看看这个程序的[1.x.90]，可以看到CG迭代的数量确实不会随着我们细化网格而改变）。

因此，除了我们已经有的东西之外，我们所需要的就是压力变量上的质量矩阵，我们将把它存储在一个单独的对象中。




 [2.x.88]与[2.x.89]中讨论的混合拉普拉斯情况相比，外部预调节器变得简单了，但内部求解器的问题却变得更加复杂。在混合拉普拉斯离散化中，Schur补码的形式为 [2.x.90] 。因此，每当我们与Schur补码相乘时，我们必须解决一个线性系统[2.x.91]；然而，这并不太复杂，因为压力空间上的质量矩阵[2.x.92]是有条件的。


另一方面，对于我们在这里考虑的斯托克斯方程，舒尔补码是[2.x.93]，其中矩阵[2.x.94]与拉普拉斯算子有关（事实上，它是对应于双线性形式[2.x.95]的矩阵）。因此，用[2.x.96]求解要复杂得多：矩阵的条件很差，我们知道我们需要很多迭代，除非我们有一个非常好的预处理程序。更糟糕的是，我们每次与舒尔补码相乘时都要用[2.x.97]求解，使用上述的预处理程序需要5-15次。

因为我们必须多次用[2.x.98]求解，所以多花一点时间为这个矩阵创建一个好的预处理程序是值得的。所以我们要做的是：如果在2d中，我们使用终极预处理程序，即直接对矩阵进行稀疏LU分解。这是用SparseDirectUMFPACK类实现的，它使用UMFPACK直接求解器来计算分解。要使用它，你必须建立支持UMFPACK的deal.II（这是默认的）；说明见[1.x.91]。有了它，内解器在一次迭代中就会收敛。

在2D中，我们可以做这样的事情，因为即使是合理的大问题，也很少有超过100,000个未知数，每行的非零项相对较少。此外，2d中矩阵的带宽是[2.x.99]，因此是适中的。对于这样的矩阵，稀疏因子可以在几秒钟内计算出来。作为参考，计算一个大小为[2.x.100]、带宽为[2.x.101]的矩阵的稀疏因子需要[2.x.102]次操作。在2D中，这是[2.x.103]；尽管这比，例如，组装线性系统需要[2.x.104]的复杂度要高，计算分解的常数是如此之小，以至于它不会成为整个程序中的主导因素，直到我们达到非常大的未知数的%，甚至更多）。) 

情况在3D中发生了变化，因为在那里我们很快就会有更多的未知数，而且矩阵的带宽（决定了稀疏LU因子中非零项的数量）是[2.x.105]，而且每行也有很多条目。这使得使用像UMFPACK这样的稀疏直接求解器的效率很低：只有在问题规模为10,000到100,000个未知数时，才能用合理的时间和内存资源计算稀疏分解。

在这种情况下，我们所做的是使用一个不完整的LU分解（ILU）作为预处理，而不是实际计算完整的LU因子。恰好，deal.II有一个类可以做到这一点。SparseILU。计算ILU所需要的时间只取决于稀疏矩阵中的非零项的数量（或者说我们愿意填入LU因子，如果这些非零项应该多于矩阵中的非零项），但与矩阵的带宽无关。因此，这也是一个可以有效地在三维中计算的操作。另一方面，根据定义，一个不完整的LU分解并不代表矩阵的精确逆 [2.x.106] 。因此，与稀疏直接求解器的预处理不同，用ILU进行预处理仍然需要一次以上的迭代。因此，当与舒尔补码相乘时，内解器将花费更多时间：这是一个不可避免的权衡。 [2.x.107]  

在下面的程序中，我们将利用SparseILU和SparseDirectUMFPACK类具有非常相似的接口，可以互换使用的事实。我们所需要的是一个开关类，根据维度的不同，提供一个类型，即上述两个类中的任何一个。这就是我们如何做的。

[1.x.92] 



从这里开始，我们可以参考类型<code>typename [2.x.108]，并自动得到正确的预处理类。由于这两个类的接口相似，我们将能够在所有地方使用相同的语法来互换使用它们。


[1.x.93][1.x.94] 


上面的讨论显示了解决由斯托克斯方程产生的线性系统的*种方式，由于教程程序是教学工具，这是有意义的。但这是解决这个方程组的**方式吗？

这个问题的答案是否定的。这个方法的主要瓶颈已经在上面指出，我们必须反复求解舒尔补数内的[2.x.109]线性系统，由于我们没有一个好的舒尔补数的预处理程序，这些求解就不得不经常发生。一个更好的方法是使用块分解，这是基于Silvester和Wathen [2.x.110]的观察，并在[2.x.111]中做了更详细的解释。下面在本程序的结果部分的a [1.x.95]一节中讨论了这种替代方法的实施。


[1.x.96][1.x.97] 。


上面，我们已经声称线性系统具有[1.x.98]的形式 

即，特别是在矩阵的右下方有一个零块。这样，我们就可以把舒尔补码写成[2.x.112]。但这并不完全正确。

想一想，如果对某些压力变量有约束，会发生什么情况（见[2.x.113]"自由度的约束 "文件模块），例如，因为我们使用自适应细化网格和连续压力有限元，所以有悬挂节点。造成这种约束的另一个原因是压力的迪里希特边界条件。然后，AffineConstraints类，在将矩阵的局部贡献复制到全局线性系统中时，会将对应于受限自由度的行和列清零，并在对角线上放一个正条目。为了简单起见，你可以认为这个条目是1，尽管实际上它是一个与其他矩阵条目相同数量级的值）。换句话说，右下角区块其实根本不是空的：它在对角线上有几个条目，每个受限的压力自由度都有一个，对我们要解决的线性系统的正确描述是，它具有[1.x.99]的形式 

其中[2.x.114]是零矩阵，受限自由度的正对角线条目除外。那么，正确的舒尔补码实际上将是矩阵[2.x.115]，而不是上面说的那个。

思考这个问题使我们首先意识到，现在得到的舒尔补码是不确定的，因为[2.x.116]是对称的和正定的，而[2.x.117]是正半定的，从前者减去后者可能不再是正定的。这很烦人，因为我们不能再对这个真正的舒尔补数采用共轭梯度法。也就是说，我们可以在[2.x.118]中通过简单地将*负*值放在受限压力变量的对角线上来解决这个问题--因为我们实际上只是放了一些非零的东西来确保结果矩阵不是奇异的；我们真的不关心这个条目是正还是负。因此，如果[2.x.119]的对角线上的条目是负的，那么[2.x.120]将再次成为一个对称的正定矩阵。

但是，其次，下面的代码实际上并没有做这些事情。它很高兴地用错误的舒尔补码[2.x.121]来解决线性系统，完全忽略了这个问题。为什么会这样呢？为了理解为什么会这样，回顾一下，当把局部贡献写入全局矩阵时，[2.x.122]把对应于受限自由度的行和列置零。这意味着[2.x.123]有一些零行，[2.x.124]零列。因此，如果要乘出[2.x.125]的条目是什么，就会发现它的所有受限压力自由度的行和列都是零，包括对角线上的一个零。[2.x.126]的非零条目将正好适合于这些零对角线位置，并确保[2.x.127]是可逆的。不这样做，严格来说，意味着[2.x.128]仍然是单数。它在非约束压力自由度子集上是对称和正定的，而在约束压力上只是零矩阵。为什么共轭梯度法对这个矩阵有效？因为[2.x.129]还确保对应于矩阵的这些零行的右手边条目也是**零，即右手边是兼容的。

这意味着无论这些受限压力自由度的解向量的值是多少，这些行的残差总是为零，如果考虑到CG算法的内部操作，就永远不会对解向量产生任何更新。换句话说，CG算法只是*忽略*这些行，尽管矩阵是单数。这只是因为这些自由度与线性系统的其他部分完全解耦（因为整个行和相应的列都是零）。在求解过程结束时，求解向量中的受限压力值仍然和我们开始调用求解器时一模一样；当我们在CG求解器完成后调用[2.x.130]时，它们最终被正确的值所覆盖。

这个讨论的结果是，大矩阵的右下角块为零的假设有点简化了，但是仅仅使用它实际上并不会导致任何值得解决的实际问题。


[1.x.100][1.x.101] 


我们下面实现的域、右手边和边界条件与地球物理学中的一个问题有关：在那里，人们想计算大洋中裂缝下地球内部岩浆的流动场。裂缝是两个大陆板块非常缓慢地漂移开来的地方（每年最多几厘米），在地壳上留下一个裂缝，被下面的岩浆填满。在不试图完全现实的情况下，我们通过在域[2.x.131]上解出以下一组方程和边界条件来模拟这种情况：[1.x.102] 。

并在其他地方使用自然边界条件[2.x.132]。换句话说，在顶面的左边部分，我们规定流体以速度[2.x.133]随大陆板向左移动，在顶面的右边部分向右移动，并在其他地方施加自然流动条件。如果我们在2d中，描述基本上是相同的，例外的是我们省略了上述所有矢量的第二部分。

正如在[1.x.103]中会变得很明显的那样，流场会从下面拉动材料，并将其移动到域的左右两端，这是预期的。速度边界条件的不连续性将在顶面中心产生一个压力奇异点，将材料一直吸到顶面，以填补材料在此位置向外运动留下的空隙。


[1.x.104][1.x.105] 


[1.x.106][1.x.107] 。


在之前的所有教程程序中，我们仅仅使用AffineConstraints对象来处理悬挂节点约束（[2.x.134]除外）。然而，这个类也可以用来实现Dirichlet边界条件，正如我们将在这个程序中展示的那样，通过固定一些节点值[2.x.135] 。注意，这些是不均匀约束，我们要特别注意一下。我们要实现的方式是，首先通过使用调用将边界值读入AffineConstraints对象中 

[1.x.108] 



非常类似于我们之前制作边界节点列表的方式（注意，我们只在边界标志为1的边界上设置Dirichlet条件）。然后边界值的实际应用由AffineConstraints对象直接处理，没有任何额外的干扰。

然后我们可以像以前那样进行，即通过填充矩阵，然后在约束对象上调用一个凝结函数，其形式为 

[1.x.109] 



注意，我们在系统矩阵和系统右侧同时调用这个函数，因为解决非均质约束需要对矩阵条目和右侧的知识。但出于效率的考虑，我们选择了另一种策略：在AffineConstraints对象中收集的所有约束可以在将本地数据写入全局矩阵的同时，通过调用来实时解决 

[1.x.110] 



这一技术在[2.x.136]教程程序中进一步讨论。我们在这里需要知道的是，这个函数同时做了三件事：它将本地数据写入全局矩阵和右手边，它分配了悬挂的节点约束，另外还实现了（不均匀的）迪里切特边界条件。这很好，不是吗？

我们可以得出结论，AffineConstraints类提供了一个替代使用[2.x.137]来实现Dirichlet边界条件的方法。


[1.x.111][1.x.112][1.x.113] 

通常，稀疏矩阵包含大量的元素，当我们要开始线性求解时，这些元素实际上是零。这样的元素是在我们消除约束条件或实现Dirichlet条件时引入的，我们通常会删除受约束行和列中的所有条目，即把它们设置为零。对于本教程程序中所考虑的三维应用，存在于稀疏模式中但并不真正包含任何信息的那部分元素，可以达到矩阵中元素总数的四分之一。请记住，矩阵-向量乘积或预处理程序对稀疏矩阵的所有元素（甚至那些为零的元素）进行操作，这是我们在这里要避免的低效率。

直接解决约束自由度的一个好处是，我们可以避免在我们的稀疏矩阵中出现大部分要为零的条目&mdash；在矩阵构造过程中我们不需要约束条目（与传统算法相反，传统算法是先填充矩阵，之后才解决约束）。这将在形成矩阵-向量乘积时节省内存和时间。我们要做的是将约束信息传递给生成稀疏模式的函数，然后设置一个<tt>false</tt>参数，指定我们不打算使用约束条目。

[1.x.114] 

顺便说一下，这个函数也避免了对稀疏模式的<tt>condense()</tt>函数的调用。


[1.x.115][1.x.116] 。


下面开发的程序已经看到了很多的TLC。我们在分析工具（主要是[1.x.117]的cachegrind和callgrind工具，以及用于可视化的KDE[1.x.118]程序）下一遍又一遍地运行它，看看瓶颈在哪里。这已经得到了回报：通过这种努力，当考虑到细化周期0到3的运行时间时，程序的速度已经提高了大约4倍，将CPU指令的总体执行数量从869,574,060,348减少到199,853,005,625。对于更高的细化水平，收益可能更大，因为一些不是[2.x.138]的算法被取消了。

基本上，目前程序中有两种算法不随自由度数量的增加而线性扩展：自由度的重新编号（这是[2.x.139]，和线性求解器（这是[2.x.140]）。至于第一个，虽然自由度的重新排序可能不是线性扩展，但它是整个算法中不可缺少的部分，因为它极大地提高了稀疏ILU的质量，很容易弥补计算重新编号的时间；证明这一点的图表和时间显示在DoFRenumbering命名空间的文档中，也强调了下面选择的Cuthill-McKee重新排序算法。

至于线性求解器：如上所述，我们在这里的实现使用了Schur补码公式。这不一定是非常好的选择，但却展示了交易中可用的各种重要技术。关于哪种求解器最好的问题，在本程序的[1.x.119]中再次进行了讨论，并附有显示备选求解器的代码和对其结果的比较。

除此以外，在这个程序的创建过程中，许多其他的算法也被测试和改进。例如，在建立稀疏性模式时，我们最初使用了一个BlockCompressedSparsityPattern对象（现在已经不存在了），该对象每次增加一个元素；然而，其数据结构对于我们在3D中离散化所产生的每行大量非零条目来说适应性很差，导致了二次方的行为。替换deal.II中的内部算法，一次设置许多元素，并使用BlockCompressedSimpleSparsityPattern（截至2015年初，它又被BlockDynamicSparsityPattern取代）作为一个更好的适应性数据结构，消除了这个瓶颈，代价是内存消耗略高。同样，SparseILU类中的分解步骤的实现也非常低效，已经被一个快10倍的步骤所取代。甚至SparseILU的vmult函数也得到了改进，节省了大约20%的时间。小的改进在这里和那里被应用。此外，AffineConstraints对象被用来消除稀疏矩阵中很多最终会为零的条目，见[1.x.120]。

这里显示了在3d的细化周期0到3中，在程序的各个不同地方花费了多少CPU指令的概况。

 [2.x.141]  

可以看出，在这个细化水平上，大约四分之三的指令数花在实际求解上（左边的[2.x.142]调用，中间的[2.x.143]调用用于舒尔补数求解，另一个方框代表[1.x.121]求解中与稀疏ILU和稀疏矩阵的乘法）。大约五分之一的指令数用于矩阵装配和稀疏ILU计算（右下角的方框），其余的用于其他方面。由于在[2.x.144]调用中的浮点运算通常比矩阵装配中的许多逻辑运算和查表要长得多，所以矩阵装配所占的运行时间的比例实际上大大低于指令的比例，这在我们在结果部分的比较中会变得很明显。

对于更高的细化水平，代表求解器的方框以及右上方源于重排算法的蓝色方框将以牺牲程序的其他部分为代价而增长，因为它们不是线性扩展。在这个中等细化水平（3168个单元和93176个自由度），线性求解器已经占了大约四分之三的指令，这是一个很好的迹象，说明这个程序中使用的大多数算法都是经过良好调整的，加快程序速度的主要改进很可能不是来自手工优化的个别方面，而是通过改变求解器的算法。我们将在下面的结果讨论中也讨论这一点。

最后一点，作为参考，下图也显示了在优化这个程序的早期阶段，配置文件的样子。

 [2.x.145]  

如上所述，这个版本的运行时间大约是第一个配置文件的四倍，其中SparseILU分解占用了大约30%的指令数，而操作早期低效版本的DynamicSparsityPattern大约占10%。这两个瓶颈后来都被完全消除了。[1.x.122] [1.x.123] 。


[1.x.124] [1.x.125]。




像往常一样，我们首先包括一些著名的文件。

[1.x.126] 



然后我们需要包括稀疏直接求解器UMFPACK的头文件。

[1.x.127] 



这包括用于不完全LU因子化的库，它将被用作3D的预处理程序。

[1.x.128] 



这就是C++。

[1.x.129] 



如同在所有的程序中一样，包括了命名空间dealii。

[1.x.130] 




[1.x.131] [1.x.132] 




正如介绍中所解释的，我们将分别对二维和三维空间使用不同的预处理程序。我们通过使用空间维度作为模板参数来区分它们。关于模板的细节见[2.x.146]。我们不打算在这里创建任何预处理对象，我们所做的只是创建一个持有确定预处理类的本地别名的类，这样我们就可以以独立于维度的方式来编写我们的程序。

[1.x.133] 



在二维中，我们将使用一个稀疏的直接求解器作为预处理。

[1.x.134] 



而三维中的ILU预处理，由SparseILU调用。

[1.x.135] 




[1.x.136] [1.x.137] 。




这是对[2.x.147]的改编，所以主类和数据类型与那里使用的几乎相同。唯一不同的是，我们有一个额外的成员 [2.x.148] ，用于预处理Schur补码，以及相应的稀疏模式 [2.x.149] 。此外，我们没有依赖LinearOperator，而是实现了我们自己的InverseMatrix类。   


在这个例子中，我们还使用了自适应网格细化，其处理方式与 [2.x.150] 类似。根据介绍中的讨论，我们也将使用AffineConstraints对象来实现Dirichlet边界条件。因此，我们改变了 [2.x.151] 的名称。

[1.x.138] 



这一条是新的：我们将使用一个所谓的共享指针结构来访问预处理程序。共享指针本质上只是指针的一种方便形式。几个共享指针可以指向同一个对象（就像普通的指针一样），但是当最后一个指向前提器对象的共享指针对象被删除时（例如共享指针对象超出范围，它所在的类被销毁，或者指针被分配给不同的前提器对象），那么指向的前提器对象也被销毁。这确保了我们不必手动跟踪一个预设条件器对象在多少地方仍被引用，它永远不会产生内存泄漏，也不会产生一个指向已被销毁对象的悬空指针。

[1.x.139] 




[1.x.140] [1.x.141]。




正如在[2.x.152]和其他大多数例子程序中一样，下一个任务是定义PDE的数据：对于斯托克斯问题，我们将在边界的一部分使用自然边界值（即同质诺伊曼型），对此我们不必做任何特殊处理（同质性意味着弱形式中的相应项只是零），而在边界的其余部分使用速度的边界条件（狄里克型），如介绍中所述。   


为了强制执行速度上的Dirichlet边界值，我们将像往常一样使用[2.x.153]函数，这要求我们写一个具有与有限元一样多分量的函数对象。换句话说，我们必须在[2.x.154]-空间上定义函数，但我们在插值边界值时要过滤掉压力分量。




下面的函数对象是介绍中描述的边界值的表示。

[1.x.142] 



我们为右手边实现类似的函数，对于目前的例子来说，右手边只是简单的零。

[1.x.143] 




[1.x.144] [1.x.145]。




介绍中对线性求解器和预处理器进行了广泛的讨论。在这里，我们创建将被使用的各自对象。





[1.x.146] [1.x.147] [2.x.155]类表示逆矩阵的数据结构。与[2.x.156]不同，我们用一个类来实现，而不是用辅助函数inverse_linear_operator()，我们将把这个类应用于不同种类的矩阵，这些矩阵需要不同的预处理（在[2.x.157]中，我们只对质量矩阵使用非同一性预处理）。矩阵和预处理器的类型通过模板参数传递给这个类，当创建[2.x.158]对象时，这些类型的矩阵和预处理器对象将被传递给构造函数。成员函数[2.x.159]是通过解决一个线性系统得到的。

[1.x.148] 



这就是[2.x.160]函数的实现。




在这个类中，我们对解算器控制使用了一个相当大的公差。这样做的原因是，该函数的使用非常频繁，因此，任何使CG求解中的残差变小的额外努力都会使求解更加昂贵。请注意，我们不仅将这个类作为Schur补数的预处理程序，而且在形成拉普拉斯矩阵的逆时也使用这个类；因此，它直接对解本身的精度负责，所以我们也不能选择太大的公差。

[1.x.149] 




[1.x.150][1.x.151] 。




这个类实现了介绍中讨论的Schur补码。它与 [2.x.161] 相类似。 不过，我们现在用一个模板参数[2.x.162]来调用它，以便在指定逆矩阵类的各自类型时访问它。作为上述定义的结果，声明[2.x.163]现在包含上述预处理类的第二个模板参数，这也影响到[2.x.164]。

[1.x.152] 




[1.x.153] [1.x.154]。





[1.x.155] [1.x.156]。




这个类的构造函数看起来与 [2.x.165] 的构造函数非常相似。构造函数初始化了多项式程度、三角形、有限元系统和dof处理器的变量。矢量速度分量的基础多项式函数的阶数为[2.x.166]，压力的阶数为[2.x.167]。 这就得到了LBB稳定元素对[2.x.168]，通常被称为Taylor-Hood元素。   


请注意，我们用MeshSmoothing参数初始化三角形，这可以确保单元的细化是以PDE解的近似保持良好的方式进行的（如果网格过于非结构化就会出现问题），详情请参见[2.x.169]的文档。

[1.x.157] 




[1.x.158][1.x.159] 。




给定一个网格，该函数将自由度与之关联，并创建相应的矩阵和向量。在开始的时候，它还释放了指向预处理对象的指针（如果共享指针在这时指向任何东西的话），因为在这之后肯定不再需要它了，在组装矩阵后必须重新计算，并将稀疏矩阵从其稀疏模式对象中解开。   


然后，我们继续分配自由度，并对其重新编号。为了使ILU预处理程序（三维）有效地工作，重要的是以减少矩阵带宽的方式列举自由度，或者也许更重要的是：以使ILU尽可能地接近于真正的LU分解的方式。另一方面，我们需要保留在[2.x.170]和[2.x.171]中已经看到的速度和压力的块结构。这要分两步完成。首先，对所有的道夫进行重新编号，以提高ILU，然后我们再一次按组件重新编号。由于[2.x.172]没有触及单个块内的重新编号，所以第一步的基本重新编号仍然存在。至于如何对自由度进行重新编号以改善ILU：deal.II有许多算法试图找到排序以改善ILU，或减少矩阵的带宽，或优化其他方面。DoFRenumbering命名空间显示了我们在本教程程序中基于这里讨论的测试案例而获得的几种算法的结果比较。在这里，我们将使用传统的Cuthill-McKee算法，该算法已经在之前的一些教程程序中使用。 在[1.x.160]中我们将更详细地讨论这个问题。




与以前的教程程序相比，还有一个变化。没有理由对[2.x.173]的速度成分进行单独排序。事实上，与其先列举所有[2.x.174]-velocities，再列举所有[2.x.175]-velocities，等等，我们希望把所有速度放在一起，只在速度（所有分量）和压力之间分开。默认情况下，[2.x.176]函数不是这样做的：它把每个矢量分量分开处理；我们要做的是把几个分量分成 "块"，并把这个块结构传递给该函数。因此，我们分配一个有多少个元素的向量[2.x.177]，描述所有的速度分量对应于块0，而压力分量将形成块1。

[1.x.161] 



现在是迪里希特边界条件的实现，这在介绍中的讨论后应该是很明显的。所有改变的是，这个函数已经出现在设置函数中，而我们习惯于在一些装配程序中看到它。在我们设置网格的下面，我们将把施加Dirichlet边界条件的顶部边界与边界指标1联系起来。 我们必须将这个边界指标作为第二个参数传递给下面的插值函数。 不过，还有一件事。 描述Dirichlet条件的函数是为所有分量定义的，包括速度和压力。然而，Dirichlet条件只为速度而设置。 为此，我们使用一个只选择速度分量的ComponentMask。通过指定我们想要的特定分量，从有限元中获得该分量掩码。由于我们使用自适应细化网格，仿生约束对象需要首先填充由DoF处理程序生成的悬挂节点约束。注意这两个函数的顺序；我们首先计算悬挂节点约束，然后将边界值插入约束对象。这确保了我们在有悬挂节点的边界上尊重H<sup>1</sup>符合性（在三个空间维度上），其中悬挂节点需要支配Dirichlet边界值。

[1.x.162] 



与[2.x.178]相类似，我们计算各个组成部分中的道夫。我们可以用与那里相同的方式来做，但我们想在我们已经用于重新编号的块状结构上进行操作。函数[2.x.179]的作用与[2.x.180]相同，但现在通过[2.x.181]分组为速度和压力块。

[1.x.163] 



下一个任务是为我们将创建的系统矩阵分配一个稀疏模式，为预处理矩阵分配一个稀疏模式。我们可以用与[2.x.182]相同的方式来做，即通过[2.x.183]直接建立一个SparsityPattern类型的对象，但是，有一个重要的理由不这样做。在3D中，函数[2.x.184]对各个道夫之间的耦合产生了一个保守但相当大的数字，因此，最初为创建矩阵的稀疏模式提供的内存太多--实际上，对于中等大小的3D问题，初始稀疏模式甚至无法放入大多数系统的物理内存中，也请参见[2.x.185] 中的讨论。相反，我们首先建立临时对象，使用不同的数据结构，不需要分配更多的内存，但不适合作为SparseMatrix或BlockSparseMatrix对象的基础；在第二步，我们将这些对象复制到BlockSparsityPattern类型的对象中。这与我们在 [2.x.186] 和 [2.x.187] 中所做的完全相似。特别是，我们利用了这样一个事实，即我们永远不会写入系统矩阵的[2.x.188]块，而这是唯一需要为预处理矩阵填充的块。     


所有这些都是在新范围内完成的，这意味着一旦信息被复制到[2.x.190]，[2.x.189]的内存将被释放。

[1.x.164] 



最后，与 [2.x.191] 中的方法类似，从块结构中创建了系统矩阵、前导矩阵、解决方案和右侧向量。

[1.x.165] 




[1.x.166] [1.x.167]。




组装过程遵循[2.x.192]和介绍中的讨论。我们使用众所周知的缩写来表示持有本单元的局部矩阵、右手和自由度的全局编号的数据结构。

[1.x.168] 



接下来，我们需要两个对象，作为FEValues对象的提取器。它们的使用在关于 [2.x.193] 的报告中详细解释。

[1.x.169] 



作为对[2.x.194]和[2.x.195]的扩展，我们包括了一些优化，这些优化使这个特定问题的装配速度大大加快。这些改进是基于这样的观察：当我们像[2.x.196]那样做时，我们做了太多次的计算：对称梯度实际上在每个正交点有[2.x.197]个不同的值，但我们从FEValues对象中提取了[2.x.198]次--在[2.x.199]的循环和[2.x.200]的内循环中。在3D中，这意味着评估[2.x.201]而不是[2.x.202]次，这是一个不小的差异。     


所以我们在这里要做的是，在开始对单元上的道夫进行循环之前，在正交点得到一个秩-2张量的向量（类似的还有压力上的发散和基函数值）来避免这种重复计算。首先，我们创建各自的对象来保存这些值。然后，我们开始在所有单元上进行循环，并在正交点上进行循环，在那里我们首先提取这些值。我们在这里还实现了一个优化：本地矩阵（以及全局矩阵）将是对称的，因为所有涉及的操作都是相对于[2.x.203]和[2.x.204]对称的。这可以通过简单地运行内循环而不是[2.x.205]来实现，外循环的索引。

[1.x.170] 



现在最后是系统矩阵和我们用于预处理程序的矩阵的双线性形式。回顾一下，这两个的公式是 

[1.x.171] 

和 

[1.x.172] 

其中[2.x.206]和[2.x.207]是[2.x.208]th形状函数的速度和压力成分。然后，上述各种条款在以下实施中很容易识别。

[1.x.173] 



注意，在上述（1）的实现中，`operator*`被重载用于对称张量，产生两个张量之间的标量乘积。                 


对于右手边，我们利用形状函数只在一个分量中不为零的事实（因为我们的元素是原始的）。 我们不把代表形状函数i的dim+1值的张量与整个右手边的向量相乘，而只看唯一的非零分量。函数[2.x.209]将返回这个形状函数所处的分量（0=x速度，1=y速度，2=2d中的压力），我们用它来挑选出右手边向量的正确分量来相乘。

[1.x.174] 



在我们将局部数据写入全局矩阵之前（同时使用AffineConstraints对象来应用Dirichlet边界条件并消除悬挂的节点约束，正如我们在介绍中讨论的那样），我们必须注意一件事。由于对称性，我们只建立了一半的局部矩阵，但我们要保存完整的矩阵，以便使用标准函数进行解算。这是通过翻转指数来实现的，以防我们指向局部矩阵的空部分。

[1.x.175] 



在我们要解决这个线性系统之前，我们为速度-速度矩阵生成一个预处理程序，即系统矩阵中的[2.x.210]。如上所述，这取决于空间维度。由于[2.x.211]别名所描述的两个类具有相同的接口，因此无论我们想使用稀疏直接求解器还是ILU，都不需要做任何不同的事情。

[1.x.176] 




[1.x.177] [1.x.178]。




经过前面介绍中的讨论和各自类的定义，[2.x.212]函数的实现是相当直接的，其方式与[2.x.213]类似。首先，我们需要一个[2.x.214]类的对象，代表矩阵A的逆。正如在介绍中所描述的那样，在[2.x.215]类型的内部预处理器的帮助下，生成了逆。

[1.x.179] 



这与[2.x.216]中一样。我们生成舒尔补数的右手边[2.x.217]和一个代表各自线性运算的对象[2.x.218]，现在有一个模板参数表示预处理器--根据类的定义。

[1.x.180] 



解算器调用的常规控制结构被创建... 

[1.x.181] 



现在是舒尔补码的预处理程序。正如介绍中所解释的，预处理是由压力变量的质量矩阵完成的。       


实际上，求解器需要有预处理的形式 [2.x.219] ，所以我们需要创建一个逆运算。我们再次使用[2.x.220]类的对象，它实现了求解器需要的[2.x.221]操作。 在这种情况下，我们必须对压力质量矩阵进行反转。正如在早期的教程程序中已经证明的那样，质量矩阵的反转是一个相当便宜和简单的操作（与拉普拉斯矩阵等相比）。带有ILU预处理的CG方法在5-10步内收敛，与网格大小无关。 这正是我们在这里所做的。我们选择另一个ILU预处理，并通过相应的模板参数将其带入InverseMatrix对象。 然后在逆矩阵的vmult操作中调用一个CG求解器。       


另一种方法是选择因子为1.2的SSOR预处理器，这种方法构建成本较低，但之后需要更多的迭代。它需要大约两倍的迭代次数，但其生成的成本几乎可以忽略不计。

[1.x.182] 



有了舒尔补码和高效的预处理程序，我们可以用通常的方法解决压力的相应方程（即解向量中的块0）。

[1.x.183] 



在这第一个求解步骤之后，为了实现一致的压力场，必须将悬挂的节点约束分布到求解中。

[1.x.184] 



如同在[2.x.222]中，我们最后需要求解速度方程，在这里我们插入压力方程的解。这只涉及到我们已经知道的对象--所以我们只需将[2.x.223]乘以[2.x.224]，减去右边的部分，再乘以[2.x.225]的逆数。最后，我们需要分配悬挂节点的约束，以获得一个一致的流场。

[1.x.185] 




[1.x.186] [1.x.187] 。




下一个函数生成图形输出。在这个例子中，我们将使用VTK文件格式。 我们给问题中的各个变量附上名字：[2.x.226]速度的组成部分和[2.x.227]压力。   


并非所有的可视化程序都有能力将各个矢量分量组合成一个矢量，以提供矢量图；特别是对于一些基于VTK的可视化程序，这一点是成立的。在这种情况下，在包含数据的文件中应该已经描述了组件的逻辑分组为矢量的情况。换句话说，我们需要做的是为我们的输出编写者提供一种方法，让他们知道有限元的哪些分量在逻辑上形成一个矢量（在[2.x.229]空间维度上有[2.x.228]分量），而不是让他们假设我们只是有一堆标量场。 这是用[2.x.230]命名空间的成员实现的：和文件名一样，我们创建一个向量，其中第一个[2.x.231]分量指的是速度，并被赋予标签[2.x.232]我们最后推一个标签[2.x.233]来描述压力变量的分组情况。




然后，函数的其余部分与 [2.x.234] 中的相同。

[1.x.188] 




[1.x.189] [1.x.190] 。




这是[2.x.235]类中最后一个有趣的函数。 正如它的名字所示，它获取问题的解决方案并在需要的地方细化网格。其过程与[2.x.236]中的相应步骤相同，不同的是我们只根据压力的变化进行细化，也就是说，我们用ComponentMask类型的掩码对象调用Kelly误差估计器，选择我们感兴趣的压力的单一标量分量（我们通过指定我们想要的分量从有限元类得到这样一个掩码）。此外，我们没有再次粗化网格。

[1.x.191] 




[1.x.192] [1.x.193]。




斯托克斯类的最后一步和往常一样，是生成初始网格的函数，并按各自的顺序调用其他函数。   


我们从一个大小为[2.x.237]（2D）或[2.x.238]（3D）的矩形开始，在[2.x.239]中分别放置为[2.x.240]或[2.x.241]。在每个方向上以相等的网格大小开始是很自然的，所以我们在第一个坐标方向上将初始矩形细分四次。为了将创建网格所涉及的变量的范围限制在我们实际需要的范围内，我们将整个块放在一对大括号之间。

[1.x.194] 



边界指标1被设置为所有受Dirichlet边界条件约束的边界，即位于最后一个坐标方向上的0的面。详见上面的例子描述。

[1.x.195] 



然后我们在第一次求解前应用初始细化。在三维中，会有更多的自由度，所以我们在那里细化得更少。

[1.x.196] 



正如在[2.x.242]中首次看到的那样，我们在不同的细化级别上循环细化（除了第一个循环），设置自由度和矩阵，组装，求解和创建输出。

[1.x.197] 




[1.x.198] [1.x.199] 




主函数与 [2.x.243] 中相同。我们将元素度数作为参数传递，并在众所周知的模板槽中选择空间尺寸。

[1.x.200] 

[1.x.201] [1.x.202][1.x.203]。


[1.x.204][1.x.205] 。


[1.x.206][1.x.207] 。


在[2.x.244]函数中空间维度设置为2的情况下运行程序，会产生以下输出（在 "释放模式 "下，[2.x.245] ）。 

[1.x.208] 



上述整个计算在一台相当快的（以2015年的标准）机器上需要大约2秒。

我们从中立即看到的是，（外部）迭代的数量并没有随着我们细化网格而增加。这证实了介绍中的说法，即用质量矩阵对Schur补码进行预处理，确实可以得到一个与身份矩阵频谱等价的矩阵（即特征值上下有界，与网格大小或单元的相对大小无关）。换句话说，质量矩阵和Schur补码在光谱上是等价的。

在下面的图片中，我们展示了程序中前六个细化步骤的网格。 观察一下网格是如何在解决方案快速变化的区域进行细化的。在上边界，我们有迪里希特的边界条件，在左半边是-1，右半边是1，所以在[2.x.246]有一个突然的变化。同样地，在两个上角也有从Dirichlet到Neumann数据的变化，所以那里也需要细化。

 [2.x.247]  

最后，下面是一个流场的图。它显示了流体随着上边界的移动而被来自下方的物质所取代。

 [2.x.248]  

该图使用了基于VTK的可视化程序（本例中为VisIt）的能力来显示矢量数据；这是我们将使用中的有限元的速度分量声明为一组矢量分量的结果，而不是本教程程序的[2.x.249]功能中的独立标量分量。




[1.x.209][1.x.210] 。


在3D中，程序的屏幕输出看起来是这样的。

[1.x.211] 



我们再次看到，随着我们对网格的细化，外部迭代的次数并没有增加。然而，计算时间明显增加：对于上述每一次迭代分别需要大约0.14秒、0.63秒、4.8秒、35秒、2分33秒和13分12秒。这种运行时间的整体超线性（未知数的数量）增加是由于我们的内部求解器不是[2.x.250]：一个简单的实验表明，随着我们不断细化网格，反演速度-速度块[2.x.251]的平均ILU预处理的CG迭代次数会增加。

我们将解决如何改进我们的求解器[1.x.212]的问题。

至于图形输出，在求解过程中产生的网格看起来如下。

 [2.x.252]  

同样，它们基本上显示了由边界条件引入的奇异点的位置。计算出的矢量场构成了一个有趣的图形。

 [2.x.253]  

这里显示的等值线也是压力变量的等值线，显示了在不连续的速度边界条件点的奇异性。




[1.x.213][1.x.214] 


正如在生成稀疏模式时解释的那样，在使用不完全LU分解等前置条件时，必须记住自由度的编号。使用刚度矩阵中的非零元素的分布，这是最方便的可视化。

如果我们不对自由度进行特别的重新编号（即不使用[2.x.254]，而是使用[2.x.255]来确保自由度被适当地排序到矩阵和向量的相应块中），那么在二维的第一次自适应细化后，我们会得到以下的图像。

 [2.x.256]  

为了生成这样的图，你必须在设置步骤的末尾插入一段类似以下的代码。

[1.x.215] 



可以清楚地看到，非零项几乎分布在整个矩阵中。 这使得用ILU进行预处理的效率很低。ILU生成的高斯消除（LU分解）没有填充元素，这意味着更多的暂定填充元素的遗漏会导致完整分解的近似度更差。

因此，在这个方案中，我们选择了一种更先进的成分重编号。 用[2.x.257]进行重新编号，并将分量分组为速度和压力，得到的输出结果如下。

 [2.x.258]  

很明显，情况有了很大的改善。大多数元素现在都集中在矩阵中（0,0）块的对角线周围。其他区块也可以看到类似的效果。在这种情况下，ILU分解将更接近于完全的LU分解，这就提高了预处理程序的质量。值得注意的是，稀疏直接求解器UMFPACK在实际生成稀疏LU分解之前会对方程进行一些内部重新编号；该过程导致了与我们从Cuthill-McKee算法中得到的模式非常相似）。

最后，我们想仔细看看三维的稀疏模式。我们只显示了矩阵的(0,0)块，也是在一次自适应细化之后。除了矩阵大小增加的事实之外，还可以看到矩阵中多了很多条目。此外，即使是优化后的重新编号，也会有相当数量的暂定填充元素。这说明了为什么UMFPACK在三维中不是一个好的选择--完整的分解需要很多新的条目，最终无法装入物理内存（RAM）。

 [2.x.259]  




[1.x.216][1.x.217] 。


[1.x.218][1.x.219][1.x.220] 

我们在计算结果一节中看到，外迭代次数不取决于网格大小，这在可扩展性意义上是最佳的。然而，如上所述，这并不适用于整个求解器。在生成矩阵[2.x.260]和质量矩阵[2.x.261]的逆时，我们没有研究内迭代的数量。当然，这在二维情况下是没有问题的，我们用直接求解器对[2.x.262]进行预处理，逆矩阵结构的[2.x.263]操作将在一个单一的CG步骤中收敛，但这在三维情况下发生变化，我们只使用ILU预处理器。 在那里，反演[2.x.264]所需的预处理CG步骤的数量随着网格的细化而增加，每个[2.x.265]操作平均涉及上述细化步骤中的大约14、23、36、59、75和101次内部CG迭代。另一方面，在二维和三维中，应用反压力质量矩阵的迭代次数总是在5次左右）。 总而言之，大部分工作都花在了用同一矩阵[2.x.266]反复解决线性系统上。让这看起来更糟糕的是，我们实际上反转了一个矩阵，其大小约为整个系统矩阵的95%，并代表了稀疏模式中85%的非零条目。因此，自然的问题是，在计算块状系统的解时，用矩阵[2.x.267]解约15次的线性系统是否合理。

当然，答案是，我们可以用其他一些（大多数时候是更好的）方法来做。然而，必须指出的是，正如我们在早期的教程中所看到的那样，眼前的这个不确定系统对线性代数的要求确实比标准椭圆问题高得多。如果与类似规模的椭圆问题相比，其改进仍然相当不令人满意。无论如何，我们将在下面介绍一些对线性求解器的改进，这个讨论我们将在[2.x.268]程序中用额外的选项再次重新考虑。

[1.x.221][1.x.222][1.x.223] 改善线性求解过程速度的第一个尝试是选择一个dof重排序，使ILU被更接近于全LU分解，这在代码内的注释中已经提到。DoFRenumbering命名空间比较了几种对斯托克斯方程的道夫重新编号的选择。关于计算时间的最佳结果是通过调用[2.x.269]找到的，有了这个程序，内部求解器需要的操作大大减少，例如，在第4周期对[2.x.270]进行反演的内部CG迭代约为62次，而标准Cuthill-McKee-算法的迭代约为75次。另外，在第4周期，对于[2.x.271]的调用，计算时间从大约17分钟减少到11分钟。然而，King排序（以及一般由[2.x.272]命名空间提供的排序）有一个严重的缺点--它比构建中的交易版本使用更多的内存，因为它作用于抽象图而不是由三角化提供的几何图形。在目前的情况下，重新编号需要大约5倍的内存，这就产生了一个不可行的算法，在3D的最后一个周期有120万未知数。

[1.x.224][1.x.225] 

另一个改善情况的想法是选择一个预处理程序，使(0,0)矩阵[2.x.273]的CG在一个与网格无关的迭代次数中收敛，比如10到30。我们已经在[2.x.274]中看到了这样的候选方案：多网格。

[1.x.226][1.x.227] 。

[1.x.228] 即使在[2.x.275]中有一个好的预处理程序，我们仍然需要反复求解同一个线性系统（虽然右手边不同），以使舒尔补码的求解收敛。我们这里要讨论的方法是如何将内部迭代和外部迭代结合起来。如果我们坚持计算舒尔补码，就没有其他的可能性了。

另一种方法是一次性攻击块状系统，并使用近似的Schur补数作为有效的预处理程序。这个想法是这样的。如果我们找到一个块状预处理[2.x.276]，使矩阵[1.x.229] 

是简单的，那么使用该预处理程序的迭代求解器将在几次迭代中收敛。使用舒尔补码[2.x.277]，我们发现[1.x.230]似乎是一个很好的选择，因为它是一个很简单的矩阵。

似乎是一个很好的选择，因为[1.x.231] 。

这就是引言中提到的Silvester和Wathen的论文所采取的方法（不同的是Silvester和Wathen使用了右预处理）。在这种情况下，基于Krylov的迭代方法只有在应用[2.x.278]和[2.x.279]的精确求逆器时才会一步收敛，因为所有的特征值都是1（而这种方法的迭代次数是由不同特征值的数量所决定的）。下面，我们将讨论为这个问题选择一个适当的求解器。首先，我们要仔细研究一下预处理程序的实现。

由于[2.x.280]旨在成为一个预处理程序，我们将使用舒尔补码[2.x.281]和矩阵[2.x.282]的逆的近似值。因此，舒尔补集将由压力质量矩阵[2.x.283]近似，我们使用[2.x.284]的预处理器（周围没有反矩阵类）来近似[2.x.285]。

这里有一个实现块状Schur补码预处理的类。根据上面的推导，对块向量的[2.x.286]操作可以通过三个连续的操作来指定。

[1.x.232] 



由于我们现在在整个块系统上行动，我们必须忍受一个缺点：我们需要在整个块系统上执行求解器迭代，而不是较小的压力空间。

现在我们转向我们应该对块系统使用哪种求解器的问题。第一个观察结果是，所产生的预设条件矩阵不能用CG求解，因为它既不是正定也不是对称的。

deal.II库实现了几个适合手头问题的求解器。一种选择是解算器 [2.x.287] "BiCGStab"，它被用于解决 [2.x.288] 中的非对称平流问题。第二个选择，也就是我们要选择的，是[2.x.289] "GMRES"（广义最小残差）。这两种方法都有其优点和缺点--在有些问题上，两种候选方法中的一种明显优于另一种，反之亦然。[1.x.233]关于GMRES方法的文章给出了一个比较的介绍。更全面和有根据的比较可以在J.W. Demmel的书中读到（Applied Numerical Linear Algebra, SIAM, 1997, 6.6.6节）。

对于我们用ILU预处理[2.x.290]的具体问题，对于大的问题规模，我们当然需要对块系统进行数百次迭代（我们不会打败CG！）。实际上，这不利于GMRES。在GMRES迭代过程中，Krylov向量的基础被陆续建立起来，并对这些向量进行一些操作。这个基础上的向量越多，需要的操作和内存就越多。操作的数量以[2.x.291]的形式扩展，内存以[2.x.292]的形式扩展，其中[2.x.293]是Krylov基中的向量数量，[2.x.294]是（块）矩阵的大小。为了不让这些需求过度增长，deal.II将基的大小[2.x.295]默认限制为30个向量。然后，重新建立基。这种GMRES方法的实现被称为GMRES(k)，默认为 [2.x.296] 。我们通过这一限制所获得的东西，即对操作和内存需求的约束，将被我们使用不完整的基础这一事实所补偿--这将增加所需的迭代次数。

另一方面，当需要多次迭代时，BiCGStab不会变慢（一次迭代只使用前面一个步骤的结果，而不是像GMRES那样使用所有的步骤）。除了BiCGStab由于需要两个矩阵-向量乘积（相比之下，CG或GMRES只需要一个），所以每一步的成本更高之外，还有一个主要原因使得BiCGStab不适合这个问题：预处理程序通过使用InverseMatrix类应用压力质量矩阵的逆。由于向量的逆矩阵应用只是以近似的方式进行（精确的逆太昂贵了），这也会影响求解器。在BiCGStab的情况下，由于这种扰动，Krylov向量将不会是正交的。虽然这对于少量的步骤（最多50步）来说是无所谓的，但当这些扰动在迭代的粗放中增长到相当大的程度时，它就会破坏求解器的性能。

我们用BiCGStab做了一些实验，发现它在细化周期3之前比GMRES快（在3D中），但在周期4和5时变得非常慢（甚至比原来的Schur补码还慢），所以求解器在这种情况下是无用的。为逆矩阵类选择一个更尖锐的公差（[2.x.297]而不是[2.x.298]）使BiCGStab在第4周期也表现良好，但没有改变在非常大的问题上的失败。

GMRES当然也会受到近似求逆的影响，但它对正交性不那么敏感，而且在大问题上也保持了相对较好的性能，见下面的结果。

说到这里，我们转向用[2.x.299]临时向量实现GMRES的求解器调用。

[1.x.234] 



显然，需要添加include文件[2.x.300]"<lac/solver_gmres.h>"，以使其运行。我们用BlockVector模板来调用求解器，以便使GMRES能够对块状向量和矩阵进行操作。还要注意的是，在我们将信息复制到另一个矩阵之后，我们需要将系统矩阵中的（1,1）块设置为零（我们将压力质量矩阵保存在那里，这不是问题的一部分）。

使用定时器类，我们收集了一些统计数据，将块解算器的运行时间与上述问题实现的运行时间进行比较。除了两个选项的解法，我们还检查了两个变体的解法是否接近（即这个解法给出的解法确实和我们之前的解法一样），并计算了向量差的无穷大准则。

我们先来看看二维的结果。

[1.x.235] 



我们看到，块状舒尔补码预处理求解器和舒尔补码本身在求解时间上没有巨大的差别。原因很简单：我们用直接求解作为[2.x.301]的前置条件--所以我们不能指望通过避免内部迭代获得任何收益。我们看到，GMRES的迭代次数略有增加，但总的来说，这两种选择相当相似。

当然，情况在三维中发生了变化。

[1.x.236] 



在这里，块状预处理求解器明显优于Schur补数，但网格点越多，优势就越小。这是因为GMRES(k)随着问题规模的扩大比CG更差，正如我们上面所讨论的。 尽管如此，对于中等规模的问题，3-6倍的改进是相当令人印象深刻的。


[1.x.237][1.x.238] 。

这个问题的终极线性求解器可以想象为[2.x.302]的最佳预处理器（例如多网格）和上述的块状预处理器的组合，这是[2.x.303]和[2.x.304]教程程序（我们使用代数多网格方法）和[2.x.305]（我们使用几何多网格方法）中采取的方法。


[1.x.239][1.x.240] 

另一种可以考虑的可能性是不设置块状系统，而是一次性解决速度和压力的系统。可以选择用UMFPACK直接求解（2D）或用ILU预处理的GMRES（3D）。这应该是很直接的尝试。




[1.x.241][1.x.242] 。


当然，这个程序也可以作为在更有趣的情况下计算流量的基础。编写这个程序的最初动机是希望它能成为一些地球物理流动问题的起点，例如在大陆板块漂移分开的地方（例如大洋中脊）岩浆的运动。当然，在这种地方，几何形状比上面的例子更复杂，但要适应这种情况并不难。

例如，通过使用以下对边界值函数的修改 

[1.x.243] 

和以下方式生成网格作为域[2.x.306]。 

[1.x.244] 

然后我们得到断层线是弯曲的图像。 [2.x.307] [1.x.245] [1.x.246] [2.x.308] 。 

 [2.x.309] 
