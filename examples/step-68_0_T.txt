 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14 ][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28] 

 [2.x.3]  

[1.x.29] 

[1.x.30] [1.x.31] 


[1.x.32][1.x.33]。


粒子在大量应用的数值模型中发挥着重要作用。粒子通常被用作无质量的追踪器，以显示瞬时流动的动态。它们也可以作为更复杂的有限元模型的一部分发挥固有的作用，如颗粒在单元（PIC）方法[2.x.4]，或者它们甚至可以用来模拟颗粒物质的运动，如离散元素法（DEM）[2.x.5] 。在DEM的情况下，所产生的模型不再与有限元方法有关，而只是导致了一个描述粒子运动和它们碰撞动态的常微分方程系统。所有这些模型都可以使用deal.II的粒子处理能力来建立。

在本步骤中，我们使用粒子作为无质量的追踪器来说明涡流的动态。由于粒子是无质量追踪器，每个粒子[2.x.6]的位置由以下常微分方程（ODE）描述。[1.x.34] 

其中[2.x.7]是粒子[2.x.8]的位置，[2.x.9]是其位置上的流速。在本步骤中，该ODE使用显式欧拉方法进行求解。得到的方案是。[1.x.35] 

其中[2.x.10]和[2.x.11]分别是粒子[2.x.12]在时间[2.x.13]和[2.x.14]的位置，[2.x.15]是时间步骤。在本步骤中，粒子位置的速度以两种不同的方式获得。

- 通过评估粒子位置的速度函数。

- 通过在背景三角图上评价速度函数，并使用有限元支持，在粒子的位置上进行内插。

第一种方法是不实际的，因为速度曲线一般是不知道的分析。第二种方法，基于在粒子位置的内插解，完全模仿了现实计算流体动力学模拟中的做法，这也是我们在 [2.x.16] 中对粒子位置的有限元解进行评估的方式。在这一步，我们说明了这两种策略。

我们注意到，通过使用四阶Runge-Kutta方法或其他适当的方案对粒子的运动进行时间积分，可以获得更大的精度。 实施更先进的时间积分方案将是这一步骤的直接扩展。

[1.x.36][1.x.37] 


在deal.II中，[2.x.17]是非常简单和灵活的实体，可用于建立PIC、DEM或任何类型的基于粒子的模型。粒子在现实空间中有一个位置，在它们所在的元素的参考空间中有一个位置，还有一个唯一的ID。在大多数情况下，包含粒子的模拟需要大量的粒子。因此，通过一个聚集所有粒子的实体来处理所有的粒子变得很有趣。在deal.II中，这是通过使用[2.x.18]类来实现的。

默认情况下，粒子没有直径、质量或任何其他我们通常期望的物理粒子的物理属性。然而，通过ParticleHandler，粒子可以访问[2.x.19]这个PropertyPool是一个数组，可以用来存储与粒子相关的任意数量的属性。因此，用户可以建立自己的粒子求解器，并将所需的属性归属于粒子（例如，质量、电荷、直径、温度等）。在本教程中，这被用来存储流体速度的值和粒子所属的过程ID。

[1.x.38][1.x.39] 。


尽管本步骤不是计算密集型的，但包括许多粒子的模拟可能对计算要求很高，需要并行化。本步骤展示了deal.II对粒子的分布式并行能力。一般来说，在包括粒子的平行分布式模拟中，有三个主要挑战。

- 在分布式三角图上生成粒子。

- 在处理器之间交换离开本地域的粒子。

- 平衡模拟的负载，使每个处理器有类似的计算负载。这些挑战和它们在deal.II中的解决方案已经在[2.x.20]中进行了更详细的讨论，但我们将在下面进行总结。

当然，还有一些关于简单设置使用粒子的代码的问题。这些问题在 [2.x.21] 中已经基本解决了。一些更高级的技术也将在 [2.x.22] 中讨论。

[1.x.40][1.x.41] 。


以可扩展的方式生成分布式粒子并不简单，因为在找到它们所在的单元之前，必须首先确定它们所属的处理器。 deal.II通过[2.x.23]命名空间提供了许多生成粒子的功能。 其中一些粒子生成器只在本地拥有的子域上创建粒子。例如，[2.x.24]在本地子域的每个单元内的相同参考位置创建粒子，[2.x.25]使用全局定义的概率密度函数来确定本地生成粒子的数量和位置。

在其他情况下，如本步骤，粒子必须在单元上的特定位置生成，而这些单元可能只由处理器的一个子集拥有。在大多数这些情况下，粒子的插入是在非常有限的时间步长内完成的，因此，并不构成计算成本的很大一部分。对于这些情况，deal.II提供了方便的[2.x.26]，可以全局性地插入粒子，即使粒子不在启动创建粒子的调用的并行进程所拥有的单元中。生成器首先定位粒子位于哪个子域上，确定它们位于哪个单元中，并在处理器之间交换必要的信息，以确保生成的粒子具有正确的属性。因此，这种类型的粒子生成可能是通信密集型的。[2.x.27]和[2.x.28]分别使用三角形和相关DoFHandler或正交的点来生成粒子。用于生成粒子的三角形可以是用于背景网格的同一三角形，在这种情况下，这些函数与上一段中描述的[2.x.29]函数非常相似。然而，用于生成粒子的三角法也可以与背景网格的三角法不同（不匹配），这对于生成特定形状的粒子（如本例），或者在两个不同的计算网格之间传递信息（如[2.x.30]）是很有用的。 此外，[2.x.31]类提供了[2.x.32]函数，该函数能够从任意点的矢量和边界盒的全局矢量中插入粒子。在本步骤中，我们在非匹配三角形上使用[2.x.33]函数来插入位于圆盘形状的位置上的粒子。

[1.x.42][1.x.43] 


当粒子在平行分布式计算中移动时，它们可能会离开本地拥有的子域，需要转移到新的主人进程中。这种情况可能以两种非常不同的方式出现。首先，如果先前拥有的进程知道丢失的粒子的新主人（例如，因为粒子从一个处理器的本地拥有的单元移动到分布式三角形的相邻的幽灵单元），那么转移可以作为每个进程和新主人之间的点对点通信有效处理。每当粒子被分类到新单元时，这种转移就会自动发生。其次，以前的所有者可能不知道粒子被转移到哪个进程。在这种情况下，粒子会被默认丢弃，因为全局搜索所有者的成本很高。 [2.x.34]展示了这样一个被丢弃的粒子如何仍然可以被收集、解释，并可能被用户重新插入。在本例中，我们通过对时间步长施加CFL准则来防止第二种情况的发生，以确保粒子最多进入本地进程的幽灵层，因此可以自动发送到邻近的进程。

[1.x.44][1.x.45] 


在使用粒子的并行分布式计算中出现的最后一个挑战是平衡计算负载，即在网格上完成的工作，例如解决有限元问题，和在粒子上完成的工作，例如移动粒子或计算粒子之间或粒子与网格之间的力。默认情况下，例如在[2.x.35]中，deal.II将背景网格尽可能均匀地分配给可用的进程，也就是平衡每个进程中的单元数量。然而，如果一些单元比其他单元拥有更多的粒子，或者一个单元的粒子比其他单元的粒子计算成本高得多，那么这个问题就不再有效地扩展了（关于我们认为的 "可扩展 "程序的讨论，见[2.x.36]"本词汇表条目"）。因此，我们必须应用一种 "负载平衡 "的形式，这意味着我们估计与每个单元及其粒子相关的计算负载。然后，重新划分网格就会考虑到这个综合的计算负荷，而不是单元数的简化假设 [2.x.37] 。

在本节中，我们只讨论了分布式计算中针对粒子的挑战。粒子与有限元解决方案共享的并行挑战（并行输出，网格细化过程中的数据传输）可以用其他例子中已经讨论过的有限元问题的解决方案来解决。

[1.x.46][1.x.47] 。


在本步骤中，我们使用粒子作为无质量追踪器来说明一个特殊的涡流的动力学：Rayleigh--Kothe涡流。这种流动模式通常被用作界面跟踪方法（如流体体积法和水平集法）的复杂测试案例，因为它导致了流体的强烈旋转和拉长 [2.x.38] 。

这个Rayleigh-Kothe涡流的流函数[2.x.39]被定义为。

[1.x.48] 其中[2.x.40]是流动周期的一半。二维的速度曲线（[2.x.41]）为 。[1.x.49] 



速度剖面图在下面的动画中得到说明。

[1.x.50] 



可以看出，由于[2.x.42]项的存在，这个速度会周期性地逆转，材料在每一个长度为[2.x.43]的周期后会结束在其起始位置。我们将正好运行这个教程程序一个周期，并将最终的粒子位置与初始位置进行比较，以说明这个流动特性。这个例子使用测试案例产生了两个模型，这两个模型处理粒子的方式略有不同。第一个模型将精确的分析速度解作为每个粒子的速度。因此，在这个模型中，分配给粒子的速度没有错误，而在给定时间内，粒子位置与分析位置的任何偏差都是由于使用时间步进法不准确地求解粒子运动方程的错误造成的。在第二个模型中，分析速度场首先被内插到一个有限元矢量空间（以模拟速度是通过求解有限元问题得到的情况，与[2.x.44]中每个粒子的ODE取决于有限元解的方式相同）。然后在粒子的位置上对这个有限元 "解决方案 "进行评估，以解决它们的运动方程。这两种情况之间的差异允许评估所选择的有限元空间是否足够精确，以所选择的粒子平流方案的最佳收敛率来平流粒子，这个问题在实践中对确定组合算法的精度很重要（例如，见[2.x.45] ）。[1.x.51] [1.x.52] 。


[1.x.53] [1.x.54] 







[1.x.55] 



从下面的include文件中，我们导入了ParticleHandler类，该类允许你管理漂浮在[2.x.47]上的粒子集合（类型为[2.x.46]的对象，代表具有一些附加属性（例如，一个id）的点集合）。 命名空间Particles中的方法和类允许人们轻松实现Particle-In-Cell方法和分布式三角形上的粒子追踪。

[1.x.56] 



我们导入粒子发生器，使我们能够插入粒子。在本步骤中，粒子是使用非匹配的超壳三角形全局插入的。

[1.x.57] 



由于粒子没有形成三角形，它们有自己特定的DataOut类，这将使我们能够把它们写成常用的并行vtu格式（或任何数量的其他文件格式）。

[1.x.58] 




[1.x.59] [1.x.60]。




与[2.x.48]中的做法类似，我们建立了一个持有我们问题的所有参数的类，并从ParameterAcceptor类中派生出来以简化参数文件的管理和创建。   


ParameterAcceptor范式要求所有参数都可以被ParameterAcceptor方法写入。为了避免出现很难追踪的bug（比如写成`if (time = 0)`而不是`if(time == 0)`），我们在一个外部类中声明所有的参数，该类在实际的`ParticleTracking`类之前被初始化，并将其作为`const`引用传递给主类。   


该类的构造函数负责该类的成员与ParameterHandler中的相应条目之间的连接。由于使用了[2.x.49]方法，这种连接是微不足道的，但要求这个类的所有成员都是可写的。

[1.x.61] 



这个类主要由描述粒子跟踪模拟及其离散化细节的成员变量组成。下面的参数是关于输出应该写到哪里，速度的空间离散化（默认是[2.x.50]），时间步长和输出频率（在我们再次生成图形输出之前应该经过多少时间步长）。

[1.x.62] 



我们允许每个网格独立地进行精炼。在本教程中，流体网格上没有解决物理问题，其速度是通过分析计算得出的。

[1.x.63] 



还有一个任务就是声明我们在输入文件中可以接受哪些运行时参数。由于我们的参数数量非常有限，所有的参数都在同一章节中声明。

[1.x.64] 




[1.x.65][1.x.66] 。




速度曲线是作为一个函数对象提供的。这个函数在例子中是硬编码的。

[1.x.67] 



Rayleigh-Kothe顶点的速度曲线是随时间变化的。因此，必须从函数对象中收集模拟的当前时间（t）。

[1.x.68] 




[1.x.69] [1.x.70] 




现在我们准备介绍我们教程程序的主类。

[1.x.71] 



这个函数负责在背景网格之上初始生成粒子。

[1.x.72] 



当速度剖面被内插到粒子的位置时，首先必须用自由度来存储。因此，与其他并行情况一样（例如[2.x.51]），我们在背景网格上初始化自由度。

[1.x.73] 



在其中一个测试案例中，函数被映射到背景网格上，并使用有限元插值来计算粒子位置的速度。这个函数计算三角形的支持点处的函数值。

[1.x.74] 



接下来的两个函数分别负责对速度场在粒子位置插值或分析计算的情况进行显式欧拉时间积分的步骤。

[1.x.75] 



`cell_weight()`函数向三角计算表明在这个单元上预计会发生多少计算工作，因此需要对域进行划分，以使每个MPI等级得到大致相等的工作量（可能不是相等的单元数量）。虽然该函数是从外部调用的，但它与该类内部的相应信号相连，因此它可以是 "私有 "的。

[1.x.76] 



下面两个函数分别负责输出粒子的模拟结果和背景网格上的速度曲线。

[1.x.77] 



这个类的私有成员与其他并行deal.II例子相似。参数被存储为`const`成员。值得注意的是，我们保留了`Vortex`类的成员，因为它的时间必须随着仿真的进行而被修改。







[1.x.78] 




[1.x.79] [1.x.80] 。





[1.x.81] [1.x.82]. 




构造函数和析构函数是相当微不足道的。它们与 [2.x.52] 中的做法非常相似。我们将我们想要工作的处理器设置为所有可用的机器（`MPI_COMM_WORLD`），并初始化 [2.x.53] 变量，只允许处理器0输出任何东西到标准输出。







[1.x.83] 




[1.x.84][1.x.85] 。




这个函数是允许我们动态平衡本例计算负载的关键组件。该函数为每个单元分配一个权重，代表该单元的计算工作。在这里，大部分的工作预计会发生在粒子上，因此这个函数的返回值（代表 "这个单元的工作"）是根据当前单元中的粒子数量计算的。该函数与三角形内部的cell_weight()信号相连，每一个单元将被调用一次，每当三角形在等级之间重新划分领域时（该连接是在该类的generate_particles()函数中创建的）。

[1.x.86] 



我们不给不属于我们的单元分配任何权重（即人工或幽灵单元）。

[1.x.87] 



这决定了粒子工作与细胞工作相比有多重要（默认情况下每个细胞的权重为1000）。我们将每个粒子的权重设置得更高，以表明在这个例子中，粒子载荷是唯一一个对分配细胞很重要的。这个数字的最佳值取决于应用，可以从0（廉价的粒子操作，昂贵的单元操作）到远远大于1000（昂贵的粒子操作，廉价的单元操作，像本例中推测的那样）。

[1.x.88] 



这个例子没有使用自适应细化，因此每个单元都应该有`CELL_PERSIST`的状态。然而这个函数也可以用来在细化过程中分配负载，因此我们也考虑细化或粗化的单元。

[1.x.89] 




[1.x.90] [1.x.91] 




该函数生成示踪粒子和这些粒子演化的背景三角图。

[1.x.92] 



我们创建一个超立方体三角形，并对其进行全局细化。这个三角形覆盖了粒子的全部轨迹。

[1.x.93] 



为了在重新划分三角形时考虑粒子，该算法需要知道三件事。     


1. 给每个单元分配多少权重（里面有多少粒子）；2.在运送数据之前如何包装粒子；3.在重新分区之后如何拆开粒子。     


我们将正确的函数附加到[2.x.54]里面的信号，这些信号将在每次调用repartition()函数时被调用。这些连接只需要创建一次，所以我们不妨在这个类的构造函数中设置它们，但为了这个例子，我们想把粒子相关的指令分组。

[1.x.94] 



这将初始化粒子所处的背景三角，以及粒子的属性数量。

[1.x.95] 



我们创建了一个粒子三角图，该三角图仅用于生成将被用于插入粒子的点。这个三角形是一个超壳，它从模拟域的中心偏移。这将被用来生成一个充满粒子的圆盘，这将允许轻松地监测由于涡流而产生的运动。

[1.x.96] 



我们为粒子发生器生成必要的边界盒。这些边界框是快速识别插入的粒子位于哪个过程的子域中，以及哪个单元拥有它的必要条件。

[1.x.97] 



我们生成一个空的属性向量。一旦粒子被生成，我们将把这些属性归于粒子。

[1.x.98] 



我们在单点正交的位置生成粒子。因此，在每个单元的中心点将生成一个粒子。

[1.x.99] 




[1.x.100] [1.x.101] 




该函数设置了用于速度插值的背景自由度，并分配了存储整个速度场解决方案的场向量。

[1.x.102] 



该函数负责将涡流速度场内插到场矢量上。这可以通过使用[2.x.55]函数相当容易地实现。

[1.x.103] 




[1.x.104] [1.x.105]。




我们使用分析定义的速度场对粒子的轨迹进行积分。这展示了粒子的一个相对琐碎的用法。

[1.x.106] 



使用粒子迭代器在域中的所有粒子上循环运行 

[1.x.107] 



我们使用粒子的当前位置来计算它们的速度。

[1.x.108] 



这将更新粒子的位置，并将旧的位置设置为等于粒子的新位置。

[1.x.109] 



我们在粒子属性中存储处理器ID（一个标量）和粒子速度（一个矢量）。在这个例子中，这样做纯粹是为了可视化的目的。

[1.x.110] 



与前面的函数不同，在这个函数中，我们通过将自由度上的速度场的值插值到粒子的位置来整合粒子的轨迹。

[1.x.111] 



我们循环计算所有的局部粒子。尽管这可以直接通过循环所有的单元来实现，但这将迫使我们循环许多不包含粒子的单元。相反，我们在所有的粒子上循环，但是，我们得到粒子所在单元的参考，然后在该单元内的所有粒子上循环。这使我们能够从 "速度场 "向量中收集一次速度值，并将其用于该单元中的所有粒子。

[1.x.112] 



接下来，通过评估粒子位置的有限元解来计算粒子位置上的速度。这基本上是第19步中粒子平流功能的优化版本，但我们不是为每个单元创建正交对象和FEValues对象，而是通过手工进行评估，这在一定程度上更有效率，而且只对本教程有意义，因为粒子工作是整个程序的主要成本。

[1.x.113] 



同样，我们将粒子的速度和处理器的ID存储在粒子的属性中，以达到可视化的目的。

[1.x.114] 




[1.x.115][1.x.116] 。




接下来的两个函数负责将粒子和背景网格用pvtu记录写入vtu。这确保了在并行启动仿真时，仿真结果可以被可视化。

[1.x.117] 



将解决方案的数据附加到data_out对象中 

[1.x.118] 




[1.x.119] [1.x.120] 这个函数协调了整个仿真过程。它与其他时间相关的教程程序非常相似--以[2.x.56]或[2.x.57]为例。注意，我们使用DiscreteTime类来监控时间、时间步长和[2.x.58]数。这个函数相对来说是比较简单的。







[1.x.121] 



我们通过在分析法和插值法的情况下做一个显式欧拉迭代，时间步长为0，来设置粒子的初始属性。

[1.x.122] 



粒子是通过循环的方式随时间推移而平移的。

[1.x.123] 



在粒子被移动后，有必要确定它们现在所处的单元。这可以通过调用[2.x.59]来实现。 

[1.x.124] 




[1.x.125] [1.x.126] 。




代码的其余部分，即`main()`函数，是标准的。我们注意到，我们用分析速度和插值速度运行粒子跟踪，并产生两种结果 

[1.x.127] 

[1.x.128][1.x.129] 。


运行该程序的目录中默认包含一个参数文件的例子。如果你没有在命令行中指定参数文件作为参数，程序将默认尝试读取文件 "参数.prm"，并执行代码。

在任何数量的核上，模拟输出将看起来像。

[1.x.130] 



我们注意到，默认情况下，仿真会以分析速度运行粒子跟踪2000次，然后从头开始，以相同的时间运行速度插值的粒子跟踪。每隔10次迭代就会写入结果。

[1.x.131][1.x.132] 。


下面的动画显示了粒子在流场作用下的运动轨迹。我们看到，在流动的整个过程中，粒子又回到了它们的初始配置，这也是我们所期望的。

[1.x.133] 



[1.x.134][1.x.135]。


下面的动画显示了动态负载平衡的影响。我们清楚地看到，子域适应自己，以平衡每个子域的粒子数量。然而，完美的负载平衡并没有达到，部分原因是由于背景网格的粗糙性。

[1.x.136] 




[1.x.137][1.x.138]。


这个程序强调了在deal.II中处理粒子的一些主要能力，特别是它们在分布式并行模拟中的能力。然而，这个步骤可以以多种方式进行扩展。

- 高阶时间积分（例如使用Runge-Kutta 4方法）可以用来提高精度，或者在相同精度下允许更大的时间步长。

- 完整的运动方程（含惯性）可以为粒子求解。在这种情况下，粒子需要有额外的属性，如质量，如[2.x.60]，如果还想考虑与流体的相互作用，则需要考虑其直径。

- 耦合到流动求解器。这一步可以直接与任何解决斯托克斯方程（[2.x.61], [2.x.62]）或纳维-斯托克斯方程（例如[2.x.63]）的并行程序相耦合。

- 计算两种模型之间最终粒子位置的差异，可以量化插值误差对粒子运动的影响。[1.x.139] [1.x.140] [2.x.64] 。 

 [2.x.65] 
