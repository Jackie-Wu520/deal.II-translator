 [2.x.0] [2.x.1]  

本教程取决于 [2.x.2] , [2.x.3] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19 ][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38] 

 [2.x.4]  

[1.x.39] [2.x.5] [2.x.5]。 




 [2.x.6] 作为这个程序的先决条件，你需要安装HDF5、复杂的PETSc和p4est库。在[1.x.40]文件中描述了deal.II与这些附加库的安装情况。

[1.x.41][1.x.42] 。

声子晶体是一种周期性的纳米结构，它可以改变机械振动或[声子]的运动（https://en.wikipedia.org/wiki/Phonon）。声子结构可以用来分散、引导和限制机械振动。这些结构在[量子信息](https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391)方面有潜在的应用，并已被用于研究[宏观量子现象](https://science.sciencemag.org/content/358/6360/203)。声波晶体通常是在[洁净室]中制造的(https://en.wikipedia.org/wiki/Cleanroom)。

在本教程中，我们将展示如何设计一个[声子超晶格腔](https://doi.org/10.1103/PhysRevA.94.033813)，这是一种特殊类型的声子晶体，可用于限制机械振动。声子超晶格空腔是由两个[分布式布拉格反射器](https://en.wikipedia.org/wiki/Distributed_Bragg_reflector)、镜子和一个[2.x.7]空腔组成，其中[2.x.8]是声学波长。声学DBRs是周期性结构，其中一组具有对比物理特性（声速指数）的双层堆栈被重复[2.x.9]次。超晶格空腔通常是通过[分子束外延](https://en.wikipedia.org/wiki/Molecular-beam_epitaxy)在[砷化镓](https://en.wikipedia.org/wiki/Gallium_arsenide)晶圆上生长的。双层对应于砷化镓/砷化铝镜像对。如下图所示，镜像层（棕色和绿色）的厚度为[2.x.10]，空腔（蓝色）的厚度为[2.x.11] 。

 [2.x.12]  

在本教程中，我们计算了[带隙](https://en.wikipedia.org/wiki/Band_gap)和声子超晶格空腔的机械共振，但这里介绍的代码可以很容易地用于设计和计算其他类型的[声子晶体](https://science.sciencemag.org/content/358/6360/203)。

该装置是一个波导，其中波从左到右。本教程的模拟是在二维中完成的，但代码是独立于尺寸的，可以很容易地用于三维模拟。波导的宽度等于域的[2.x.13]维，波导的长度等于域的[2.x.14]维。有两种取决于波导宽度的制度。

- 单一模式。在这种情况下，结构的宽度要比波长小得多。  这种情况可以用有限元法（我们在此采取的方法）或用简单的半分析法[一维转移矩阵形式]（https://en.wikipedia.org/wiki/Transfer_matrix）来解决。

- 多模。在这种情况下，结构的宽度比波长大。  这种情况可以用有限元法或[散射矩阵形式主义](https://doi.org/10.1103/PhysRevA.94.033813)来解决。  尽管我们在本教程中没有研究这种情况，但通过增加波导宽度参数（jupyter笔记本中的`dimension_y'），很容易达到多模制度。

本教程的模拟是在频域中进行的。为了计算传输光谱，我们使用了一个在时域[FDTD](https://meep.readthedocs.io/en/latest/Python_Tutorials/Resonant_Modes_and_Transmission_in_a_Waveguide_Cavity/)模拟中常用的[程序](https://en.wikipedia.org/wiki/Finite-difference_time-domain_method)。在结构的左侧产生一个特定频率的脉冲，在结构的右侧测量传输的能量。仿真运行了两次。首先，我们用声子结构运行模拟，并测量传输的能量。

 [2.x.15]  

然后，我们运行没有声学结构的模拟，测量传输的能量。我们使用没有结构的模拟来进行校准。

 [2.x.16]  

传输系数对应于第一个模拟的能量除以校准能量。我们对每个频率步骤重复这一程序。


[1.x.43][1.x.44] 

我们在这里想要模拟的是弹性波的传输。因此，对问题的正确描述使用了弹性方程，在时域中由[1.x.45]给出，其中刚度张量[2.x.17]取决于空间坐标，应变是位移的对称梯度，由[1.x.46]给出。

[完全匹配层（PML）](https://en.wikipedia.org/wiki/Perfectly_matched_layer)可以用来截断边界处的解决方案。PML是一种导致复杂坐标拉伸的变换。

本教程程序没有采用时域方法，而是通过对时间变量进行傅里叶变换，将上述方程转换为频域。然后，频域中的弹性方程如下[1.x.47] 。

其中系数[2.x.18]说明了吸收的情况。在三维有3个[2.x.19]系数，在二维有2个系数。[2.x.20]的虚部在PML外等于零。PML仅对精确的波浪方程是无反射的。当方程组被离散化时，PML就不再是无反射的了。只要介质是缓慢变化的，反射就可以变得任意小，见[绝热定理](https://doi.org/10.1103/PhysRevE.66.066608)。在代码中，已经使用了PML的二次开启。线性和立方开启也是[已知可行的](https://doi.org/10.1364/OE.16.011376)。这些方程可以扩展为[1.x.48][1.x.49]，其中重复指数的求和（这里是[2.x.21]，以及[2.x.22]和[2.x.23]）一如既往地被暗示。请注意，在应用PML的复数坐标拉伸后，应变不再是对称的了。这组方程可以写成[1.x.50]。

与应变相同，应力张量在PML内也不是对称的（[2.x.24]）。事实上，PML内部的场不是物理的。介绍张量[2.x.25]和[2.x.26]是有用的。[1.x.51] 

我们可以乘以[2.x.27]并在域[2.x.28]上进行积分，并通过部分积分。[1.x.52] 

正是这组方程，我们要为一组频率[2.x.29]求解，以计算传输系数与频率的关系。线性系统成为[1.x.53]。



[1.x.54][1.x.55] 。

在本教程中，我们使用python[jupyter notebook](https://github.com/dealii/dealii/blob/phononic-cavity/examples/ [2.x.30] / [2.x.31] .ipynb)来设置参数和运行仿真。首先，我们创建一个HDF5文件，在其中存储参数和模拟结果。

每个模拟（位移和校准）都存储在一个单独的HDF5组中。

[1.x.56] 

[1.x.57] [1.x.58] 。


[1.x.59] [1.x.60]。




我们在这个程序中需要的大部分包含文件已经在以前的程序中讨论过了，特别是在 [2.x.32] . 

[1.x.61] 



下面的头文件提供了我们用来表示材料属性的张量类。

[1.x.62] 



下面的标头对于deal.II的HDF5接口是必要的。

[1.x.63] 



这个标头是我们用来评估模拟结果的函数[2.x.33]所需要的。

[1.x.64] 



我们在函数[2.x.35]中使用的函数[2.x.34]需要这个标头。 

[1.x.65] 




[1.x.66] [1.x.67] 以下类用于存储模拟的参数。





[1.x.68] [1.x.69] 该类用于定义结构左侧的力脉冲。

[1.x.70] 



变量`data`是[2.x.36]，所有的仿真结果都将被储存在其中。注意，变量[2.x.37][2.x.38][2.x.39]和[2.x.40]指向HDF5文件的同一组。当[2.x.41]被复制时，它将指向HDF5文件的同一组。

[1.x.71] 



仿真参数作为HDF5属性存储在`data`中。以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造器读取。

[1.x.72] 



在这个特定的模拟中，力只有一个[2.x.42]分量，[2.x.43] 。

[1.x.73] 




[1.x.74] [1.x.75] 该类用于定义完美匹配层（PML）的形状，以吸收向边界移动的波。

[1.x.76] 



 [2.x.44] 所有的模拟结果将被储存在其中。

[1.x.77] 



和以前一样，在jupyter笔记本中定义以下属性，作为HDF5属性存储在`data`中，然后由构造器读取。

[1.x.78] 




[1.x.79] [1.x.80] 这个类是用来定义质量密度的。

[1.x.81] 



 [2.x.45] 所有的模拟结果将被储存在其中。

[1.x.82] 



和以前一样，在jupyter笔记本中定义以下属性，作为HDF5属性存储在`data`中，然后由构造函数读取。

[1.x.83] 




[1.x.84] [1.x.85] 这个类包含所有将在模拟中使用的参数。

[1.x.86] 



 [2.x.46] 所有的模拟结果将被储存在其中。

[1.x.87] 



和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。

[1.x.88] 




[1.x.89] [1.x.90] 质量和刚度矩阵的计算非常昂贵。这些矩阵对所有的频率步骤都是一样的。右手边的向量对所有的频率步骤也是一样的。我们用这个类来存储这些对象，并在每个频率步骤中重新使用它们。请注意，这里我们不存储集合的质量和刚度矩阵以及右手边，而是存储单个单元的数据。QuadratureCache "类与 "PointHistory "类非常相似，后者已在 [2.x.47] 中使用。

[1.x.91] 



我们在变量mass_coefficient和stiffness_coefficient中存储质量和刚度矩阵。我们还存储了右手边和JxW值，这些值对所有的频率步骤都是一样的。

[1.x.92] 




[1.x.93] [1.x.94] 




该函数返回材料的刚度张量。为了简单起见，我们认为刚度是各向同性和同质的；只有密度 [2.x.48] 取决于位置。正如我们之前在 [2.x.49] 中所表明的，如果刚度是各向同性和均质的，刚度系数 [2.x.50] 可以表示为两个系数 [2.x.51] 和 [2.x.52] 的函数。系数张量简化为 [1.x.95] 。

[1.x.96] 




[1.x.97] [1.x.98] 。




接下来让我们声明这个程序的主类。其结构与[2.x.53]的教程程序非常相似。主要的区别是。

- 对频率值的扫描。

- 我们在`quadrature_cache`中保存刚度和质量矩阵，并在每个频率步骤中使用它们。

- 我们在HDF5文件中存储每个频率步骤的探头测量的能量。

[1.x.99] 



在每一个频率步骤之前调用，为缓存变量设置一个原始状态。

[1.x.100] 



这个函数在频率向量上循环，为每个频率步骤运行仿真。

[1.x.101] 



参数被存储在这个变量中。

[1.x.102] 



我们把每个单元的质量和刚度矩阵存储在这个向量中。

[1.x.103] 



这个向量包含我们要模拟的频率范围。

[1.x.104] 



这个向量包含测量探头各点的坐标[2.x.54]。

[1.x.105] 



HDF5数据集用于存储频率和`探针位置`向量。

[1.x.106] 



HDF5数据集，用于存储探头测量的能量值。

[1.x.107] 




[1.x.108] [1.x.109] [1.x.109]。





[1.x.110] [1.x.110] [1.x.111]。




构造函数使用[2.x.56]函数从[2.x.55]`data`中读取所有参数。

[1.x.112] 



这个函数定义了力矢量脉冲的空间形状，其形式为高斯函数。

[1.x.113] 

其中[2.x.57]是取力的最大振幅，[2.x.58]和[2.x.59]是[2.x.60]和[2.x.61]成分的标准偏差。请注意，脉冲已被裁剪为[2.x.62]和[2.x.63] 。

[1.x.114] 




[1.x.115] [1.x.116] 。




和以前一样，构造函数使用[2.x.65]函数从[2.x.64]`data`中读取所有参数。正如我们所讨论的，在jupyter笔记本中已经定义了PML的二次开机。通过改变参数`pml_coeff_degree`，可以使用线性、立方或其他幂度。参数`pml_x`和`pml_y`可以用来打开和关闭`x`和`y`PML。

[1.x.117] 



`x`分量的PML系数的形式为[2.x.66] 。 

[1.x.118] 




[1.x.119] [1.x.120]。




这个类是用来定义质量密度的。正如我们之前所解释的，一个声学超晶格空腔是由两个[分布式反射器](https://en.wikipedia.org/wiki/Band_gap)、镜子和一个[2.x.67]空腔组成，其中[2.x.68]是声学波长。声学DBRs是一种周期性结构，其中一组具有对比物理特性（声速指数）的双层叠层被重复[2.x.69]次。波速的变化是由具有不同密度的层交替产生的。

[1.x.121] 



为了提高精度，我们使用了[子像素平滑法](https://meep.readthedocs.io/en/latest/Subpixel_Smoothing/)。

[1.x.122] 



声速由[1.x.123]定义，其中[2.x.70]是有效弹性常数，[2.x.71]是密度。这里我们考虑波导宽度远小于波长的情况。在这种情况下，可以证明对于二维的情况[1.x.124]和三维的情况[2.x.72]等于杨氏模量。[1.x.125] 

[1.x.126] 



密度[2.x.73]采取以下形式 <img alt="声学超晶格空腔" src="https://www.dealii.org/images/steps/developer/ [2.x.74] .04.svg" height="200" /> 其中棕色代表材料_a，绿色代表材料_b。

[1.x.127] 



这里我们定义了[subpixel smoothing](https://meep.readthedocs.io/en/latest/Subpixel_Smoothing/)，它提高了模拟的精度。

[1.x.128] 



然后是腔体 

[1.x.129] 



材料_A层 

[1.x.130] 



材料_B层 

[1.x.131] 



最后是默认的 material_a。

[1.x.132] 




[1.x.133] [1.x.134] 




构造函数使用[2.x.76]函数从[2.x.75]`data`读取所有参数。

[1.x.135] 




[1.x.136] [1.x.137]。




我们需要为质量和刚度矩阵以及右手边的向量保留足够的空间。

[1.x.138] 




[1.x.139] [1.x.140] [1.x.140]。





[1.x.141][1.x.142] 。




这与 [2.x.77] 的构造函数非常相似。此外，我们创建了HDF5数据集`frequency_dataset`，`position_dataset`和`displacement`。注意在创建HDF5数据集时使用了`template'关键字。这是C++的要求，使用`template`关键字是为了将`create_dataset`作为一个依赖的模板名称。

[1.x.143] 




[1.x.144][1.x.145] 。




这个函数没有什么新内容，与[2.x.78]的唯一区别是，我们不必应用边界条件，因为我们使用PML来截断域。

[1.x.146] 




[1.x.147] [1.x.148]。




这个函数也与[2.x.79]非常相似，尽管有明显的区别。我们为每个频率/欧米茄步骤组装系统。在第一步，我们设置`calculate_quadrature_data = True'，我们计算质量和刚度矩阵以及右手边的矢量。在随后的步骤中，我们将使用这些数据来加速计算。

[1.x.149] 



这里我们存储右手边的值，rho和PML。

[1.x.150] 



我们计算在jupyter笔记本中已经定义的[2.x.80]和[2.x.81]的刚度张量。注意，与[2.x.82]相反，刚度在整个领域中是恒定的。

[1.x.151] 



我们使用与[2.x.83]相同的方法处理矢量值问题。

[1.x.152] 



只有当我们要计算质量和刚度矩阵时，我们才必须计算右手边的值、rho和PML。否则我们可以跳过这个计算，这将大大减少总的计算时间。

[1.x.153] 



我们在 [2.x.84] 中已经这样做了。获得一个指向当前单元本地正交缓存数据的指针，作为防御措施，确保这个指针在全局数组的范围内。

[1.x.154] 



quadrature_data变量用于存储质量和刚度矩阵、右手边向量和`JxW`的值。

[1.x.155] 



下面我们声明力向量和PML的参数 [2.x.85] 和 [2.x.86] 。

[1.x.156] 



下面的块只在第一个频率步骤中计算。

[1.x.157] 



存储`JxW`的值。

[1.x.158] 



将向量转换为张量并计算xi 

[1.x.159] 



这里我们计算[2.x.87]和[2.x.88]的张量。

[1.x.160] 



计算质量矩阵的值。

[1.x.161] 



循环计算刚度张量的[2.x.89]指数。

[1.x.162] 



这里我们计算刚度矩阵。注意，由于PML的存在，刚度矩阵不是对称的。我们使用梯度函数（见[文件](https://www.dealii.org/current/doxygen/deal.II/group__vector__valued.html)），它是一个 [2.x.90] 。矩阵[2.x.91]由条目[1.x.163]组成 注意指数[2.x.92]和[2.x.93]的位置以及我们在本教程中使用的符号。 [2.x.94] . 由于刚度张量不是对称的，所以很容易出错。

[1.x.164] 



我们将刚度矩阵的值保存在quadrature_data中 

[1.x.165] 



并在quadrature_data中保存右手边的值。

[1.x.166] 



我们再次在单元格的自由度上循环，计算系统矩阵。这些循环真的很快，因为我们已经计算了刚度和质量矩阵，只有[2.x.95]的值会改变。

[1.x.167] 




[1.x.168] [1.x.169]。




这比[2.x.96]中更简单。我们使用并行的直接求解器MUMPS，它比迭代求解器需要更少的选项。缺点是它不能很好地扩展。用迭代求解器来解决Helmholtz方程并不简单。移位拉普拉斯多网格法是一种众所周知的预处理该系统的方法，但这超出了本教程的范围。

[1.x.170] 




[1.x.171][1.x.172] 。




我们用这个函数来计算位置向量的值。

[1.x.173] 



由于运算符+和-的重载方式是为了减去两个点，所以必须做以下工作。`Point_b<dim> + (-Point_a<dim>)`。

[1.x.174] 




[1.x.175][1.x.176] 。




该函数在HDF5文件中存储探头测量的能量。

[1.x.177] 



我们存储[2.x.97]方向的位移；[2.x.98]方向的位移可以忽略不计。

[1.x.178] 



向量坐标包含HDF5文件中位于本地所有单元中的探针点的坐标。向量displacement_data包含这些点的位移值。

[1.x.179] 



首先，我们要找出该点是否在本地拥有的单元中。

[1.x.180] 



然后我们可以将探针中各点的位移值储存在`displacement_data`中。

[1.x.181] 



我们将位移数据写入HDF5文件中。调用[2.x.99]是MPI集体的，这意味着所有的进程都要参与。

[1.x.182] 



因此，即使进程没有数据要写，它也必须参与到集体调用中。为此，我们可以使用[2.x.100]注意，我们必须指定数据类型，在这种情况下[2.x.101]  

[1.x.183] 



如果输入文件中的变量`save_vtu_files`等于`True`，那么所有数据将被保存为vtu。写入`vtu'文件的程序已经在 [2.x.102] 中描述。

[1.x.184] 



在我们不感兴趣的单元格上，将各自的值设置为一个假值，以确保如果我们的假设有什么错误，我们会通过查看图形输出发现的。

[1.x.185] 




[1.x.186] [1.x.187] 




这个函数写入尚未写入的数据集。

[1.x.188] 



向量`频率`和`位置`对所有进程都是一样的。因此，任何进程都可以写入相应的`数据集'。因为调用[2.x.103]是MPI集体的，其余的进程将不得不调用[2.x.104] 。 

[1.x.189] 




[1.x.190] [1.x.191] 。




我们在计算开始时使用这个函数来设置缓存变量的初始值。这个函数在 [2.x.105] 中已经描述过。与 [2.x.106] 的函数没有区别。

[1.x.192] 




[1.x.193] [1.x.194] 。




为清楚起见，我们将[2.x.107]的函数`run`分为函数`run`和`frequency_sweep`。在函数`frequency_sweep`中，我们对频率向量进行迭代。

[1.x.195] 



只写一次仿真参数 

[1.x.196] 



我们计算这个特定步骤的频率和omega值。

[1.x.197] 



在第一个频率步骤中，我们计算质量和刚度矩阵以及右手边。在随后的频率步骤中，我们将使用这些值。这大大地改善了计算时间。

[1.x.198] 




[1.x.199][1.x.200] 。




这个函数与 [2.x.108] 中的函数非常相似。

[1.x.201] 




[1.X.202] [1.X.203] 。




主函数与 [2.x.109] 中的函数非常相似。

[1.x.204] 



每个模拟（位移和校准）都存储在一个单独的HDF5组中。

[1.x.205] 



对于这两个组的名称，我们现在创建组并将属性放入这些组中。具体来说，这些是。

- 波导的尺寸（在[2.x.110]和[2.x.111]方向）。

- 探针的位置（在[2.x.112]和[2.x.113]方向）。

- 探针中的点的数量 

- 全局细化水平 

- 腔体谐振频率 

- 镜像对的数量 

- 材料属性 

- 力的参数 

- PML参数 

- 频率参数 







[1.x.206] 



位移模拟。参数从位移HDF5组中读取，结果保存在同一HDF5组中。

[1.x.207] 



校准模拟。从校准HDF5组中读取参数，并将结果保存在同一HDF5组中。

[1.x.208] 

[1.x.209][1.x.210]。


[1.x.211][1.x.212]。


在[jupyter notebook](https://github.com/dealii/dealii/blob/phononic-cavity/examples/ [2.x.114] / [2.x.115] .ipynb)中用以下代码分析结果 

[1.x.213] 



声腔的特点是[共振频率](https://en.wikipedia.org/wiki/Resonance)和[品质因子](https://en.wikipedia.org/wiki/Q_factor)。质量因子等于谐振器中储存的能量和每周期耗散的能量之间的比率，这大约相当于谐振频率和[半最大值全宽（FWHM）](https://en.wikipedia.org/wiki/Full_width_at_half_maximum)之间的比率。FWHM等于振动功率大于谐振频率的一半的带宽。[1.x.214] 

机械共振[2.x.116]振幅的平方作为频率的函数具有高斯形状[1.x.215]，其中[2.x.117]是共振频率，[2.x.118]是耗损率。我们使用jupyter笔记本中的前一个方程式来拟合机械共振。

鉴于我们为参数选择的值，人们可以通过分析来估计共振频率。事实上，这一点随后被我们在这个程序中得到的结果所证实：声子超晶格空腔在20GHz时表现出机械共振，质量系数为5046。下面的图片显示了在共振频率附近的传输振幅和相位与频率的关系。

 [2.x.119] [2.x.120]。 

上述图像表明，周期性结构有其预期的效果：它确实只让非常特定频率的波通过，而所有其他波都被反射。当然，这正是人们建造这类装置的目的。但这并不十分容易。在实践中，实际上只有一个 "带隙"，也就是说，该设备只在一定的频率范围内阻止20GHz频率以外的波。事实上，要想知道这个被阻挡的 "间隙 "有多大，我们可以通过输入文件中的适当参数将频率范围扩大到16GHz。然后我们得到以下图像。

 [2.x.121]  

这张图片表明，在18到22GHz左右的范围内，实际上只有频率为20GHz的波被允许通过，但在这个范围之外，还有很多其他频率的波可以通过设备。

[1.x.216][1.x.217] 


我们可以用Paraview或VisIt检查模式轮廓。正如我们所讨论的，在共振时，所有的机械能都被传递，运动的振幅在腔内被放大。可以看出，PMLs对于截断解决方案是相当有效的。下面的图片显示了共振时的模式轮廓。

 [2.x.122]  

另一方面，在共振之外，所有的机械能都被反射。下图显示了19.75GHz时的轮廓。注意力脉冲和反射波在位置[2.x.123]的干扰。

 [2.x.124]  

[1.x.218][1.x.219] 。


声波超晶格空腔在[量子光学力学](https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391)中找到了应用。这里我们介绍了二维超晶格空腔的模拟，但这个代码也可以用来模拟 "现实世界 "的三维器件，如[微柱超晶格空腔](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.99.060101)，它是研究宏观量子现象的有希望的候选者。微柱超晶格空腔的20GHz模式本质上是一个机械谐波振荡器，与环境隔离得非常好。如果该装置在稀释冰箱中被冷却到20mK，那么该模式就会成为一个宏观的量子谐波振荡器。


[1.x.220][1.x.221] 


我们可以不在C++文件中设置参数，而是使用python脚本设置参数，并将其保存在我们将用于模拟的HDF5文件中。然后deal.II程序将从HDF5文件中读取参数。

[1.x.222] 



为了读取HDF5参数，我们必须使用[2.x.125]标志。

[1.x.223] 

[1.x.224] [1.x.225] [2.x.126]。 

 [2.x.127] 
