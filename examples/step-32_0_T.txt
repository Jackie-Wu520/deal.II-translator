 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] , [2.x.3] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23 ][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43][1.x.44][1.x.45] 

 [2.x.4]  

[1.x.46][1.x.47][1.x.48][1.x.49][1.x.50] 


[1.x.51] [1.x.52][1.x.53]。


这个程序所做的事情与[2.x.5]已经做的差不多：它求解描述温度不平衡的流体运动的Boussinesq方程。因此，我们在[2.x.6]中描述的所有方程仍然成立：我们使用相同的有限元方案、相同的时间步进算法以及或多或少相同的温度平流-扩散方程的稳定方法来解决相同的一般偏微分方程（只做了些许修改以调整问题设置的真实性）。因此，你可能首先要了解那个程序&mdash;和它的实现&mdash;，然后再研究当前的程序。

[2.x.7]与当前程序的不同之处在于，在这里我们想以%并行的方式做事，既利用集群中许多机器的可用性（基于MPI的并行化），也利用单台机器中的许多处理器内核（基于线程的并行化）。因此，本程序的主要工作是引入必要的变化，以利用这些%并行计算资源的可用性。在这方面，它建立在[2.x.8]程序的基础上，该程序首先介绍了大部分%并行功能的必要类，并在[2.x.9]中展示了如何对一个矢量值问题进行处理。

除了这些变化之外，我们还使用了一个略微不同的预处理程序，而且我们将不得不做一些改变，这与我们想在这里解决一个[1.x.54]问题而不是一个模型问题有关。特别是后者，将要求我们考虑比例问题，以及所考虑的方程中所有这些参数和系数的实际含义。我们将首先讨论影响数学公式和求解器结构变化的问题，然后讨论如何将事情并行化，最后讨论我们将考虑的实际测试案例。


[1.x.55][1.x.56] 


在[2.x.10]中，我们对速度和压力场使用了以下斯托克斯模型。[1.x.57] 

第一个方程的右手边显得有点无动于衷。事情的真相应该是这样的。我们需要作用在流体上的外力，我们假设这些外力只由重力给出。在目前的情况下，我们假设流体确实为了这个重力的目的而轻微膨胀，但还不足以让我们需要修改不可压缩性条件（第二个方程）。这意味着，为了右手边的目的，我们可以假设[2.x.11] 。一个可能不完全合理的假设是，我们可以假设密度作为温度的函数的变化很小，导致形式为[2.x.12] 的表达，即在参考温度下密度等于[2.x.13]，并且随着温度的升高（随着材料的膨胀）线性下降。然后，力平衡方程看起来正确地写成这样。[1.x.58] 

现在请注意，重力是由重力势产生的，如[2.x.14] ，因此我们可以将其重新写成如下。[1.x.59] 

右边的第二项是与时间无关的，因此我们可以引入一个新的 "动态 "压力[2.x.15]，这样斯托克斯方程就变成了。[1.x.60] 

这正是我们在[2.x.16]中使用的形式，这样做是合适的，因为流体流动的所有变化只由温度差异导致的动态压力驱动。(换句话说。换句话说：因取标量场的梯度而对右手边的任何贡献都对速度场没有影响）。) 

另一方面，我们在这里将使用考虑总压力的斯托克斯方程的形式来代替。[1.x.61] 

这样做有几个好处。

- 这样，我们就可以在我们的程序中绘制压力图，它实际上显示的是总压力，包括温差的影响以及上层岩石的静压力。由于压力没有进一步出现在任何其他方程中，因此使用一个还是另一个，更多的是口味问题，而不是正确性问题。流动场是完全相同的，但我们得到的压力现在可以与地球物理书籍中给出的数值进行比较，例如，在地幔底部的压力。

- 如果我们想使模型更加真实，我们就必须考虑到许多材料参数（如粘度、密度等）不仅取决于温度，而且还取决于[1.x.62]压力。

- 上面的模型假设了一个线性依赖[2.x.17]，并假定[2.x.18]很小。在实践中，情况可能并非如此。事实上，现实的模型肯定不是线性的，而且[2.x.19]至少在部分温度范围内也可能不小，因为密度的行为不仅大大取决于热膨胀，而且取决于相变。

- 这样做的最后一个原因在结果部分讨论，涉及到对我们在这里使用的模型的可能扩展。这与我们在这里使用的温度方程（见下文）不包括包含压力的条款这一事实有关。然而，它应该包括：岩石，像气体一样，在你压缩它的时候会升温。因此，上升的物质以绝热方式冷却，而下沉的冷物质以绝热方式升温。我们在下面进一步讨论这个问题。

 2.x.20] 然而，这个过程有一个缺点。在地球上，动压比总压要小几个数量级。如果我们使用上述方程并求解所有的变量，例如4位数的精度，那么我们可能会得到正确的速度和总压，但如果我们通过从总压中减去静态部分来计算动压，我们将完全没有精度 [2.x.21] 。例如，如果动压比静压小六个数量级，那么我们需要解出整体压力，至少要达到七位数的精度，才能得到任何接近准确的结果。也就是说，在实践中，这并不是一个限制性因素。




[1.x.63][1.x.64] 。


记住，我们要解决以下方程组。[1.x.65] 

用适当的边界条件和初始条件来增强。正如在[2.x.22]中所讨论的，我们将通过在每个时间步长中首先求解斯托克斯问题，然后将温度方程向前移动一个时间间隔来解决这组方程。

本节所考虑的问题是斯托克斯问题：如果我们像往常一样对其进行离散，我们会得到一个线性系统[1.x.66] 

在这个程序中，我们将用FGMRES求解器来解决这个问题。这个求解器一直迭代到这些线性方程的残差低于某个公差，即直到[1.x.67] 这从物理单位的角度来看没有任何意义：这里涉及的量有物理单位，所以残差的第一部分有单位[2.x.23 ]（通过考虑术语[2.x.24]和考虑压力的单位[2.x.25]以及积分得到的系数[2.x.26]最容易确定），而残差的第二部分的单位是[2.x.27]。取这个残差向量的常数将得到一个单位为 [2.x.28] 的量。很明显，这没有意义，而且我们不应该惊讶，这样做最终会伤害到我们。

那么，为什么这在这里是个问题，而在[2.x.29]中不是？那里的原因是一切都很平衡：速度是一的数量级，压力也是如此，粘度是一，域的直径是[2.x.30] 。结果是，虽然不符合逻辑，但没有发生什么坏事。另一方面，正如我们将在下面解释的那样，这里的事情不会是那么简单的缩放。 [2.x.31]将在[2.x.32]左右，速度在[2.x.33]左右，压力在[2.x.34]左右，而域的直径是[2.x.35]。换句话说，第一个方程的数量级将是 [2.x.36] ，而第二个方程将是 [2.x.37] 左右。那么，这将导致这样的结果：如果求解器想让残差变小，它几乎会完全关注第一组方程，因为它们大得多，而忽略了描述质量守恒的发散方程。这正是发生的情况：除非我们将公差设置为极小的值，否则所得到的流场肯定不是无发散的。作为一个辅助问题，事实证明，很难找到一个始终有效的公差；在实践中，人们往往最终得到一个公差，在大多数时间步长中需要30或40次迭代，而在其他一些时间步长中需要10000次迭代。

那么，在这样的情况下，数字分析师该怎么做呢？答案是从根本上入手，首先要确保一切在数学上是一致的。在我们的案例中，这意味着如果我们想联合解决斯托克斯方程组，我们必须对它们进行缩放，使它们都有相同的物理尺寸。在我们的例子中，这意味着将第二个方程乘以具有单位[2.x.38]的东西；一种选择是乘以[2.x.39]，其中[2.x.40]是我们领域中的典型长度尺度（实验表明最好选择羽流的直径&mdash；大约10公里&mdash；而不是领域的直径）。使用[2.x.41]和[2.x.42]的这些%数，这个系数约为[2.x.43]。因此，我们现在对斯托克斯系统得到这个。[1.x.68] 

这方面的问题是，结果不再是对称的（我们在左下方有[2.x.44]，但在右上方没有其转置算子）。然而，这可以通过引入一个比例压力[2.x.45]来解决，我们得到比例方程[1.x.69] 

这现在是对称的。很明显，我们可以很容易地从按比例计算的压力[2.x.47]中恢复原来的压力[2.x.46]，我们是通过这个程序计算出来的结果。

在下面的程序中，我们将引入一个对应于[2.x.49]的因子[2.x.48]，我们将在系统矩阵和预处理程序的装配中使用这个因子。因为这很烦人而且容易出错，我们将在线性系统的解之后立即恢复未标定的压力，也就是说，解矢量的压力分量将立即被取消标定以检索物理压力。由于求解器使用的是我们可以通过推断以前的解来使用一个好的初始猜测，所以我们也要立即对压力进行缩放[1.x.70]求解。




[1.x.71][1.x.72] 。


在这个教程程序中，我们应用了 [2.x.50] 中使用的预处理程序的一个变体。该预处理程序是为了对系统矩阵[2.x.51]进行块状操作，从而使乘积矩阵[1.x.73] 

是一种基于Krylov的迭代求解器（如GMRES）可以在几次迭代中解决的形式。然后，我们用基于矢量拉普拉斯矩阵的AMG预处理器[2.x.53]的作用取代了[2.x.52]的精确逆，用压力空间上的质量矩阵[2.x.55]来逼近舒尔补码[2.x.54]，并编写了一个<tt>InverseMatrix</tt>类来实现[2.x.56]对矢量的作用。在InverseMatrix类中，我们使用了带有不完全Cholesky（IC）预处理的CG求解器来执行内部求解。

人们可以观察到，我们仅仅使用了预处理程序的作用来逼近速度逆[2.x.57]（外部GMRES迭代处理了逆的近似特性），而我们对[2.x.58]使用了或多或少的[1.x.74]逆，由完全收敛的CG解实现。这似乎是不平衡的，但这种疯狂是有系统的：几乎所有的努力都用在了左上角的区块上，我们将AMG预处理程序应用于此，而即使是压力质量矩阵的精确反演也基本上不需要花费什么。因此，如果它能帮助我们在一定程度上减少总的迭代次数，那么这种努力是值得的。

也就是说，尽管该求解器在[2.x.59]中运行良好，但我们这里的问题更复杂一些（单元是变形的，压力有数量级的变化，而且我们想为更复杂的物理学提前做好计划），因此我们将稍微改变一些东西。

- 对于更复杂的问题，事实证明，仅仅使用单一的AMG V型循环作为预处理器并不总是足够的。外围求解器在大多数时候都能在合理的迭代次数内收敛（比如，少于50次），但偶尔会有一些时间步骤，它突然需要700次左右。到底发生了什么，很难确定，但这个问题可以通过对左上角的块使用更精确的求解器来避免。因此，我们要使用CG迭代来反转预处理矩阵的左上角块，并使用AMG作为CG求解器的预处理。

- 这样做的缺点是，当然，斯托克斯预处理程序变得更加昂贵（比我们只使用单个V型循环时大约贵10倍）。我们的策略是这样的：让我们只用V型循环作为预处理程序做多达30次的GMRES迭代，如果这没有产生收敛，那么在第一轮迭代后得到的斯托克斯解的最佳近似值，并将其作为我们使用具有相当宽松容忍度的完整内部求解器作为预处理程序进行迭代的起始猜测。在我们所有的实验中，这只导致了少数额外迭代的收敛。

- 我们需要注意的一点是，当使用具有宽松容限的CG作为前置条件时，[2.x.60]不再是[2.x.61]的线性函数（当然，如果我们的求解器具有非常严格的容限，或者我们只应用单一的V-循环，则是如此）。这是一个问题，因为现在我们的预处理程序不再是一个线性算子；换句话说，每次GMRES使用它时，预处理程序看起来都不一样。标准的GMRES求解器不能处理这个问题，导致收敛缓慢甚至崩溃，但F-GMRES变体正是为了处理这种情况而设计的，我们因此使用了它。

- 另一方面，一旦我们确定使用F-GMRES，我们就可以放宽用于反转[2.x.62]的预处理器的容忍度。在[2.x.63]中，我们对[2.x.64]运行了一个预处理的CG方法，直到残差减少7个数量级。在这里，我们又可以更宽松一些，因为我们知道外部预处理程序并没有受到影响。

- 在[2.x.65]中，我们使用了一个左预处理器，首先反转预处理器矩阵的左上块，然后应用左下块（发散），再反转右下块。换句话说，预处理器的应用起到了左下块三角矩阵的作用。另一个选择是使用右预处理器，这里将是右上块三角化，即我们首先反转右下舒尔补码，应用右上（梯度）算子，然后反转椭圆的左上块。在某种程度上，选择哪一个是一个品味的问题。也就是说，在GMRES类型的求解器中，右预处理有一个显著的优势：我们决定是否应该停止迭代的残差是真正的残差，而不是预处理方程的规范。因此，将其与我们通常使用的停止标准，即右手边向量的规范进行比较要简单得多。在编写这段代码时，我们发现上面讨论的缩放问题也使我们难以确定适合于左预处理线性系统的停止准则，因此这个程序使用了右预处理。

- 在[2.x.66]中，我们对舒尔补码预处理中的压力质量矩阵和温度系统的解使用了IC（不完全Cholesky）预处理。在这里，我们原则上也可以这样做，但我们确实选择了一个更简单的预处理程序，即两个系统的雅可比预处理程序。这是因为在这里我们的目标是大规模的并行计算，IC/ILU的分解必须在每个处理器上对本地拥有的自由度逐块执行。这意味着，无论如何，预处理程序会变得更像一个雅可比预处理程序，所以我们宁愿直接从这个变体开始。请注意，我们只对有质量矩阵的CG求解器使用Jacobi预处理，无论如何它们都能提供最佳的（[1.x.75]独立的）收敛性，尽管它们通常需要两倍于IC预处理的迭代次数。

最后，让我们指出，在[2.x.67]中，我们通过近似[2.x.69]来计算舒尔补码[2.x.68]。然而现在，我们重新缩放了[2.x.70]和[2.x.71]的运算符。所以[2.x.72]现在应该近似于[2.x.73] 。我们用这个的右手边的离散形式作为我们对[2.x.74]到[2.x.75]的近似。


[1.x.76][1.x.77] 。


与[2.x.76]类似，我们将使用基于方程残余的人工粘度进行稳定。 作为与[2.x.77]的区别，我们将提供两个略有不同的稳定参数的定义。对于[2.x.78]，我们使用与[2.x.79]中相同的定义：[1.x.78] 

我们从方程的残差[2.x.80]中计算粘度，在残差较大的区域（陡峭的梯度周围），由与网格大小[2.x.81]成比例的扩散限制。这个定义在给定的情况下被证明是有效的， [2.x.82] 在 [2.x.83] 中，但它通常不如 [2.x.84] 的扩散有效。对于这种情况，我们选择了一个稍微可读的粘度定义，[1.x.79] 。

其中第一项又给出了最大耗散量（类似于一阶上风方案）， [1.x.80] 

而熵粘度的定义为[1.x.81] 。



这个公式在文章[1.x.82]中有所描述。与[2.x.85]的情况相比，残差是由温度熵计算出来的，[2.x.86]有[2.x.87]个平均温度（我们在计算中选择最高和最低温度之间的平均值），这就得到以下公式[1.x.83] 

[2.x.88]的公式中的分母被计算为熵与空间平均熵的全局偏差 [2.x.89] 。与[2.x.90]一样，我们根据前两个时间层次的温度和速度来评估人工黏度，以避免其定义中的非线性。

上述粘度的定义很简单，但取决于两个参数，即 [2.x.91] 和 [2.x.92] 。 对于目前的程序，我们想在[2.x.93]的情况下对这两个参数更系统地去解决这个问题，使用我们在离散化中选择其他两个参数[2.x.94]和[2.x.95]的相同思路，在[2.x.96]的结果部分。特别是，请记住，我们希望使人工粘度尽可能小，同时保持必要的大。在下文中，让我们描述一个人可能遵循的一般策略。这里显示的计算是用程序的早期版本完成的，因此你在运行程序时得到的实际数值可能不再与这里显示的数值一致；这就是说，一般的方法仍然有效，并被用来寻找程序中实际使用的参数值。

要想知道发生了什么，请注意，下面我们将对973和4273开尔文之间的温度施加边界条件，初始条件也选择在这个范围内；出于这些考虑，我们运行程序时没有%的内部热源或散热器，因此温度应该总是在这个范围内，除非有任何%的内部振荡。如果最低温度下降到973开尔文以下，那么我们需要通过增加[2.x.97]或减少[2.x.98]来增加稳定度。

正如我们在[2.x.99]中所做的那样，我们首先通过使用 "传统 "公式[1.x.84]确定[2.x.100]的最佳值。

我们知道，只要[2.x.101]足够大，它就是稳定的。在2d中做几百个时间步数（在比程序中显示的网格更粗的网格上，并且用不同的粘度影响传输速度，从而影响时间步数大小），将产生以下图形。

 [2.x.102]  

可以看出，[2.x.103]的数值太小，而[2.x.104]似乎是有效的，至少在这里显示的时间范围内。作为旁观者，这里至少有两个问题是人们可能想知道的。首先，当解决方案变得不稳定时，会发生什么？看一下图形输出，我们可以看到，在这些实验所选择的不合理的粗大网格下，大约在[2.x.105]秒的时间里，一直向冷的外部边界上升，然后向侧面扩散的热物质羽流开始相互靠近，将中间的冷物质挤压出来。这就形成了一个细胞层，流体从两个相对的侧面流入，并向第三个侧面流出，显然，这种情况会在没有充分稳定的情况下产生这些不稳定性。第二：在[2.x.106]中，我们使用了[2.x.107]；为什么这在这里不起作用？这个问题的答案并不完全清楚--稳定参数肯定取决于单元格的形状等因素，在[2.x.108]中我们使用的是正方形，而在目前的程序中则是梯形。不管具体原因是什么，我们至少有一个[2.x.109]的值，即2d的0.052，对当前程序有效。在3d中也可以做类似的实验，我们发现[2.x.110]是一个很好的选择&mdash; 整齐地引出公式[2.x.111] 。

有了这个值，我们可以回到粘度的原始公式[2.x.112]，并对常数[2.x.113]进行调整，使其尽可能大，以便使[2.x.114]尽可能小。这样我们就得到了这样的画面。

 [2.x.115]  

因此，[2.x.116]似乎是这里的正确值。虽然这个图形是针对指数[2.x.117]得到的，但在程序中我们用[2.x.118]代替，在这种情况下，我们必须重新调整参数（并观察到[2.x.119]出现在分子中而不是分母中）。事实证明，[2.x.120]与[2.x.121]一起工作。


[1.x.85][1.x.86] 。


Stokes的标准Taylor-Hood离散化，使用[2.x.122]元素，是全局保守的，即[2.x.123] 。这很容易看出：发散方程的弱形式为 [2.x.124] 。因为压力空间确实包含函数 [2.x.125] ，所以我们得到 

[1.x.87] 

根据发散定理。这个性质很重要：如果我们想用速度场[2.x.126]沿其他量（如当前方程中的温度，但也可能是化学物质的浓度或完全人为的示踪量）进行传输，那么守恒性质保证了所输送的量保持不变。

也就是说，在有些应用中，这个[1.x.88]属性是不够的。相反，我们希望它在每个单元上都成立[1.x.89]。这可以通过使用空间[2.x.127]进行离散化来实现，其中我们用相同程度的完整多项式的[1.x.91]空间取代压力的[1.x.90]度数[2.x.128]的张量积多项式空间。(注意，2d中的张量积多项式包含函数[2.x.129]，而完全多项式只包含函数[2.x.130]) 。这个空间对于斯托克斯方程来说原来是稳定的。

由于该空间是不连续的，我们现在可以特别选择测试函数 [2.x.131] ，即单元格的特征函数 [2.x.132] 。然后我们以类似于上面的方式得到 

[1.x.92] 

显示了细胞[2.x.133]的守恒属性。这显然对每个单元都是成立的。

使用这种离散化有很好的理由。如上所述，这个元素保证了每个单元上的平流量的守恒。第二个优点是，我们用压力质量矩阵代替舒尔补码作为预处理，成为块状对角线，因此非常容易反转。然而，也有缺点。首先，现在有更多的压力变量，增加了问题的总体规模，尽管这在实践中似乎没有造成太大的影响。但更重要的是，现在每个单元上的发散是零，而以前不是，这并不能保证发散是点状的小。事实上，我们可以很容易地验证，与标准的Taylor-Hood离散化相比，这个发散的[2.x.134]准则是[1.x.93]。然而，两者都以相同的速度收敛到零，因为很容易看到[2.x.135] 。因此，先验地看不出误差确实较小只是因为我们现在有更多的自由度。

鉴于这些考虑，我们仍然不清楚应该选择哪种离散化。因此，我们把这个问题留给用户，并在输入文件中规定使用哪个参数。


[1.x.94][1.x.95] 。


在程序中，我们将使用一个球壳作为域。这意味着域的内部和外部边界不再是 "直的"（我们通常指它们是可以用FlatManifold类表示的双线性表面）。相反，它们是弯曲的，如果我们已经使用高阶有限元来计算速度，那么在程序中使用一个弯曲的近似值似乎是谨慎的。因此，我们将引入一个MappingQ类型的成员变量，表示这样的映射（[2.x.136]和[2.x.137]首次引入了这样的映射），我们将在与边界相邻的单元的所有计算中使用。由于这只影响到相对较小的一部分单元，额外的努力并不是很大，我们将对这些单元使用夸父映射。


[1.x.96][1.x.97] 。


在三维空间中运行具有显著雷利数的对流代码需要大量的计算；在整个地球模拟的情况下，需要一或几亿个未知数的数量。这显然不能用一台机器来完成（至少在2010年我们开始编写这段代码时不能）。因此，我们需要将其并行化。科学代码在计算机集群的多台机器上的并行化几乎总是使用消息传递接口（MPI）来完成。这个程序也不例外，它遵循了[2.x.138]和[2.x.139]程序的一般精神，尽管在实践中它更多地借鉴了[2.x.140]，其中我们首先介绍了当我们想[1.x.98]分布所有计算时使用的类和策略，以及[2.x.141 ]，其中展示了如何对[2.x.142]的 "向量值问题 "做到这一点：包括，例如，将网格分割成若干部分，使每个处理器只存储自己的份额和一些幽灵单元，以及使用没有处理器可能有足够的内存来保存本地的组合解向量的条目的策略。我们的目标是在数百甚至数千个处理器上运行这段代码，并具有合理的可扩展性。

 [2.x.143]尽管它有一个更大的数字，[2.x.144]在逻辑上是在当前程序之前。对于 [2.x.145] 也是如此。在你试图理解我们在这里所做的事情之前，你可能会想看看这些程序。

MPI是一个相当笨拙的编程接口。它是一个半面向对象的函数集，虽然人们用它在网络上发送数据，但需要明确地描述数据类型，因为MPI函数坚持把数据的地址作为[2.x.146]对象来获取，而不是通过重载或模板来自动推断数据类型。我们已经在[2.x.147]和[2.x.148]中看到了如何通过将所有必要的通信放到 deal.II 库中，或者在这些程序中放到 PETSc 中，来避免几乎所有的 MPI。我们将在这里做一些类似的事情：就像在 [2.x.149] 和 [2.x.150] 中一样，deal.II 和底层的 p4est 库负责分配网格所需的所有通信，而我们将让 Trilinos 库（以及命名空间 TrilinosWrappers 中的包装器）来处理线性代数组件的并行化。我们已经在[2.x.151]中使用了Trilinos，并将在这里再次使用，不同的是我们将使用其%并行能力。

Trilinos由大量的包组成，实现了基本的%并行线性代数操作（Epetra包），不同的求解器和预处理包，以及对deal.II不太重要的东西（例如。deal.II的Trilinos接口封装了Trilinos提供的许多与PDE求解器相关的东西，并提供了封装类（在命名空间TrilinosWrappers中），使Trilinos的矩阵、向量、求解器和预处理器类看起来与deal.II自己对这些功能的实现非常相同。然而，与deal.II的类相比，如果我们给它们提供必要的信息，它们可以在%并行中使用。因此，有两个Trilinos类我们必须直接处理（而不是通过包装器），这两个类都是Trilinos的Epetra基本线性代数和工具类库的一部分。 [2.x.152] [2.x.153] Epetra_Comm类是MPI "通信器 "的抽象，也就是说，它描述了多少台机器和哪些机器可以相互通信。  每个分布式对象，比如稀疏矩阵或矢量，我们可能想把它们的部分存储在不同的机器上，需要有一个通信器对象来知道有多少部分，在哪里可以找到它们，以及如何访问它们。

  在这个程序中，我们只真正使用了一个通信器对象--基于MPI变量[2.x.154]--包含了一起工作的[1.x.99]进程。在[2.x.155]机器上启动一个进程，但只在其中的一个子集上存储向量，产生一个只包括这个子集的机器的通信器对象是完全合法的；不过，在这里确实没有令人信服的理由这样做。

 [2.x.156] IndexSet类用于描述向量的哪些元素或矩阵的哪些行应该驻留在属于通信器的当前机器上。要创建这样一个对象，你需要知道（i）元素或行的总数，（ii）你想在本地存储的元素的索引。我们将在下面的[2.x.157]函数中设置这些[2.x.158]，然后把它交给我们创建的每个%parallel对象。

  与PETSc不同，Trilinos没有假设矢量的元素需要被分割成连续的小块。至少在原则上，我们可以在一个处理器上存储所有偶数索引的元素，在另一个处理器上存储所有奇数索引的元素。当然，这不是很有效率，但这是可能的。此外，这些分区的元素不一定是相互排斥的。这一点很重要，因为在对解决方案进行后处理时，我们需要访问所有本地相关的或至少是本地活跃的自由度（定义见[2.x.159]上的模块，以及[2.x.160]中的讨论）。那么Trilinos矢量认为哪些元素是本地拥有的，对我们来说并不重要。我们所关心的是它在本地存储了我们需要的那些元素。 [2.x.161]  

还有一些与将网格分布到多个处理器上有关的概念；在尝试理解这个程序之前，你可能想看看[2.x.162]模块和[2.x.163]或[2.x.164]。 程序的其余部分几乎完全不知道我们并不完全在本地存储所有对象的事实。有几个地方我们必须将所有单元的循环限制在本地拥有的单元上，或者我们需要区分只存储本地拥有的元素的向量和存储本地相关的所有元素的向量（见[2.x.165]"这个词汇表条目"），但总的来说，使程序在%parallel中运行所需的大量繁重工作都很好地隐藏在这个程序赖以建立的库中。在任何情况下，我们都会在程序代码中对这些位置进行评论。


[1.x.100][1.x.101] 。


使程序并行化的第二个策略是利用这样一个事实，即今天大多数计算机都有一个以上的处理器，它们都可以访问相同的内存。换句话说，在这个模型中，我们不需要明确地说哪块数据在哪里，我们需要的所有数据都可以直接访问，我们要做的就是在可用的处理器之间分割[1.x.102]这些数据。然后，我们将把它与上述的MPI并行化结合起来，也就是说，我们将让一台机器上的所有处理器一起工作，例如，为这台机器实际 "拥有 "的单元汇集对全局矩阵的局部贡献，而不是为那些被其他机器拥有的单元。我们将把这种策略用于本程序中经常进行的四种操作：组装斯托克斯和温度矩阵，组装形成斯托克斯预处理的矩阵，以及组装温度系统的右手边。

所有这些操作基本如下：我们需要在所有单元中进行循环，其中[2.x.166]等于我们机器在用于所有通信的通信器对象中的索引（即[2.x.167] ，如上所述）。我们实际要使用的测试，简明扼要地描述了我们为什么要测试这个条件，是[2.x.168] 。在每一个这样的单元上，我们需要集合对全局矩阵或向量的局部贡献，然后我们必须将每个单元的贡献复制到全局矩阵或向量中。请注意，第一部分（循环）定义了一个必须发生的迭代器的范围。第二部分，本地贡献的组装是在这个步骤序列中花费大部分CPU时间的事情，也是一个可以在%并行中完成的典型例子：每个单元的贡献完全独立于所有其他单元的贡献。第三部分，复制到全局矩阵中，不能在%parallel中进行，因为我们在修改一个对象，所以几个线程不能同时读取一个现有的矩阵元素，加上他们的贡献，然后把总和写回内存中，而不会产生[1.x.103]的危险。

deal.II有一个类，正是为这个工作流程而生的。WorkStream，首次在 [2.x.169] 和 [2.x.170] 中讨论。它的使用在[2.x.171]模块中也有广泛的记录（在[2.x.172]"WorkStream类 "一节），我们不会在这里重复那里阐述的原理和详细说明，尽管你会想通读这个模块以理解从头开始的空间和每单元数据之间的区别。我们只需提到我们需要以下东西。

- 一个迭代器范围，用于我们要处理的那些单元格。这是由FilteredIterator类提供的，它的作用与deal.II中的其他单元格迭代器一样，只是它跳过了所有不满足特定谓词（即一个评估为真或假的标准）的单元格。在我们的例子中，该谓词是一个单元格是否为本地所有。

- 一个为上述每项任务在每个单元上做工作的函数，即集合对斯托克斯矩阵和预调节器、温度矩阵和温度右手边的局部贡献的函数。这些是下面代码中的[2.x.173]、[2.x.174]、[2.x.175]和[2.x.176]函数。这四个函数都可以有几个实例同时并行运行。

- 将前一个函数的结果复制到全局对象中的%函数，并按顺序运行以避免竞赛条件。这些是[2.x.177]、[2.x.178]、[2.x.179]和[2.x.180]函数。

我们将在实际代码中多评论几点，但总的来说，它们的结构在 [2.x.181] 的讨论中应该是很清楚的。

WorkStream的底层技术识别需要工作的 "任务"（例如，在一个单元上组装本地贡献），并将这些任务自动安排到可用的处理器上。WorkStream通过将迭代器范围分割成合适的块，自动创建这些任务。

 [2.x.182] 在每个MPI进程中使用多个线程，只有当你在集群的每个节点上运行的MPI进程少于这台机器上的处理器内核时才有意义。否则，MPI已经让你的处理器很忙了，你不会从使用线程中获得任何额外的速度。例如，如果你的集群节点有8个内核，就像在写这篇文章的时候经常有的那样，如果你的批处理调度程序在每个节点上放8个MPI进程，那么使用线程并不能使程序更快。因此，你可能想在运行之前，要么配置你的deal.II不使用线程，要么将[2.x.183]中的线程数设置为1（第三个参数），或者 "export DEAL_II_NUM_THREADS=1"。也就是说，在写这篇文章的时候，我们只用WorkStream类来组装（部分）线性系统，而程序的75%或更多的运行时间是在没有并行化的线性求解器中度过的&mdash;换句话说，我们最好的希望是将剩下的25%并行化。


[1.x.104][1.x.105] 。


这个程序的设置稍微让人想起我们最初想要解决的问题（见[2.x.184]的介绍）：地幔的对流。因此，我们选择了以下数据，所有这些数据在程序中出现的单位是米和秒（国际单位制），即使我们在这里以其他单位列出它们。然而，我们注意到，这些选择基本上仍然只是示范性的，而不是要形成对地幔对流的完全现实的描述：为此，必须实现更多、更困难的物理学，而且目前这个程序中也缺少其他几个方面。我们将在结果部分再次讨论这个问题，但现在要说明的是，在写这篇文章时，提供一个现实的描述是正在开发的[1.x.106]代码的一个目标。

作为提醒，让我们再次说明我们要解决的方程是这些。[1.x.107] 

由边界条件和初始条件增强。然后我们必须选择以下数量的数据。 [2.x.185] [2.x.186] 领域是一个环形（2D）或一个球壳（3D），其内外半径与地球的半径一致：地球的总半径为6371km，地幔从大约35km的深度开始（就在由[1.x.109]和[1.x.110]组成的固体地球[1.x.108]之下）到2890km的深度（[1.x.111]开始）。因此，半径为[2.x.187] 。这个领域是使用[2.x.188]函数方便地生成的。

   [2.x.189] 在地壳和地幔的界面上，温度在500至900摄氏度之间，而在其底部则是4000摄氏度左右（例如，见[1.x.112]）。因此，在开尔文中，我们选择[2.x.190] ，[2.x.191]作为内部和外部边缘的边界条件。

  除此以外，我们还必须为温度场指定一些初始条件。地球的真实温度场是相当复杂的，因为对流已经持续了40多亿年 -- 事实上，我们想用这样的程序来探索这种温度分布的特性。因此，我们在这里并没有什么有用的东西可以提供，但是我们可以希望，如果我们从一些东西开始，让事情运行一段时间，确切的初始条件就不再那么重要了&mdash；事实上，通过查看[1.x.113]中显示的图片就可以看出。我们在这里使用的初始温度场在半径方面由[1.x.114]给出 

  其中[1.x.115] 

  这个复杂的函数本质上是对内外温度之间的线性轮廓的扰动。在2D中，函数[2.x.192]看起来像这样（我从[1.x.116]中得到的图片）。

   [2.x.193]  

  这个轮廓的重点是，如果我们在[2.x.196]的定义中使用[2.x.194]而不是[2.x.195]，那么它将只是一个线性内插。 [2.x.197]在内部和外部边界具有与[2.x.198]相同的函数值（分别为0和1），但它根据角度和3D中的[2.x.199]值将温度曲线拉长一些，产生一个与角度有关的线性内插场的扰动。我们将在结果部分看到，这是一个完全不实际的温度场（尽管它将产生有趣的图像），因为温度的平衡状态将是一个几乎恒定的温度，在内部和外部边界有边界层。

   [2.x.200] 温度方程的右侧包含内部加热%的速率 [2.x.201] 。地球确实通过几种机制自然升温：放射性衰变、化学分离（较重的元素沉到底部，较轻的元素升到顶部；逆流耗散的能量相当于这一分离过程中的势能损失）；随着地球内部固体核心的增长，液态金属的结晶释放热量；以及流体运动时粘性摩擦的热量耗散。

  化学分离很难建模，因为它需要将地幔材料建模为多个相；它也是一个相对较小的影响。结晶热就更难了，因为它只限于温度和压力允许相变的区域，也就是一个不连续的过程。鉴于对这两个现象进行建模的困难，我们将忽略它们。

  其他两个很容易处理，考虑到我们缩放温度方程的方式，导致方程[1.x.117]，其中[2.x.202]是[2.x.203]中的辐射性加热，枚举器中的第二个项是粘性摩擦加热。 [2.x.204] 是密度，[2.x.205] 是比热。文献中提供了以下近似值。 [2.x.206] .   其他参数将在本节的其他地方讨论。

  我们忽略了一个内部热源，即这里的绝热加热，这将导致一个令人惊讶的温度场。这一点将在下面的结果部分详细评论。

   [2.x.207] 对于速度，我们在内半径处选择[2.x.208]作为边界条件（即流体粘在地心上），在外半径处选择[2.x.209]（即流体沿地壳底部切向流动）。这两种情况在物理上都不过分正确：当然，在这两个边界上，流体可以切向流动，但它们会通过与界面另一侧的介质（分别是金属核心和地壳）摩擦而产生剪切应力。这样的情况可以用切向速度的罗宾式边界条件来模拟；在这两种情况下，法向（垂直）速度将为零，尽管即使这样也不完全正确，因为大陆板块也有垂直运动（例如，见[1.x.118]的现象）。但是，对于切向速度来说，另一侧的介质也在运动，这已经使事情变得更糟，因此，在最简单的情况下，剪应力将与[1.x.119]成正比，导致边界条件的形式为[1.x.120] 

  与比例常数[2.x.210]。然而，我们没有走这条路，而是选择了零（棒）和切向流的边界条件。

  作为一个有趣的附带说明，我们也可以在内部和外部边界上选择切向流动条件。然而，这有一个明显的缺点：它使速度不是唯一定义的。原因是所有对应于实体绕域中心旋转的速度场[2.x.211]都满足[2.x.212]，和[2.x.213]。因此，如果[2.x.214]满足方程和边界条件，那么[2.x.215] 也满足。这当然不是一个我们希望避免的好情况。传统的方法是在边界上选择一个任意的点，通过选择速度在那里的所有分量为零，把这个点称为你的固定点。(在三维空间中，必须选择两个点。)由于这个程序开始时并不打算太现实，我们通过简单地固定整个内部边界的速度来避免这种复杂情况。

   [2.x.216]在一阶上，重力矢量总是指向下方。对于像地球这样大的物体，问题只是："向上 "在哪里。当然，天真的答案是 "径向向内，朝向地球中心"。所以在地球表面，我们有[1.x.121]，其中[2.x.217]刚好是地球表面的平均重力加速度。但是在地球内部，问题变得有点复杂：例如，在地球的（轨道）中心，你有物质在各个方向上同样用力拉扯，所以[2.x.218] 。在这之间，净力的描述如下：让我们通过[1.x.123]定义[1.x.122]，然后[2.x.219] 。如果我们假设整个地球的密度[2.x.220]是恒定的，我们可以产生一个重力矢量的分析表达式（不要试图以某种方式整合上述方程--它导致了椭圆积分；一个更简单的方法是注意到[2.x.221]，并利用径向对称性在所有的[2.x.222]中解决这个偏微分方程）。  [1.x.124]因子[2.x.223]是指向径向内的单位矢量。当然，在这个问题中，我们只对与地球内部有关的分支感兴趣，即[2.x.224] 。因此，我们将只考虑表达式[1.x.125]，我们可以推断出最后一个表达式，因为我们知道地球在表面的重力（其中[2.x.225] ）。

  我们可以通过整合[2.x.226]的微分方程，在密度分布是径向对称的情况下，即[2.x.227]，推导出一个更一般的表达式。在这种情况下，我们将得到[1.x.126] 。


  然而，这有两个问题。(i) 地球不是同质的，即密度[2.x.228]取决于[2.x.229]；事实上，它甚至不是一个只取决于半径的函数[2.x.230]。因此，在现实中，重力并不总是随着我们的深入而减少：因为地心比地幔的密度大得多，重力实际上在地心地幔边界的[2.x.231]左右达到峰值（见[1.x.127]）。(ii) 密度，以及由此产生的重力矢量，在时间上甚至不是恒定的：毕竟，我们要解决的问题是与时间相关的热的、密度较小的物质的上涌和冷的密度较大的物质的下涌。这就导致了重力矢量随空间和时间的变化而变化，并不总是直指下方。

  为了不使情况变得更加复杂，我们可以使用这样的近似值：在地幔的内部边界，重力是[2.x.232]，在外部边界是[2.x.233]，在每一种情况下都是径向向内的，在这两者之间，重力随着离地球中心的径向距离而线性变化。也就是说，实际上稍微现实一点，假设（就像我们下面做的那样）地幔具有恒定的密度也不是那么难。在这种情况下，上面的方程可以被整合，我们得到一个[2.x.234]的表达式，我们可以拟合常数以匹配地幔顶部和底部的重力，得到[1.x.128] 

   [2.x.235] 地幔的密度在空间上有变化，但变化幅度不大。 [2.x.236]是参考温度[2.x.237]开尔文时的密度的一个相对较好的平均值。

   [2.x.238]热膨胀系数[2.x.239]也随深度变化（通过其对温度和压力的依赖）。在接近地表的地方，它似乎是[2.x.240]，而在地心地幔边界，它可能更接近[2.x.241]。作为一个合理的值，让我们选择[2.x.242]。那么密度与温度的关系是[2.x.243] 。

   [2.x.244] 我们需要指定的第二个至最后一个参数是粘度 [2.x.245] 。这是一个棘手的问题，因为在地幔典型的温度和压力下，岩石的流动非常缓慢，以至于在实验室里无法准确地确定粘度。那么我们如何知道地幔的粘度呢？最常用的方法是考虑在冰期和冰期之后，冰盾形成和消失的时间尺度比地幔流动的时间尺度短。因此，大陆在冰盾的附加重量下慢慢沉入地幔，而在冰盾再次消失后，它们又慢慢升起（这被称为[1.x.129][1.x.130]）。通过测量这种反弹的速度，我们可以推断出流向反弹的大陆板块下腾出的区域的物质的粘度。

  使用这种技术，人们发现[2.x.246]附近的数值是最有可能的，尽管这个数值的误差范围至少是一个数量级的。

  虽然我们将使用这个值，但我们不得不再次提醒，有许多物理原因可以假设这不是正确的值。首先，它确实应该取决于温度：较热的材料很可能比较冷的材料的粘性要小。然而，在现实中，情况甚至更为复杂。地幔中的大多数岩石随着温度和压力的变化而发生相变：根据温度和压力的不同，不同的晶体构型在热力学上比其他的更受青睐，即使地幔的化学成分是均匀的。例如，常见的地幔物质MgSiO<sub>3</sub>在整个地幔的大部分地区以其[1.x.131]的形式存在，但在地幔下部，同样的物质只以[1.x.132]的形式稳定。显然，为了计算现实的粘度，我们不仅需要知道地幔的确切化学成分和所有物质的粘度，而且还必须计算所有物质在每个正交点的热力学上最稳定的配置。在编写这个程序时，这不是一个可行的建议。

   [2.x.247] 我们的最后一个材料参数是热扩散率[2.x.248] ，其定义为[2.x.249] 其中[2.x.250] 是热导率，[2.x.251] 是密度，[2.x.252] 是比热。对于这一点，文献表明，它从上地幔的[2.x.253]左右增加到下地幔的[2.x.254]左右，尽管确切的数值其实并不那么重要：通过对流的热传输比通过热传导的热传输要重要几个数量级。可能有兴趣知道的是，地幔中最丰富的材料--过氧化物，在超过大约120GPa的压力下似乎变得透明（例如，见J. Badro等人，《科学》305，383-386（2004））；因此，在下地幔中，通过辐射传输的热传输可能比通过热传导更有效率。

  鉴于这些考虑，让我们选择[2.x.255]作为本方案的目的。 [2.x.256]  

所有这些方程数据都在程序中定义在[2.x.257]名称空间中。当运行时，该程序产生的长期最大速度约为每年10-40厘米（见下面的结果部分），大约是物理上正确的数量级。我们将设定结束时间为10亿年。

 [2.x.258] 上述常数和材料参数的选择在很大程度上遵循G. Schubert和D. L. Turcotte和P. Olson（剑桥，2001年）的综合书籍《地球和行星的地幔对流，第一部分》。它包含了关于如何使程序更加真实的广泛讨论。


[1.x.133][1.x.134] 。


与[2.x.259]相比，这个程序有一些值得注意的区别。

- [2.x.260]的命名空间要大得多，反映了我们现在有更多的物理学需要处理的事实。也就是说，这些额外的物理细节大部分是在这个命名空间的函数中自成一体的，并没有扩散到程序的其他部分。

- 更明显的是，我们把大量的参数放到了一个由ParameterHandler类处理的输入文件中（例如，见[2.x.261]，关于用这个类设置运行时参数文件的方法）。当人们想避免重新编译程序时，这往往是有意义的，只因为他们想玩弄一个参数（例如，想想确定上面讨论的稳定常数的最佳值的参数研究），特别是考虑到重新编译当前规模的程序需要花费非同寻常的时间。为了仅仅概述我们从固定值移入输入文件的参数种类，这里列出了一个典型的[2.x.262]文件。  [1.x.135] 



- 很明显，有大量的变化是与我们想在可能非常多的机器上运行我们的程序有关的。尽管人们可能会怀疑这需要我们完全重新构造我们的代码，但事实上并非如此（尽管从实现的角度来看，在deal.II中实现大部分功能的类看起来非常不同，但这并没有反映在它们的公共接口中）。相反，这些变化大多是微妙的，主类的整体结构几乎没有变化。也就是说，魔鬼在细节中：正确地进行%并行计算，没有死锁，确保正确的数据在正确的地方可用（例如，见关于全分布式向量与有鬼魂元素的向量的讨论），以及避免瓶颈是很困难的，关于这个话题的讨论将出现在本程序中的很多地方。


[1.x.136][1.x.137] 。


这是一个教程性的程序。这意味着至少它的大部分重点需要在于演示使用deal.II和相关库的方法，而不是通过过度关注物理细节来稀释这个教学课程。尽管上面有关于物理参数选择的长篇大论，但程序中专门讨论这个问题的部分实际上是很短的，而且是自成一体的。

也就是说，[2.x.263]和当前的[2.x.264]都不是偶然出现的，而是作为通往更全面的程序的路标，模拟地幔的对流。我们把这个代码称为[1.x.138]（简称[1.x.139]）；它的开发由[1.x.140]计划资助，由美国国家科学基金会支持。关于[1.x.141]的更多信息可在其[1.x.142]中找到。[1.x.143] [1.x.144]。


[1.x.145] [1.x.146]。




像往常一样，第一个任务是包括这些著名的deal.II库文件和一些C++头文件的功能。

[1.x.147] 



这是唯一一个新的包含文件：它引入了与[2.x.265]等价的[2.x.266]类，用于在网格细化时将解决方案从一个网格带到下一个网格，但在并行分布式三角计算的情况下。

[1.x.148] 



以下的类用于并行分布式计算，在 [2.x.267] 中都已经介绍过了。

[1.x.149] 



下一步就像以前所有的教程程序一样。我们把所有东西放到一个自己的命名空间中，然后把deal.II的类和函数导入其中。

[1.x.150] 




[1.x.151] [1.x.152]。




在下面这个命名空间中，我们定义了描述问题的各种方程数据。这对应于使问题至少有一点现实性的各个方面，在介绍中对测试案例的描述中已经详尽地讨论了这些方面。   


我们从几个具有恒定值的系数开始（数值后面的注释表示其物理单位）。

[1.x.153] 



下一组定义是用于编码作为温度函数的密度、重力矢量和温度的初始值的函数。同样，所有这些（以及它们计算的值）都在介绍中讨论过。

[1.x.154] 



正如介绍中提到的，我们需要重新调整压力的比例，以避免动量和质量守恒方程的相对条件不良。比例系数是[2.x.268]，其中[2.x.269]是一个典型的长度尺度。通过实验发现，一个好的长度尺度是烟羽的直径，大约是10公里。

[1.x.155] 



这个命名空间的最后一个数字是一个常数，表示每（平均，热带）年的秒数。我们只在生成屏幕输出时使用它：在内部，这个程序的所有计算都是以SI单位（公斤、米、秒）进行的，但是用秒来写地质学时间产生的数字无法与现实联系起来，所以我们用这里定义的因子转换为年。

[1.x.156] 




[1.x.157] [1.x.158]。




这个命名空间实现了预处理程序。正如介绍中所讨论的，这个预处理程序在一些关键部分与 [2.x.270] 中使用的不同。具体来说，它是一个右边的预处理程序，实现了矩阵的 

[1.x.159] 

其中，两个逆矩阵操作由线性求解器近似，或者，如果给这个类的构造器加上右标志，则由速度块的单个AMG V-循环来实现。[2.x.271]函数的三个代码块实现了与该预处理矩阵的三个块的乘法运算，如果你读过[2.x.272]或[2.x.273]中关于组成求解器的讨论，应该是不言自明的。

[1.x.160] 




[1.x.161] [1.x.162]。   


正如介绍中所述，我们将使用[2.x.274]模块中讨论的WorkStream机制，在一台机器的处理器之间进行并行操作。WorkStream类要求数据在两种数据结构中传递，一种是用于抓取数据，一种是将数据从装配函数传递到将本地贡献复制到全局对象的函数。   


下面的命名空间（以及两个子命名空间）包含了服务于这一目的的数据结构的集合，在介绍中讨论的四种操作中的每一种都有一对，我们将想把它们并行化。每个装配例程都会得到两组数据：一个是Scratch数组，收集所有用于计算单元格贡献的类和数组，另一个是CopyData数组，保存将被写入全局矩阵的本地矩阵和向量。而CopyData是一个容器，用来存放最终写入全局矩阵和向量的数据（因此是绝对必要的），Scratch数组的存在只是为了性能的原因&mdash；在每个单元上设置一个FEValues对象，要比只创建一次和更新一些导数数据要昂贵得多。   


 [2.x.275]有四个汇编程序。一个用于斯托克斯系统的预处理矩阵，一个用于斯托克斯矩阵和右手边，一个用于温度矩阵和温度方程的右手边。我们在这里使用[2.x.276]环境为这四个装配组件中的每一个组织scratch数组和CopyData对象（因为我们认为这些是我们传递的临时对象，而不是实现自己功能的类，尽管这是区分[2.x.277]es的一个比较主观的观点）。   


关于Scratch对象，每个结构都配备了一个构造器，该构造器使用[2.x.279]、正交、[2.x.280]（描述弯曲边界的插值）和[2.x.281]实例创建一个[2.x.278]对象。此外，我们手动实现了一个复制构造函数（因为FEValues类本身是不可复制的），并提供了一些额外的矢量字段，用于在计算局部贡献时保存中间数据。   


让我们从抓取数组开始，特别是用于组装斯托克斯预处理程序的数组。

[1.x.163] 



下一个是用于组装完整的斯托克斯系统的划痕对象。请注意，我们从上面的StokesPreconditioner类派生出StokesSystem scratch类。我们这样做是因为所有用于组装预处理程序的对象也需要用于实际的矩阵系统和右手边，再加上一些额外的数据。这使得程序更加紧凑。还要注意的是，斯托克斯系统的装配和进一步的温度右手边分别需要温度和速度的数据，所以我们实际上需要两个FEValues对象来处理这两种情况。

[1.x.164] 



在定义了用于组装斯托克斯系统的对象后，我们对组装温度系统所需的矩阵也做了同样的定义。一般的结构是非常相似的。

[1.x.165] 



最后的划痕对象被用于组装温度系统的右侧。这个对象比上面的对象大得多，因为有更多的量进入温度方程右边的计算中。特别是，前两个时间步骤的温度值和梯度需要在正交点评估，还有速度和应变率（即速度的对称梯度），它们作为摩擦加热项进入右侧。尽管条款很多，但下面的条款应该是相当自我解释的。

[1.x.166] 



CopyData对象比Scratch对象更简单，因为它们所要做的就是存储局部计算的结果，直到它们可以被复制到全局矩阵或矢量对象中。因此，这些结构只需要提供一个构造函数，一个复制操作，以及一些用于局部矩阵、局部向量和局部与全局自由度之间关系的数组（又称[2.x.282]）。同样，我们为我们将使用WorkStream类并行化的四个操作中的每一个都有一个这样的结构。

[1.x.167] 




[1.x.168] [1.x.169]    


这是主类的声明。它与[2.x.283]非常相似，但有一些区别我们将在下面评论。   


类的顶部与[2.x.284]基本相同，列出了公共方法和一组做重活的私有函数。与[2.x.285]相比，本节只增加了两个内容：计算所有单元的最大CFL数的函数[2.x.286]，然后我们根据它计算全局时间步长；以及用于计算熵值稳定的函数[2.x.287]。它类似于我们在[2.x.289]中用于此目的的[2.x.288]，但它的工作对象是熵而不是温度。

[1.x.170] 



第一个重要的新组件是根据介绍中的讨论为参数定义了一个结构。该结构在构建该对象时通过读取参数文件进行初始化。

[1.x.171] 



[2.x.290]（针对[1.x.172]）对象用于简化写输出：每个MPI进程都可以像往常一样使用它来产生输出，但由于这些进程中的每一个都将（希望）产生相同的输出，它只是被多次复制；使用ConditionalOStream类，只有一个MPI进程产生的输出将真正被打印到屏幕上，而所有其他线程的输出将被简单遗忘。

[1.x.173] 



然后，下面的成员变量将再次与[2.x.291]中的成员变量相似（以及与其他教程程序相似）。正如介绍中提到的，我们完全分布计算，所以我们将不得不使用[2.x.292]类（见[2.x.293] ），但这些变量的其余部分相当标准，有两个例外。

     




- [2.x.294]变量用于表示高阶多项式映射。正如在介绍中提到的，我们在通过正交形成积分时使用这个映射，用于所有与我们域的内边界或外边界相邻的、边界是弯曲的单元。

     




- 在命名的混乱中，你会注意到下面一些来自命名空间TrilinosWrappers的变量取自命名空间[2.x.295]（比如右手边的向量），而其他变量则不是（比如各种矩阵）。这是由于遗留的原因。我们经常需要查询任意正交点的速度和温度；因此，每当我们需要访问与本地相关但属于另一个处理器的自由度时，我们不是导入矢量的幽灵信息，而是以%并行方式求解线性系统，但随后立即初始化一个矢量，包括求解的幽灵条目，以便进一步处理。因此，各种[2.x.296]向量在以%parallel求解各自的线性系统后立即被填充，并将始终包含所有[2.x.297]"本地相关自由度 "的值；我们从求解过程中获得的完全分布的向量，只包含[2.x.298]"本地拥有的自由度"，在求解过程后，在我们将相关值复制到成员变量向量后立即被销毁。

[1.x.174] 



下一个成员变量，[2.x.299]是用来方便地计算在某些重复输入的代码 "部分 "中花费的计算时间。例如，我们将进入（和离开）斯托克斯矩阵装配的部分，并希望在所有的时间步骤中累积在这部分花费的运行时间。每隔这么多时间步骤以及在程序结束时（通过TimerOutput类的析构器），我们将产生一个很好的总结，即在不同部分花费的时间，我们把这个程序的运行时间归类为不同的部分。

[1.x.175] 



在这些成员变量之后，我们还有一些从上面列出的辅助函数中分解出来的辅助函数。具体来说，首先有三个我们从[2.x.300]中调用的函数，然后是做线性系统组装的函数。

[1.x.176] 



按照[2.x.301]的 "基于任务的并行化 "范式，我们把所有的装配例程分成两部分：第一部分可以在某个单元上做所有的计算，而不需要照顾其他线程；第二部分（就是把本地数据写进全局矩阵和向量），每次只能由一个线程进入。为了实现这一点，我们为这一程序中使用的所有四个汇编例程的这两个步骤分别提供了函数。下面的八个函数正是这样做的。

[1.x.177] 



最后，我们向前声明一个成员类，我们将在以后定义这个成员类，它将被用来从我们的解向量中计算出一些数量，我们希望将这些数量放入输出文件中，以便进行可视化。

[1.x.178] 




[1.x.179] [1.x.180] 。





[1.x.181] [1.x.182]。   


这里是对斯托克斯问题的参数的定义。我们允许设置模拟的结束时间、细化水平（包括全局和自适应，总的来说就是指定允许单元的最大水平）以及细化的时间步长间隔。   


然后，我们让用户指定稳定参数的常数（如介绍中所讨论的），斯托克斯速度空间的多项式程度，是否对压力使用基于FE_DGP元素的局部保守离散化（对压力使用FE_Q元素），以及对温度插值的多项式程度。   


构造函数检查是否有有效的输入文件（如果没有，将写一个带有默认参数的文件），并最终解析参数。

[1.x.183] 



接下来我们有一个函数来声明我们在输入文件中期望的参数，以及它们的数据类型、默认值和描述。

[1.x.184] 



然后我们需要一个函数来读取我们通过读取输入文件得到的ParameterHandler对象的内容，并将结果放入存储我们先前声明的参数值的变量。

[1.x.185] 




[1.x.186][1.x.187] 。   


该问题的构造函数与 [2.x.302] 中的构造函数非常相似。不同的是%并行通信。Trilinos使用消息传递接口（MPI）进行数据分配。当进入BoussinesqFlowProblem类时，我们必须决定如何进行并行化。我们选择一个相当简单的策略，让所有正在运行程序的处理器一起工作，由通信器[2.x.303]指定。接下来，我们创建输出流（就像我们在[2.x.304]中已经做的那样），它只在第一个MPI进程上产生输出，而在其他所有进程上则完全不考虑。这个想法的实现是在[2.x.305]得到一个真实参数时检查进程号，它使用[2.x.306]流进行输出。例如，如果我们是一个处理器五，那么我们将给出一个 [2.x.307] ，这意味着该处理器的输出将不会被打印出来。除了映射对象（我们使用4度的多项式）外，所有的成员变量都与 [2.x.308] 中的完全相同。   


这个最后的对象，TimerOutput对象，然后被告知限制输出到[2.x.309]流（处理器0），然后我们指定要在程序结束时得到一个汇总表，该表显示我们的壁时钟时间（而不是CPU时间）。在下面的[2.x.310]函数中，我们还将手动请求每隔这么多时间步骤的中间总结。

[1.x.188] 




[1.x.189] [1.x.190] 。

[1.x.191] [1.x.192]。




除了两个小细节，计算速度的全局最大值的函数与 [2.x.311] 中的函数相同。第一个细节实际上是所有在三角形的所有单元上实现循环的函数所共有的。当以%并行方式操作时，每个处理器只能处理一大块单元，因为每个处理器只拥有整个三角形的某一部分。我们要处理的这块单元是通过所谓的[2.x.312]确定的，正如我们在[2.x.313]中所做的那样。因此，我们需要改变的是只对当前进程所拥有的单元格（相对于幽灵或人造单元格）进行与单元格相关的操作，即对子域id等于进程ID的数字。由于这是一个常用的操作，所以这个操作有一个捷径：我们可以用 [2.x.314] 询问单元格是否为当前处理器所拥有。   


第二个区别是我们计算最大值的方式。以前，我们可以简单地有一个[2.x.315]变量，在每个单元的每个正交点上检查。现在，我们必须更加小心，因为每个处理器只对单元格的一个子集进行操作。我们要做的是首先让每个处理器计算其单元中的最大值，然后做一个全局通信操作[2.x.316]，计算各个处理器所有最大值中的最大值。MPI提供了这样的调用，但是使用MPI通信器对象在命名空间[2.x.317]中使用相应的函数更为简单，因为即使我们不使用MPI并且只在一台机器上工作，这也会做正确的事情。对[2.x.318]的调用需要两个参数，即本地最大值（输入）和MPI通信器，在这个例子中是MPI_COMM_WORLD。

[1.x.193] 




[1.x.194] [1.x.195] 




下一个函数做了类似的事情，但我们现在计算CFL数，即一个单元上的最大速度除以单元直径。这个数字对于确定时间步长是必要的，因为我们对温度方程使用半显式的时间步长方案（讨论见[2.x.319]）。我们的计算方法与上述相同。在所有本地拥有的单元上计算本地最大值，然后通过MPI交换，找到全球最大值。

[1.x.196] 




[1.x.197] [1.x.198] 




接下来是计算全局熵的变化[2.x.320]，其中熵[2.x.321]的定义如介绍中所讨论的。 这对于评估温度方程中的稳定度是需要的，正如介绍中所解释的那样。实际上，只有当我们在残差计算中使用[2.x.322]作为幂时，才需要熵的变化。像离散计算中通常的那样，无穷大规范是由正交点上的最大值计算的。   


为了计算这个量，我们首先要找到空间平均数[2.x.323]，然后评估最大值。然而，这意味着我们需要执行两个循环。我们可以通过注意到[2.x.324]，即在正负方向上偏离平均熵的最大值来避免开销。我们在后一个公式中需要的四个量（最大熵、最小熵、平均熵、面积）都可以在所有单元格的同一个循环中评估，所以我们选择这个更简单的变体。

[1.x.199] 



在上面的两个函数中，我们计算了全部为非负数的数字的最大值，所以我们知道零肯定是一个下界。另一方面，在这里我们需要找到与平均值的最大偏差，也就是说，我们将需要知道熵的最大和最小值，而我们并不预先知道其符号。     


因此，为了计算它，我们可以从我们可以存储在一个双精度数字中的最大和最小的可能值开始。最小值被初始化为一个更大的数字，最大值被初始化为一个比任何一个将要出现的数字更小的数字。然后，我们保证这些数字将在第一个单元的循环中被覆盖，或者，如果这个处理器不拥有任何单元，最迟在通信步骤中被覆盖。然后，下面的循环会计算最小和最大的局部熵，以及跟踪我们局部拥有的域的部分的面积/体积和对它的熵的积分。

[1.x.200] 



现在我们只需要在处理器之间交换数据：我们需要将这两个积分相加（ [2.x.325] ），并得到最大和最小的极值。我们可以通过四个不同的数据交换来完成这个任务，但我们只需要两个就可以了。 [2.x.326]也存在一个变体，它接受一个数组的值，这些值都要被加起来。我们还可以利用[2.x.327]函数，认识到在最小熵上形成最小值等于在最小熵的负值上形成最大值的负值；然后这个最大值可以与在最大熵上形成的最大值相结合。

[1.x.201] 



以这种方式计算了一切之后，我们就可以计算平均熵，并通过取最大值或最小值与平均值的偏差中的较大者来找到[2.x.328]规范。

[1.x.202] 




[1.x.203] [1.x.204]。




下一个函数计算整个领域中外推温度的最小和最大值。同样，这只是 [2.x.329] 中各自函数的一个稍加修改的版本。和上面的函数一样，我们收集局部最小值和最大值，然后用上面的技巧计算出全局极值。   


正如在[2.x.330]中已经讨论过的，该函数需要区分第一个和所有后续的时间步骤，因为当至少有两个先前的时间步骤时，它使用了一个高阶温度外推方案。

[1.x.205] 




[1.x.206] [1.x.207] 




计算粘度的函数是纯粹的局部函数，因此根本不需要通信。它主要与[2.x.331]中的相同，但如果选择[2.x.332]，则有一个更新的粘度表述。

[1.x.208] 




[1.x.209] [1.x.210]。




下面的三个函数设置了斯托克斯矩阵、用于斯托克斯预处理的矩阵和温度矩阵。该代码与[2.x.333]中的代码基本相同，但为了简单起见，将其分解为三个自己的函数。   


这里的代码与[2.x.334]中的代码的主要功能区别在于，我们要建立的矩阵分布在多个处理器上。由于我们仍然希望出于效率的原因首先建立稀疏模式，我们可以继续将[1.x.211]的稀疏模式作为BlockDynamicSparsityPattern来建立，就像我们在[2.x.335]中做的那样。然而，这将是低效的：每个处理器将建立相同的稀疏模式，但只使用它初始化矩阵的一小部分。这也违反了一个原则，即每个处理器应该只在它拥有的单元上工作（如果有必要的话，还有它周围的幽灵单元层）。   


相反，我们使用一个类型为[2.x.336]的对象，它（显然）是对Trilinos提供的稀疏模式对象的一个封装。这样做的好处是Trilinos稀疏模式类可以在多个处理器之间进行通信：如果这个处理器填入它所拥有的单元格产生的所有非零条目，而其他每个处理器也这样做，那么在由[2.x.337]调用发起的MPI通信结束后，我们将有全局组装的稀疏模式可用，全局矩阵可以被初始化。   


在并行初始化Trilinos稀疏性模式时，有一个重要的方面。除了通过[2.x.338]索引集指定矩阵的本地拥有的行和列之外，我们还提供了在某个处理器上装配时可能要写进的所有行的信息。本地相关行的集合包含了所有这样的行（可能还有一些不必要的行，但在实际获得所有单元格的索引和解决约束之前，很难找到确切的行索引）。这种额外的信息可以准确地确定在装配过程中发现的非处理器数据的结构。虽然Trilinos矩阵也能在飞行中收集这些信息（当从其他一些reinit方法初始化它们时），但效率较低，在用多线程组装矩阵时，会导致问题。在这个程序中，我们悲观地假设每次只有一个处理器可以在组装时写入矩阵（而计算是并行的），这对特里诺斯矩阵是没有问题的。在实践中，可以通过在不共享顶点的单元中提示WorkStream来做得更好，允许这些单元之间的并行性（参见图形着色算法和带有彩色迭代器的WorkStream参数）。然而，这只在只有一个MPI处理器的情况下有效，因为Trilinos的内部数据结构在飞行中积累非处理器的数据，不是线程安全。有了这里介绍的初始化，就不存在这样的问题，人们可以安全地为这个算法引入图形着色。   


我们唯一需要做的改变是告诉[2.x.339]函数，它只应该在一个单元格子集上工作，即[2.x.340]等于当前处理器数量的单元格，而忽略所有其他单元格。   


这一策略被复制到以下三个函数中。   


请注意，Trilinos矩阵存储的信息包含在稀疏模式中，所以一旦矩阵被赋予稀疏结构，我们就可以安全地释放[2.x.341]变量。

[1.x.212] 



设置函数的其余部分（在拆分出上述三个函数后）主要是处理我们需要做的跨处理器并行化的事情。因为设置所有这些都是程序的一个重要的计算时间支出，所以我们把我们在这里做的所有事情都放到一个定时器组中，这样我们就可以在程序结束时得到关于这部分时间的总结信息。   


像往常一样，我们在顶部列举自由度，并按组件/块进行排序，然后从零号处理器开始将它们的数字写到屏幕上。当[2.x.342]函数应用于[2.x.343]对象时，对自由度进行排序的方式是所有与子域0相关的自由度都在所有与子域1相关的自由度之前，等等。对于斯托克斯部分，这意味着速度和压力会混在一起，但这可以通过再次按块排序来解决；值得注意的是，后一种操作只保留了所有速度和压力的相对顺序，即在速度块内，我们仍然会将所有与子域零相关的速度放在与子域一相关的速度之前，等等。这一点很重要，因为我们把这个矩阵的每一个块都分布在所有的处理器上，并且希望这样做的方式是，每个处理器存储的矩阵部分与它实际工作的单元上的自由度大致相等。   


在打印自由度的数字时，注意如果我们使用许多处理器，这些数字将会很大。因此，我们让流在每三个数字之间放一个逗号分隔符。流的状态，使用locale，从这个操作之前保存到之后。虽然有点不透明，但这段代码是有效的，因为默认的locale（我们使用构造函数调用[2.x.344]得到的）意味着打印数字时，每三位数字都有一个逗号分隔符（即，千、万、亿）。   


在这个函数以及下面的许多函数中，我们测量了我们在这里花费的时间，并将其收集在一个叫做 "设置dof系统 "的部分中，跨函数调用。这是用一个[2.x.345]对象完成的，该对象在构建本地变量时，在上述名称为`computing_timer`的部分启动一个定时器；当`timing_section`变量的析构器被调用时，该定时器再次停止。 当然，这要么发生在函数的末尾，要么我们通过`return`语句离开函数，或者在某处抛出异常时--换句话说，只要我们以任何方式离开这个函数。因此，使用这种 "范围 "对象可以确保我们不必手动添加代码，告诉定时器在每个可能离开这个函数的地方停止。

[1.x.213] 



在这之后，我们必须设置各种分区器（类型为[2.x.346] ，见介绍），描述每个矩阵或向量的哪些部分将被存储在哪里，然后调用实际设置矩阵的函数，在最后还要调整我们在这个程序中保留的各种向量的大小。

[1.x.214] 



在这之后，我们可以计算解向量的约束，包括悬挂节点的约束以及斯托克斯和温度场的同质和非同质边界值。请注意，与其他一切一样，约束对象不能在每个处理器上都持有[1.x.215]约束。相反，鉴于每个处理器只在其拥有的单元上组装线性系统，因此每个处理器只需要存储那些对正确性实际必要的约束。正如在[2.x.347]"本文 "中所讨论的，我们需要知道的约束集正是所有本地相关自由度的约束集，所以这就是我们用来初始化约束对象的东西。

[1.x.216] 



所有这些完成后，我们就可以将各种矩阵和向量对象初始化为适当的大小。在最后，我们还记录了所有的矩阵和前置条件器都必须在下一个时间步长的开始时重新计算。注意我们是如何初始化斯托克斯和温度右侧的向量的。这些是可写向量（最后一个布尔参数设置为[2.x.348]），对本地拥有的元素进行了正确的一对一划分，但仍然给出了相关的划分，以弄清要立即设置的向量条目的手段。至于矩阵，这允许用多个线程将本地贡献写入向量（总是假设同一向量条目不被多个线程同时访问）。其他向量只允许读取单个元素的访问，包括鬼魂，但不适合求解器。

[1.x.217] 




[1.x.218] [1.x.219]    


按照引言和[2.x.349]模块中的讨论，我们将装配函数分成不同的部分。   


 [2.x.350] [2.x.351] 矩阵和右手边的局部计算，给定某个单元作为输入（这些函数被命名为下面的[2.x.352]）。换句话说，所产生的函数本质上是[2.x.353]中所有单元格的循环体。然而，请注意，这些函数将本地计算的结果存储在CopyData命名空间的类的变量中。   


 [2.x.354] 然后这些对象被交给第二步，将本地数据写入全局数据结构（这些函数被命名为下面的[2.x.355] ）。这些函数是相当琐碎的。   


 [2.x.356] 然后这两个子函数被用于各自的汇编例程（下面称为[2.x.357]），在那里，一个WorkStream对象被设置并在属于处理器子域的所有单元中运行。  [2.x.358]  





[1.x.220][1.x.221]    


让我们从构建斯托克斯预处理的函数开始。考虑到上面的讨论，其中前两个是相当微不足道的。要特别注意的是，使用scratch数据对象的要点是，我们要避免每次访问新单元时在自由空间上分配任何对象。因此，下面的汇编函数只有自动的局部变量，其他的都是通过从头开始的数据对象访问的，在我们开始对所有单元进行循环之前，只分配一次。

[1.x.222] 



现在是使用WorkStream函数，实际将事情组合起来的函数。  [2.x.359]需要一个开始和结束迭代器来列举它应该工作的单元格。通常，我们会使用[2.x.360]和[2.x.361]来做这件事，但在这里，我们实际上只想获得实际上由当前处理器拥有的单元格子集。这就是FilteredIterator类发挥作用的地方：你给它一个单元格的范围，它提供一个迭代器，只迭代满足某个谓词的单元格子集（谓词是一个参数的函数，要么返回真，要么返回假）。我们在这里使用的谓词是[2.x.362]，也就是说，如果单元格为当前处理器所拥有，它就准确地返回真。这样得到的迭代器范围正是我们需要的。   


解决了这个障碍后，我们用这组单元格、scratch和copy对象以及两个函数的指针来调用[2.x.363]函数：本地装配和copy-local-to-global函数。这些函数需要有非常具体的签名：前者有三个参数，后者有一个参数（关于这些参数的含义，请参见[2.x.364]函数的文档）。注意我们是如何使用lambda函数来创建一个满足这一要求的函数对象的。它使用了指定单元格、抓取数据和复制数据的本地装配函数的函数参数，以及期望将数据写入全局矩阵的复制函数的函数参数（也可参见[2.x.365]的[2.x.366]函数中的讨论）。另一方面，成员函数的隐含的第2个参数（即该成员函数要操作的对象的[2.x.367]指针）是[1.x.223]到当前函数的[2.x.368]指针的，并被捕获。因此，[2.x.369]函数不需要知道这些函数所操作的对象的任何信息。   


当WorkStream被执行时，它将为几个单元创建几个第一类的本地装配例程，并让一些可用的处理器对它们进行工作。然而，需要同步的函数，即写入全局矩阵的操作，每次只由一个线程按照规定的顺序执行。当然，这只适用于单个MPI进程上的并行化。不同的MPI进程将有自己的WorkStream对象，并完全独立地进行这项工作（并且在不同的内存空间）。在分布式计算中，一些数据将积累在不属于各自处理器的自由度上。如果每次遇到这样的自由度就把数据送来送去，那就没有效率了。取而代之的是，Trilinos稀疏矩阵将保留这些数据，并在装配结束后通过调用[2.x.370]命令将其发送给所有者。

[1.x.224] 



这个模块的最后一个函数启动了斯托克斯预处理矩阵的装配，然后实际上是建立了斯托克斯预处理。它与串行情况下的功能基本相同。与[2.x.371]唯一不同的是，我们对压力质量矩阵使用雅可比预调节器，而不是IC，正如在介绍中所讨论的。

[1.x.225] 




[1.x.226] [1.x.227]。




接下来的三个函数实现了斯托克斯系统的装配，同样分为执行局部计算的部分，一个用于将局部数据写入全局矩阵和向量，一个用于在WorkStream类的帮助下实际运行所有单元的循环。请注意，只有在我们改变了网格的情况下才需要进行斯托克斯矩阵的组装。否则，这里只需要计算（与温度有关的）右手边。由于我们正在处理分布式矩阵和向量，我们必须在装配结束时调用相应的[2.x.372]函数，以便将非本地数据发送到所有者进程。

[1.x.228] 




[1.x.229] [1.x.230]。




接下来三个函数要执行的任务是计算质量矩阵和温度系统的拉普拉斯矩阵。这些将被结合起来，以产生半隐式时间步进矩阵，该矩阵由质量矩阵加上一个与时间[2.x.373]相关的权重系数乘以拉普拉斯矩阵组成。这个函数实质上又是对[2.x.374]中所有单元的循环体。   


下面两个函数的服务与上面的函数类似。

[1.x.231] 




[1.x.232] [1.x.233] 。




这是最后一个装配函数。它计算温度系统的右侧，其中包括对流和稳定项。它包括在正交点上对旧解的大量评估（这对计算稳定化的人工粘性是必要的），但在其他方面与其他装配函数类似。请注意，我们再次解决了具有不均匀边界条件的困境，只是在这一点上做了一个右手边（比较上面对[2.x.375]函数的评论）。我们创建一些矩阵列，其值正好是为温度刚度矩阵输入的值，以防我们有不均匀约束的DFS。这将说明右边的向量与温度矩阵系统的正确平衡。

[1.x.234] 



在运行实际计算右手边的WorkStream的函数中，我们也生成了最终的矩阵。如上所述，它是质量矩阵和拉普拉斯矩阵的总和，再加上一些与时间[2.x.376]相关的权重。这个权重是由BDF-2时间积分方案指定的，见 [2.x.377] 中的介绍。本教程中的新内容（除了使用MPI并行化和WorkStream类），是我们现在也预先计算了温度预处理程序。原因是与求解器相比，设置雅可比预处理器需要明显的时间，因为我们通常只需要10到20次迭代来求解温度系统（这听起来很奇怪，因为雅可比实际上只包括对角线，但在特里诺斯，它是从更普遍的点松弛预处理器框架中衍生出来的，效率有点低）。因此，尽管由于时间步长可能会发生变化，矩阵条目可能会略有变化，但预先计算预处理程序的效率更高。这不是一个太大的问题，因为我们每隔几个时间步长就会重新网格化（然后重新生成预处理程序）。

[1.x.235] 



下一个部分是计算右手边的向量。 为此，我们首先计算平均温度 [2.x.378] ，用于通过残差评估人工粘性稳定 [2.x.379] 。我们通过在熵粘度的定义中把最高和最低温度之间的中点定义为平均温度来做到这一点。另一种方法是使用积分平均，但结果对这种选择不是很敏感。那么剩下的就只需要再次调用[2.x.380]，将每次调用的[2.x.381]函数的参数绑定到正确的值上。

[1.x.236] 




[1.x.237] [1.x.238]。




这个函数解决了Boussinesq问题的每个时间步骤中的线性系统。首先，我们在斯托克斯系统上工作，然后在温度系统上工作。实质上，它与 [2.x.382] 中的相应函数所做的事情相同。然而，这里有一些变化。   


第一个变化与我们存储解决方案的方式有关：我们在每个MPI节点上保留具有本地自由度的向量加鬼魂节点。当我们进入一个应该用分布式矩阵执行矩阵-向量乘积的求解器时，这并不是合适的形式，虽然。在那里，我们希望求解向量的分布方式与矩阵的分布方式相同，即没有任何重影。因此，我们首先要做的是生成一个名为[2.x.383]的分布式向量，并只将本地拥有的dof放入其中，这由特里诺斯向量的[2.x.384]巧妙地完成。   


接下来，我们对解算器的压力解（或者说，初始猜测）进行缩放，使其与矩阵中的长度尺度相匹配，正如介绍中所讨论的。在求解完成后，我们也会立即将压力解决方案缩回到正确的单位。 我们还需要将悬挂节点的压力值设置为零。这一点我们在[2.x.385]中也做过，以避免一些在求解阶段实际上无关紧要的向量条目干扰舒尔补数。与[2.x.386]不同的是，这里我们只对局部拥有的压力道夫进行了处理。在对斯托克斯解进行求解后，每个处理器将分布式解复制到解向量中，其中也包括幽灵元素。   


第三个也是最明显的变化是，我们有两种斯托克斯求解器的变种。一种是有时会崩溃的快速求解器，另一种是速度较慢的稳健求解器。这就是我们在介绍中已经讨论过的。以下是我们如何实现它的。首先，我们用快速求解器进行30次迭代，该求解器是基于AMG V型循环的简单预处理，而不是近似求解（这由[2.x.387]对象的参数来表示）。如果我们收敛了，一切都很好。如果我们没有收敛，求解器控制对象将抛出一个异常[2.x.389]通常，这将中止程序，因为我们在通常的[2.x.390]函数中没有捕捉它们。这当然不是我们想在这里发生的。相反，我们希望切换到强求解器，并继续用我们目前得到的任何矢量进行求解。因此，我们用C++的try/catch机制来捕获这个异常。然后我们在[2.x.391]子句中简单地再次经历相同的求解器序列，这次将[2.x.392]标志传递给强求解器的预处理程序，表示有一个近似的CG求解。

[1.x.239] 



现在让我们转到温度部分。首先，我们计算时间步长。我们发现，对于壳的几何形状，我们需要三维的时间步长比二维的小。这是因为在这种情况下，单元格的变形更大（决定CFL数的是最小的边长）。我们不是像[2.x.393]中那样从最大速度和最小网格尺寸计算时间步长，而是计算局部的CFL数，即在每个单元上计算最大速度乘以网格尺寸，并计算它们的最大值。因此，我们需要将时间步长前面的系数选择得稍微小一些。     


在温度的右手边装配后，我们解决温度的线性系统（有完全分布的矢量，没有任何重影），应用约束条件并将矢量复制回有重影的矢量。     


最后，我们提取温度范围与[2.x.394]类似，以产生一些输出（例如为了帮助我们选择稳定常数，如介绍中所讨论的）。唯一的区别是，我们需要在所有处理器上交换最大值。

[1.x.240] 




[1.x.241] [1.x.242] 




接下来是生成输出的函数。输出的数量可以像我们在 [2.x.395] 中做的那样手动引入。另一个办法是把这个任务交给一个继承自DataPostprocessor类的PostProcessor，它可以被附加到DataOut上。这允许我们从解决方案中输出派生量，比如本例中的摩擦热。它重载了虚拟函数[2.x.396]，然后从[2.x.397]内部调用。 我们必须给它数值解、它的导数、单元的法线、实际评估点和任何额外的数量。这与[2.x.398]和其他程序中讨论的程序相同。

[1.x.243] 



这里我们定义了要输出的变量的名称。这些是速度、压力和温度的实际求解值，以及摩擦热和对每个单元拥有的处理器的编号。这使我们能够直观地看到处理器之间的领域划分。除了速度是矢量值的，其他所有的量都是标量。

[1.x.244] 



现在我们实现计算派生量的函数。正如我们对输出所做的那样，我们将速度从其SI单位重新调整为更容易阅读的单位，即厘米/年。接下来，压力被缩放为0和最大压力之间。这使得它更容易比较--本质上是使所有的压力变量变成正数或零。温度按原样计算，摩擦热按 [2.x.399] 计算。   


我们在这里输出的数量更多是为了说明问题，而不是为了实际的科学价值。我们在本程序的结果部分简要地回到这一点，并解释人们实际上可能感兴趣的是什么。

[1.x.245] 



[2.x.400]函数的任务与[2.x.401]中的类似。然而，在这里我们要演示一种不同的技术，即如何合并来自不同DoFHandler对象的输出。我们要实现这种重组的方法是创建一个联合的DoFHandler，收集两个部分，斯托克斯解和温度解。这可以通过将两个系统的有限元结合起来形成一个FES系统来很好地完成，并让这个集体系统定义一个新的DoFHandler对象。为了确保一切都做得很正确，我们进行了一次理智的检查，确保我们从斯托克斯和温度两个系统中得到了所有的道夫，甚至是在组合系统中。然后我们将数据向量合并。不幸的是，没有直接的关系告诉我们如何将斯托克斯和温度矢量分类到联合矢量中。我们可以绕过这个麻烦的方法是依靠FES系统中收集的信息。对于一个单元上的每个dof，联合有限元知道它属于哪个方程分量（速度分量、压力或温度）--这就是我们所需要的信息！这就是我们所需要的。因此，我们通过所有单元（迭代器进入所有三个DoFHandlers同步移动），对于每个联合单元dof，我们使用[2.x.402]函数读出该分量（关于其返回值的各个部分的描述见那里）。我们还需要跟踪我们是在斯托克斯道次还是温度道次，这包含在joint_fe.system_to_base_index(i).first.first中。最终，三个系统中的任何一个系统的dof_indices数据结构都会告诉我们全局矢量和局部dof之间的关系在当前单元上是怎样的，这就结束了这项繁琐的工作。我们确保每个处理器在建立联合求解向量时，只在其本地拥有的子域上工作（而不是在幽灵或人工单元上）。然后在[2.x.403]中也要这样做，但该函数会自动这样做。   


我们最终得到的是一组补丁，我们可以使用DataOutBase中的函数以各种输出格式编写补丁。在这里，我们必须注意，每个处理器所写的实际上只是它自己领域的一部分，也就是说，我们要把每个处理器的贡献写进一个单独的文件。我们通过在写解决方案时给文件名添加一个额外的数字来做到这一点。这其实并不新鲜，我们在 [2.x.404] 中也是这样做的。请注意，我们用压缩格式[2.x.405]而不是普通的vtk文件来写，这样可以节省相当多的存储。   


所有其余的工作都在PostProcessor类中完成。

[1.x.246] 




[1.x.247] [1.x.248] 




这个功能也不是真正的新功能。因为我们在中间调用的[2.x.406]函数有自己的定时器部分，所以我们把这个函数的定时分成两部分。这也可以让我们很容易地识别出这两个中哪个更昂贵。   


然而，有一点需要注意的是，我们只想在本地拥有的子域上计算错误指标。为了实现这一点，我们向[2.x.407]函数传递一个额外的参数。请注意，用于误差估计的向量被调整为当前进程上存在的活动单元的数量，这小于所有处理器上活动单元的总数（但多于本地拥有的活动单元的数量）；每个处理器只有本地拥有的单元周围有一些粗略的单元，这在 [2.x.408] 中也有解释。   


然后，本地误差估计值被交给GridRefinement的%并行版本（在命名空间[2.x.409]中，也见[2.x.410]），它查看误差并通过比较各处理器的误差值找到需要细化的单元。正如在[2.x.411]中，我们希望限制最大的网格级别。因此，万一有些单元格已经被标记为最细级别，我们只需清除细化标志。

[1.x.249] 



有了所有必要的标记，我们就可以告诉[2.x.412]对象准备将数据从一个网格转移到另一个网格，当Triangulation作为[2.x.413]调用的一部分通知它们时，它们会这样做。语法类似于非%并行解决方案的传输（例外的是这里有一个指向向量项的指针就足够了）。下面函数的其余部分是在网格细化后再次设置数据结构，并在新的网格上恢复求解向量。

[1.x.250] 



强制执行约束条件，使插值后的解在新网格上符合要求。

[1.x.251] 



强制执行约束条件，使插值后的解在新网格上符合要求。

[1.x.252] 




[1.x.253] [1.x.254]。




这是这个类中的最后一个和控制性的函数。事实上，它运行了整个程序的其余部分，并且再次与 [2.x.414] 非常相似。唯一的实质性区别是我们现在使用了不同的网格（一个[2.x.415]而不是一个简单的立方体几何）。

[1.x.255] 



 [2.x.416] 通过deal.II自己的本地MatrixFree框架支持大多数标准有限元的并行矢量类：由于我们使用中等阶数的标准拉格朗日元素，这个功能在这里很好地工作。

[1.x.256] 



在如此计算了当前的温度场之后，让我们设置持有温度节点的成员变量。严格来说，我们真的只需要设置[2.x.417]，因为我们要做的第一件事是计算斯托克斯解，它只需要前一个时间步长的温度场。尽管如此，如果我们想扩展我们的数值方法或物理模型，不初始化其他的向量也不会有什么好处（特别是这是一个相对便宜的操作，而且我们只需要在程序开始时做一次），所以我们也初始化[2.x.418]和[2.x.419]。这个赋值可以确保左边的向量（初始化后也包含鬼魂元素）也得到正确的鬼魂元素。换句话说，这里的赋值需要处理器之间的通信。

[1.x.257] 



为了加快线性求解器的速度，我们从旧的时间水平推断出解决方案到新的时间水平。这给出了一个非常好的初始猜测，将求解器中所需要的迭代次数减少了一半以上。我们不需要在最后一次迭代中进行推断，所以如果我们达到了最后的时间，我们就在这里停止。         


作为一个时间步骤中的最后一件事（在实际提升时间步骤的数量之前），我们检查当前时间步骤的数量是否能被100整除，如果是，我们就让计算计时器打印一个迄今为止所花费的CPU时间的总结。

[1.x.258] 



Trilinos sadd不喜欢鬼魂向量，即使作为输入。暂时复制到分布式向量中。

[1.x.259] 



如果我们要生成图形输出，也要为最后一个时间步骤这样做，除非我们在离开do-while循环之前刚刚这样做。

[1.x.260] 




[1.x.261] [1.x.262] 




主函数照例很短，与 [2.x.420] 中的函数非常相似。由于我们使用了一个在命令行中被指定为参数的文件，我们必须在这里读取它，并将其传递给Parameters类进行解析。如果在命令行中没有给出文件名，我们就简单地使用与程序一起分发的[2.x.421]文件。




因为除非你投入大量的处理器，否则三维计算是非常慢的，程序默认为二维。你可以通过把下面的常数维度改为3来获得3D版本。

[1.x.263] 

[1.x.264][1.x.265]。


当运行时，该程序以与[2.x.422]相同的方式模拟三维对流，尽管有一个完全不同的测试案例。


[1.x.266][1.x.267] 


然而，在我们讨论这个测试案例之前，让我们展示一下这个程序稍早版本的一些结果，它所解决的正是我们在[2.x.423]中使用的测试案例，只是我们现在以并行方式解决它，而且分辨率更高。我们展示这些结果主要是为了比较。

这里有两张图片显示了这种更高的分辨率，如果我们在[2.x.424]中选择一个三维计算，如果我们设置[2.x.425]和[2.x.426] 。在所示的时间步骤中，网格有大约72,000和236,000个单元，分别为2,680,000和8,250,000个自由度，比我们在[2.x.427]中的可用度多了一个数量级以上。

 [2.x.428]  

计算是在德克萨斯A&amp;M大学Brazos集群的50个处理器的一个子集上完成的。


[1.x.268][1.x.269] 。


接下来，我们将用目录中的参数文件运行[2.x.429]，但有一个变化：我们将最终时间增加到1e9。这里我们使用的是16个处理器。启动的命令是（注意，[2.x.430] .prm是默认的）。

<code> <pre> [2.x.431] mpirun -np 16 ./ [2.x.432] 活动单元的数量：12,288（在6层） 自由度的数量：186,624（99,840+36,864+49,920) 

时间步数0：t=0年 

   重建斯托克斯预处理程序...    求解斯托克斯系统... 41次迭代。   最大速度：60.4935厘米/年 时间步长：18166.9年 温度的17次CG迭代 温度范围：973 4273.16 

活动单元的数量：15,921（在7层） 自由度的数量：252,723（136,640+47,763+68,320) 

时间步数0：t=0年 

   重建斯托克斯预处理程序...    求解斯托克斯系统... 50次迭代。   最大速度：60.3223厘米/年 时间步长：10557.6年 温度的19次CG迭代 温度范围：973 4273.16 

活动单元的数量：19,926（在8层） 自由度的数量：321,246（174,312+59,778+87,156 

时间步数0：t=0年 

   重新建立斯托克斯预处理程序...    求解斯托克斯系统... 50次迭代。   最大速度：57.8396厘米/年 时间步长：5453.78年 温度的18次CG迭代 温度范围：973 4273.16 

时间步数1：t=5453.78年 

   求解斯托克斯系统... 49次迭代。   最大速度：59.0231厘米/年 时间步骤：5345.86年 温度的18次CG迭代 温度范围：973 4273.16 

时间步长2：t=10799.6年 

   解决斯托克斯系统...24次迭代。   最大速度：60.2139厘米/年 时间步长：5241.51年 17次温度的CG迭代 温度范围：973 4273.16 

[...] 

时间步长100：t=272151年 

   解决斯托克斯系统...21次迭代。   最大速度：161.546厘米/年 时间步长：1672.96年 温度的17次CG迭代 温度范围：973 4282.57 

活动单元的数量：56,085（在8层） 自由度的数量：903,408（490,102+168,255+245,051 




+---------------------------------------------+------------+------------+ | 从开始到现在，总的壁挂时间经过了115s | | | | | 部分 | 调用次数 | 壁挂时间 | 占总时间的百分比 | +---------------------------------+-----------+------------+------------+ | 组建斯托克斯系统 | 103 | 2.82s | 2.5% | 组建温度矩阵 | 12 | 0.452s | 0.39% | 组建温度Rhs | 103 | 11. 构建斯托克斯预调节器 | 12 | 2.09s | 1.8% | 解算斯托克斯系统 | 103 | 90.4s | 79% | 解算温度系统 | 103 | 1.53s | 1.3% | 后处理 | 3 | 0.532s | 0. 完善网格结构，第1部分 | 12 | 0.93s | 0.81% | 完善网格结构，第2部分 | 12 | 0.384s | 0.33% | 设置阻隔系统 | 13 | 2.96s | 2.6% | +---------------------------------+-----------+------------+------------+ 

[...] 

+---------------------------------------------+------------+------------+ | 从开始到现在，总的壁挂时间经过了9.14e+04s||||||||部分|调用次数|壁挂时间|占总数的百分比| +---------------------------------+-----------+------------+------------+ | 组建斯托克斯系统| 47045 | 2.05e+03s | 2.2% | 组建温度矩阵| 4707 | 310s | 0.34% | 组建温度rhs | 47045 | 8.7e+03s | 9. 4707 | 1.48e+03s | 1.6% | 解决斯托克斯系统 | 47045 | 7.34e+04s | 80% | 解决温度系统 | 47045 | 1.46e+03s | 1.6% | 后处理 | 1883 | 222s | 0. 24% | | 完善网格结构，第一部分 | 4706 | 641s | 0.7% | 完善网格结构，第二部分 | 4706 | 259s | 0.28% | 设置阻尼系统 | 4707 | 1.86e+03s | 2% | +---------------------------------+-----------+------------+------------+ </pre> </code> 

当时间达到输入文件中选择的10亿年时，模拟就会终止。 你可以从中推断出不同的最终时间的模拟需要多长时间（时间步长最终定格在2万年左右，所以计算20亿年将需要10万个时间步长，给或不给20%）。 从这里可以看出，我们把大部分的计算时间花在组装线性系统和&mdash;最重要的&mdash;解决斯托克斯系统。


为了演示输出，我们在这里展示了每1250个时间步骤的输出。 [2.x.433]  

最后两张图片显示了网格以及16个子域和16个处理器的同一计算中的网格划分情况。这个模拟的全部动态只有通过看动画才能看到，例如[1.x.270]。由于其艺术质量和对岩浆羽流演变的令人陶醉的描述，这个图像非常值得观看。

如果你观看这部影片，你会看到对流模式经历了几个阶段。首先，它摆脱了不稳定的温度分层，热物质被致密的冷物质覆盖。在这个巨大的驱动力被消除后，我们有了一种稳定的情况，几个小球开始从内圈的热边界层中分离出来并上升，几个冷指也从外部边界层中掉下来。在这一阶段，解决方案仍然大部分是对称的，反映了原始网格的12倍对称性。在最后一个阶段，流体进入剧烈的混沌搅拌，其中所有的对称性都消失了。这是一个随后继续主导流动的模式。

如果我们看一下模拟中作为时间函数的最大速度，也可以确定这些不同阶段。

 [2.x.434]  

在这里，当温度分层不稳定时，速度（以每年厘米为单位）在开始时变得非常大，达到每年几米的量级）。然后，在混乱的搅拌系统中再次回升之前，它平静下来，变成相对较小的数值。在那里，它保持在每年10-40厘米的范围内，完全在物理上预期的区域内。


[1.x.271][1.x.272] 。


三维计算在计算上是非常昂贵的。此外，如上所述，有趣的行为只有在相当长的时间后才开始，需要更多的CPU时间，而不是在一个典型的集群上可用。因此，与其在这里展示一个完整的模拟，不如让我们简单地展示几张图片，我们使用这个程序的后续程序，称为[1.x.273]（简称[1.x.274]），该程序正在独立于deal.II开发，已经包含了下面讨论的一些扩展。下面两张图片显示了温度的等值线和领域（连同网格）在512个处理器上的划分。

 [2.x.435]  


[1.x.275] [1.x.276][1.x.277] 。


这个程序有很多可以扩展的方向。正如在介绍的最后提到的，在本教程程序完成时，其中大部分正在[1.x.278]（简称[1.x.279]）代码中积极开发。具体来说，以下肯定是人们应该解决的主题，以使程序更加有用。

 [2.x.436] [2.x.437] [1.x.280] 我们在模拟中得到的温度场在一段时间后大多是恒定的，在内部和外部边界有边界层，冷和热材料的流线混合了一切。然而，这并不符合我们的预期，即靠近地心的东西应该比靠近地表的东西更热。原因是我们使用的能量方程不包括一个描述绝热冷却和加热的术语：岩石，像气体一样，在你压缩它的时候会加热。因此，上升的物质以绝热方式冷却，而下沉的冷物质则以绝热方式加热。因此，正确的温度方程看起来有点像这样。  [1.x.281] 

  或者，扩大平流导数[2.x.438] ：[1.x.282] 。

  换句话说，随着岩石体积中压力的增加（[2.x.439]），我们得到一个额外的热源，反之亦然。

  压力的时间导数实现起来有点困难。如果有必要，我们可以利用导言中概述的事实进行近似计算，即压力可以分解为由于温差和由此产生的流动而产生的动态部分，以及仅由上覆岩石的静态压力产生的静态部分。由于后者要大得多，我们可以对[2.x.440]以及[2.x.441]进行近似分析。  换句话说，如果流体沿着重力方向（向下）运动，它将被压缩，因为在这种情况下[2.x.442]我们得到一个正的热源。相反，如果流体逆着重力方向运动，它将被冷却。

 [2.x.443] [1.x.283] 正如上文温度模型中已经暗示的那样，地幔岩石不是不可压缩的。相反，鉴于地幔中的巨大压力（在地核-地幔边界，压力约为140GPa，相当于大气压力的140万倍），岩石实际上确实被压缩到它在表面压力下的密度的1.5倍左右。建立这个模型有很多困难。首先，质量守恒方程不再是[2.x.444]，而应该是[2.x.445]，其中密度[2.x.446]现在不再是空间常数，而是取决于温度和压力。一个后果是，该模型现在不再是线性的；线性化的斯托克斯方程也不再是对称的，需要我们重新考虑预处理程序，甚至可能是离散化。至于如何解决这个问题，我们在这里就不做详细介绍了。

 [2.x.447] [1.x.284] 正如在不同地方已经暗示的那样，材料参数，如密度、粘度和各种热参数在整个地幔中不是恒定的。相反，它们非线性地依赖于压力和温度，在粘度的情况下，还依赖于应变率 [2.x.448] 。对于复杂的模型，准确解决这种模型的唯一方法可能是在每个时间步骤中实际迭代出这种依赖关系，而不是简单地将系数冻结在从前一个（几个）时间步骤推算出来的数值上。

 [2.x.449] [1.x.285] 在一些处理器上运行这个2D程序可以在一两天内解决现实的模型。然而，在3d中，计算时间非常大，以至于遇到了两个典型的问题。(i) 在大多数计算集群上，排队系统将单个作业的运行时间限制在2到3天；(ii) 当在数百个处理器上运行几天时，由于硬件故障、错误配置或断电而丢失计算结果是一种耻辱。这两个问题都可以通过定期保存程序的状态来解决，如果有必要，在这个时候重新启动程序。这种技术通常被称为[1.x.286]，它要求将程序的整个状态写到一个永久的存储位置（如硬盘）。考虑到这个程序的数据结构的复杂性，这并不是完全微不足道的（也可能涉及到写入数千兆字节或更多的数据），但可以通过意识到可以在两个时间步骤之间保存状态，其中基本上只包括网格和解向量；在重新启动期间，然后首先按照之前的方式重新列举自由度，然后重新组装矩阵。然而，考虑到这里涉及的数据结构的分布性质，保存和恢复程序的状态并不简单。一个额外的复杂性是由以下事实引入的：人们可能希望在两次运行之间改变处理器的数量，例如，因为人们可能希望在一个比用于在中间时间预计算起始温度场的网格更精细的网格上继续计算。

 [2.x.450] [1.x.287] 像这样的计算的重点不是简单地解决方程。相反，它通常是探索不同的物理模型，并将其与我们在地球表面可以测量的东西进行比较，以便发现哪些模型是现实的，哪些与现实相矛盾。为此，我们需要从我们的解决方案向量中计算出与我们可以观察到的东西有关的数量。例如，其中包括地球表面的热流，以及整个地幔的地震速度，因为这些影响到地震仪所记录的地震波。

 [2.x.451] [1.x.288] 从上面的三维案例可以看出，三维的网格主要是沿着内部边界进行细化。这是因为那里的边界层比领域中的任何其他过渡都要强，导致我们几乎只在那里细化，而基本上不按照羽流的方向细化。我们当然需要更好的细化标准来跟踪我们真正感兴趣的部分，而不是这里使用的标准，即应用于温度的KellyErrorEstimator，能够做到。 [2.x.452]  


还有许多其他方法可以扩展当前的程序。然而，与其在这里讨论它们，不如让我们指出更大的开放源代码ASPECT（见https://aspect.geodynamics.org/），它构成了[2.x.453]的进一步发展，已经包括了许多这样的可能的扩展。[1.x.289] [1.x.290] [2.x.454] 。 

 [2.x.455] 
