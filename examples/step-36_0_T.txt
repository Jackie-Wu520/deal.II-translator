 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19] 

 [2.x.3]  

[1.x.20] 

[1.x.21][1.x.22][1.x.23] 。


在这个例子中，我们要解决的问题是一个特征谱问题。特征值问题出现在广泛的问题背景中，例如，在计算腔体中的电磁驻波、鼓膜的振动模式或湖泊和河口的振荡中。最神秘的应用之一可能是量子力学中静止或准静止波函数的计算。后一种应用是我们在此想研究的，尽管本方案中概述的一般技术当然同样适用于上述其他应用。

Eigenspectrum问题的一般形式是 

[1.x.24] 

其中[2.x.4]上的Dirichlet边界条件也可以用Neumann或Robin条件代替；[2.x.5]是一个算子，一般也包含微分算子。

在合适的条件下，上述方程有一组解[2.x.6] , [2.x.7] ，其中[2.x.8]可以是一个有限或无限的集合（在后一种情况下，它可能是一个离散的或有时至少部分是一个连续的集合）。在这两种情况下，让我们注意到，我们要计算的不再只是一个单一的解，而是一组解（各种特征函数和相应的特征值）。从数字上寻找这类特征值问题的所有特征值（特征函数）的问题是一个艰巨的挑战。事实上，如果集合[2.x.9]是无限的，这个挑战当然是难以解决的。 然而，大多数时候，我们实际上只对这些值（函数）的一小部分感兴趣；幸运的是，我们在这个教程程序中使用的SLEPc库的接口允许我们选择特征谱的哪一部分和我们想要解决的多少个解决方案。

在这个程序中，我们使用的eigenspectrum求解器是由deal.II提供的类，这些类包裹着[1.x.25]库的线性代数实现；SLEPc本身建立在[1.x.26]库的线性代数内容上。

[1.x.27] [1.x.28][1.x.29] 。


静态量子力学的基本方程是薛定谔方程，它模拟了粒子在外部势中的运动 [2.x.10] 。粒子由一个波函数[2.x.11]描述，该波函数满足（非维度化）形式的关系 

[1.x.30] 

因此，这个粒子只能存在于一定数量的特征态中，这些特征态对应于作为该方程解的能量特征值[2.x.12]。量子力学的正统（哥本哈根）解释认为，如果一个粒子具有能量[2.x.13]，那么在位置[2.x.14]发现它的概率与[2.x.15]成正比，其中[2.x.16]是对应于这个特征值的特征函数。

为了在数值上找到这个方程的解，即一组成对的特征值/特征函数，我们使用通常的有限元方法，将左边的方程与测试函数相乘，通过部分积分，在有限维空间中通过近似[2.x.17]寻找解，其中[2.x.18]是膨胀系数的向量。然后我们立即得出以下方程，该方程将连续特征值问题离散化：[1.x.31] 用矩阵和矢量符号表示，该方程为。[1.x.32] 其中[2.x.19]是由微分算子[2.x.20]产生的刚度矩阵，而[2.x.21]是质量矩阵。特征值问题的解决方案是一个特征谱[2.x.22]，以及相关的特征函数[2.x.23] 。


[1.x.33][1.x.34] 。


在这个程序中，我们对波函数[2.x.24]使用了Dirichlet边界条件。从有限元代码的角度来看，这意味着只有内部的自由度是[1.x.35]的实数度：边界上的自由度不是自由的，但毕竟是被迫有一个零值。另一方面，有限元方法从以下事实中获得了许多力量和简单性：我们只是在每个单元上做同样的事情，而不必过多地考虑一个单元在哪里，它是否与一个不太精细的单元相接，因而有一个悬挂的节点，或者与边界相邻。所有这些检查都会使有限元线性系统的装配难以编写，甚至更难阅读。

因此，当然，当你用DoFHandler对象分配自由度时，你并不关心你列举的一些自由度是否在迪里切特边界。他们都会得到数字。我们只需要在以后应用边界值的时候照顾到这些自由度。有两种基本的方法（要么使用[2.x.25][1.x.36]装配线性系统，要么使用[2.x.26][1.x.37]装配；详见[2.x.27]"约束模块"），但两者的结果是一样的：一个线性系统的总行数等于[1.x.38]自由度的数目，包括那些位于边界的自由度。然而，受迪里希特条件约束的自由度与线性系统的其他部分分开，方法是将相应的行和列清零，在对角线上放一个正条目，并在右手边放相应的迪里希特值。

如果你暂时假设我们对自由度进行了重新编号，使迪里切特边界上的所有自由度都排在最后，那么在解决一个有右手边的常规PDE时，我们得到的线性系统会是这样的。

[1.x.39] 

这里，下标[2.x.28]和[2.x.29]分别对应于内部和边界自由度。内部自由度满足线性系统[2.x.30]，在内部产生正确的解，边界值由[2.x.31]决定，其中[2.x.32]是一个对角矩阵，由消除边界自由度的过程产生，而[2.x.33]的选择方式是[2.x.34 ]对每个边界自由度都有正确的边界值[2.x.35]。 对于好奇的人来说，矩阵[2.x.36]的条目是将修改后的局部贡献加入全局矩阵的结果，对于局部矩阵，如果非零，对角线元素被设置为其绝对值；否则，它们被设置为对角线绝对值的平均值。这个过程保证了[2.x.37]的条目是正的，并且大小与对角线的其他条目相当，确保所产生的矩阵不会因为涉及到大小迥异的矩阵条目的舍入而产生不合理的精度损失。最终出现在对角线上的实际数值是很难预测的，你应该把它们当作任意的、不可预测的，但却是正的。) 

对于 "常规 "线性系统，这一切都导致了正确的解决方案。另一方面，对于特征值问题，这就不那么简单了。在那里，消除边界值会影响到我们在当前教程程序中要解决的两个矩阵[2.x.38]和[2.x.39]。消除边界值后，我们就会得到一个可以这样划分的特征值问题。

[1.x.40] 

这种形式清楚地表明，有两组特征值：我们关心的那些，以及来自分离问题的虚假特征值[1.x.41]这些特征值是虚假的，因为它们是由一个只在边界节点上操作的特征值系统产生的--这些节点不是[1.x.42]的实数度。当然，由于两个矩阵[2.x.40]是对角线，我们可以准确地量化这些虚假的特征值：它们是[2.x.41]（其中指数[2.x.42]正好对应于受迪里切特边界值约束的自由度）。

那么，如何处理这些问题呢？第一部分是识别我们的特征值求解器何时发现其中的一个。为此，程序通过计算所有受限自由度上表达式[2.x.43]的最小和最大，计算并打印出这些特征值所在的区间。在下面的程序中，这已经足够了：我们发现这个区间位于我们感兴趣并计算的最小特征值和相应的特征函数的集合之外，所以这里我们不需要做什么。

另一方面，我们可能会发现我们在这个程序中计算的一个特征值恰好在这个区间内，在这种情况下，我们不会立即知道它是一个虚假的还是一个真正的特征值。在这种情况下，我们可以在计算完两个矩阵后简单地缩放其中一个矩阵的对角线元素，从而将它们从特征谱的感兴趣的频率上移开。这可以通过使用以下代码来完成，确保所有假的特征值正好等于[2.x.44] 。

[1.x.43] 

然而，这里没有采用这种策略，因为我们从程序中得到的假性特征值恰好大于我们要计算和感兴趣的最低的五个。


[1.x.44][1.x.45] 。


下面的程序本质上只是[2.x.45]的一个稍加修改的版本。不同的地方有以下几点。

 [2.x.46]  

 [2.x.47] 主类（名为[2.x.48]）现在不再有单一的解向量，而是有一整套我们要计算的各种特征函数的向量。此外，[2.x.49]函数对这里的一切都有顶层控制，它通过[2.x.50]和[2.x.51]同时初始化和最终确定与SLEPc和PETSc的接口。[2.x.52]  

 [2.x.53] 我们使用PETSc的矩阵和向量，如[2.x.54]和[2.x.55]，因为这是SLEPc特征值求解器的要求。[2.x.56]  

 [2.x.57] 函数[2.x.58]与本教程中迄今所见的任何函数都完全不同，因为它不只是求解一个线性系统，而是实际求解特征值问题。它建立在SLEPc库上，更直接的是建立在类[2.x.59]的deal.II SLEPc包装器上。 

 [2.x.60] 我们使用ParameterHandler类来描述一些输入参数，如势的确切形式[2.x.61] ，网格的全局细化步数，或我们要解决的特征值数量。我们可以在这方面做得更多，但只限于在运行时选择一些实际的输入文件参数。为了看看在这方面可以做什么，看看 [2.x.62] " [2.x.63] " 和 [2.x.64] 。[2.x.65]  

 [2.x.66] 我们使用FunctionParser类，使潜在的 [2.x.67] 成为运行时参数，可以在输入文件中指定为一个公式。[2.x.68]  

 [2.x.69]  

程序的其余部分以一种相当直接的方式从[2.x.70]开始。[1.x.46] [1.x.47] 。


[1.x.48] [1.x.49] 。




正如在介绍中提到的，这个程序本质上只是[2.x.71]的一个稍作修改的版本。因此，以下大部分的include文件都是在那里使用的，或者至少是在以前的教程程序中已经使用过的。

[1.x.50] 



IndexSet用于设置每个 [2.x.72] 的大小。 

[1.x.51] 



PETSc出现在这里是因为SLEPc依赖于这个库。

[1.x.52] 



然后我们需要实际导入SLEPc所提供的求解器的接口。

[1.x.53] 



我们还需要一些标准的C++。

[1.x.54] 



最后，和以前的程序一样，我们将所有deal.II的类和函数名导入本程序中的所有内容都将进入的命名空间。

[1.x.55] 




[1.x.56] [1.x.57] 。




下面是主类模板的类声明。它看起来和在 [2.x.73] 中已经展示过的差不多。

[1.x.58] 



除了这些例外情况。对于我们的特征值问题，我们既需要左手边的刚度矩阵，也需要右手边的质量矩阵。我们还需要的不仅仅是一个解函数，而是一整套用于我们要计算的特征函数的解函数，以及相应的特征值。

[1.x.59] 



然后我们需要一个对象来存储我们将在输入文件中指定的几个运行时参数。

[1.x.60] 



最后，我们将有一个对象，包含对我们自由度的 "约束"。如果我们有自适应细化的网格（目前的程序中没有），这可能包括悬挂节点约束。在这里，我们将存储边界节点的约束 [2.x.74] 。

[1.x.61] 




[1.x.62] [1.x.63] 。





[1.x.64] [1.x.65] 。




首先是构造函数。主要的新部分是处理运行时的输入参数。我们需要首先声明它们的存在，然后从输入文件中读取它们的值，该文件的名称被指定为该函数的参数。

[1.x.66] 



TODO研究为什么获得正确的特征值退化所需的最小细化步骤数是6。

[1.x.67] 




[1.x.68] [1.x.69] 




下一个函数在域[2.x.75]上创建一个网格，根据输入文件的要求对其进行多次细化，然后将DoFHandler附加到其上，并将矩阵和向量初始化为正确的大小。我们还建立了对应于边界值的约束条件 [2.x.76] 。   


对于矩阵，我们使用PETSc包装器。这些包装器能够在非零项被添加时根据需要分配内存。这似乎是低效的：我们可以先计算稀疏模式，用它来初始化矩阵，然后在我们插入条目时，我们可以确定我们不需要重新分配内存和释放之前使用的内存。一种方法是使用这样的代码。 [2.x.77]代替下面两个[2.x.78]对刚度和质量矩阵的调用。   


不幸的是，这并不完全可行。上面的代码可能会导致在非零模式下的一些条目，我们只写零条目；最值得注意的是，对于那些属于边界节点的行和列的非对角线条目，这一点是成立的。这不应该是一个问题，但是不管什么原因，PETSc的ILU预处理程序（我们用来解决特征值求解器中的线性系统）不喜欢这些额外的条目，并以错误信息终止。   


在没有任何明显的方法来避免这种情况的情况下，我们干脆选择了第二种最佳方案，即让PETSc在必要时分配内存。也就是说，由于这不是一个时间关键的部分，这整个事件没有进一步的重要性了。

[1.x.71] 



下一步是处理eigenspectrum的问题。在这种情况下，输出是特征值和特征函数，所以我们将特征函数和特征值列表的大小设置为与我们在输入文件中要求的一样大。当使用[2.x.79]时，Vector是使用IndexSet初始化的。IndexSet不仅用于调整[2.x.80]的大小，而且还将[2.x.81]中的一个索引与一个自由度联系起来（更详细的解释见[2.x.82]）。函数complete_index_set()创建了一个IndexSet，每个有效的索引都是这个集合的一部分。请注意，这个程序只能按顺序运行，如果并行使用，将抛出一个异常。

[1.x.72] 




[1.x.73] [1.x.74] 




在这里，我们分别从局部贡献[2.x.83]和[2.x.84]组装全局刚度和质量矩阵。如果你看过以前的教程程序，这个函数应该会很熟悉。唯一新的东西是使用我们从输入文件得到的表达式设置一个描述势[2.x.85]的对象。然后我们需要在每个单元的正交点上评估这个对象。如果你见过如何评估函数对象（例如，见[2.x.86]中的系数），这里的代码也会显得相当熟悉。

[1.x.75] 



现在我们有了局部矩阵的贡献，我们把它们转移到全局对象中，并处理好零边界约束。

[1.x.76] 



在函数的最后，我们告诉PETSc，矩阵现在已经完全组装好了，稀疏矩阵表示法现在可以被压缩了，因为不会再添加任何条目。

[1.x.77] 



在离开函数之前，我们要计算虚假的特征值，这是由零Dirichlet约束引入到系统中的。正如在介绍中所讨论的，使用Dirichlet边界条件，加上位于域的边界的自由度仍然是我们所求解的线性系统的一部分，引入了一些虚假的特征值。下面，我们输出它们所处的区间，以确保我们在计算中出现时可以忽略它们。

[1.x.78] 




[1.x.79] [1.x.80] 




这是该程序的关键新功能。现在系统已经设置好了，现在是实际解决问题的好时机：和其他例子一样，这是用 "解决 "程序来完成的。从本质上讲，它的工作原理与其他程序一样：你设置一个SolverControl对象，描述我们要解决的线性系统的精度，然后我们选择我们想要的解算器类型。在这里，我们选择SLEPc的Krylov-Schur求解器，对于这种问题来说，这是一个相当快速和强大的选择。

[1.x.81] 



我们从这里开始，就像我们通常做的那样，指定我们想要的收敛控制。

[1.x.82] 



在我们实际求解特征函数和-值之前，我们还必须选择哪一组特征值来求解。让我们选择那些实部最小的特征值和相应的特征函数（事实上，我们在这里解决的问题是对称的，所以特征值是纯实部的）。之后，我们就可以真正让SLEPc做它的工作了。

[1.x.83] 



上述调用的输出是一组向量和数值。在特征值问题中，特征函数只确定到一个可以任意固定的常数。由于对特征值问题的原点一无所知，SLEPc除了将特征向量归一到[2.x.87]（向量）准则外，没有其他选择。不幸的是，这个规范与我们从特征函数角度可能感兴趣的任何规范没有什么关系：[2.x.88]规范，或者也许是[2.x.89]规范。     


让我们选择后者，并重新调整特征函数的尺度，使其具有[2.x.90]而不是[2.x.91]（其中[2.x.92]是[2.x.93]第三个特征[1.x.84]，[2.x.94]是相应的结点值矢量）。对于这里选择的[2.x.95]元素，我们知道函数[2.x.96]的最大值是在其中一个节点上达到的，所以[2.x.97]，使得在[2.x.98]准则下的归一化是很简单的。请注意，如果我们选择[2.x.99]元素与[2.x.100]，这就不那么容易了：在那里，一个函数的最大值不一定要在一个节点上达到，所以[2.x.101]（尽管平等通常几乎是真的）。

[1.x.85] 



最后返回收敛所需的迭代次数。

[1.x.86] 




[1.x.87] [1.x.88] 




这是本程序的最后一个重要功能。它使用DataOut类来生成特征函数的图形输出，以便以后进行可视化。它的工作原理与其他许多教程程序一样。   


然后整个函数集合被输出为一个单一的VTK文件。

[1.x.89] 



唯一值得讨论的是，由于潜能在输入文件中被指定为一个函数表达式，如果能将其与特征函数一起以图形形式表示出来就更好了。实现这一目标的过程相对简单：我们建立一个代表[2.x.102]的对象，然后将这个连续函数插值到有限元空间。其结果我们也附加到DataOut对象上，以便进行可视化。

[1.x.90] 




[1.x.91][1.x.92] 。




这是一个对一切都有顶层控制的函数。它几乎与 [2.x.103] 中的内容完全相同。

[1.x.93] 




[1.x.94] [1.x.95] 。

[1.x.96] 



这个程序只能在串行中运行。否则，抛出一个异常。

[1.x.97] 



在这期间，我们一直在注意是否有任何异常应该被产生。如果是这样的话，我们就会惊慌失措... 

[1.x.98] 



如果没有抛出异常，那么我们就告诉程序不要再胡闹了，乖乖地退出。

[1.x.99] 

[1.x.100][1.x.101]。


[1.x.102][1.x.103]。


该问题的输入由一个输入文件[2.x.104]作为参数，例如，该文件可以包含以下文本。

[1.x.104] 



这里，域内电势为零，我们知道特征值由 [2.x.105] 给出，其中 [2.x.106] 。特征函数是正弦和余弦，在[2.x.107]和[2.x.108]方向有[2.x.109]和[2.x.110]个周期。这与我们的程序产生的输出相匹配。

[1.x.105] 这些特征值正是对应于[2.x.111]、[2.x.112]和[2.x.113]、[2.x.114]和[2.x.115]等对。相应的特征函数的可视化将看起来像这样。

 [2.x.116]  

[1.x.106][1.x.107] 。


在操场上玩一些游戏总是值得的! 所以这里有几个建议。

 [2.x.117]  

 [2.x.118] 上面使用的势（称为[1.x.108]，因为它是一个由无限高的墙包围的平坦势）很有趣，因为它允许有分析上已知的解决方案。然而，除此之外，它是相当无聊的。也就是说，通过在输入文件中设置不同的势来玩弄这个势是很容易的。例如，让我们假设我们想在2d中使用以下势。[1.x.109] 换句话说，在半径为0.75的圆的两个扇面中，电势是-100，在另外两个扇面中是-5，而在圆外是零。我们可以通过在输入文件中使用以下内容来实现这一点。

[1.x.110] 

此外，如果我们还将网格细化程度提高一级，我们会得到以下结果。

[1.x.111] 



输出文件还包含一个内插的势的版本，看起来像这样（注意，正如预期的那样，最低的几个特征模式的概率密度[2.x.119]只有在势最低的地方，即在势的内圈的右上角和左下角的部分才是重要的）。

 [2.x.120]  

前五个特征函数现在是这样的。

 [2.x.121]  

 [2.x.122] 在我们对问题的推导中，我们假设粒子被限制在一个域中[2.x.123]，并且在这个域的边界，其存在的概率[2.x.124]为零。这相当于解决所有[2.x.125]上的特征值问题，并假设能量势只在[2.x.126]区域内是有限的，而在区域外是无限的。相对来说，可以证明[2.x.127]在[2.x.128]的所有位置上，[2.x.129] 。那么问题来了，如果我们的势不是这种形式，也就是说，没有一个势是无限的有界域，会发生什么？在这种情况下，可能值得只考虑一个非常大的边界域，其中[2.x.130]即使不是无限的，也至少是非常大的。像这样玩一玩，探索一下当我们使计算区域越来越大时，频谱和特征函数如何变化。

 [2.x.131] 如果我们研究简单的谐波振荡器问题[2.x.132]会怎样？这个势正是上一段讨论的形式，具有超球面对称性。人们可能想用一个大的外半径的球面域，来近似于全空间问题（例如，通过调用[2.x.133]）。 

 [2.x.134] 上面的图显示了波函数 [2.x.135] ，但感兴趣的物理量实际上是粒子在位置 [2.x.137] 的概率密度 [2.x.136] 。一些可视化程序可以从输入文件中的数据计算出派生量，但我们也可以在创建输出文件时立即这样做。这样做的工具是DataPostprocessor类，可以和DataOut类一起使用。如何做到这一点的例子可以在 [2.x.138] 和 [2.x.139] 中找到。

 [2.x.140] 如果盒子里的粒子有%的内部自由度会怎样？例如，如果该粒子是一个自旋- [2.x.141] 粒子？在这种情况下，我们可能要开始解决一个矢量值的问题，而不是。

 [2.x.142] 我们这里的deal.II库的实现使用了PETScWrappers和SLEPcWrappers，适合在串行机器结构上运行。然而，对于更大的网格和更多的自由度，我们可能希望在并行架构上运行我们的应用程序。上述代码的并行实现在这里可能特别有用，因为广义的特征谱问题比前面大多数教程中考虑的标准问题的解决成本更高。幸运的是，将上述程序修改为与MPI兼容是一个相对简单的过程。关于如何做到这一点的简述可以在 [2.x.143] " [2.x.144] " 中找到。

 deal.II有与其中之一ARPACK（见[1.x.112]的设置说明）的接口，在ArpackSolver类中实现。下面是一个简短的、快速的概述，说明使用它需要改变什么，前提是你有一个工作的ARPACK安装，并且deal.II已经为它正确配置了（见deal.II [1.x.113]文件）。

首先，为了使用ARPACK接口，我们可以回到使用标准的deal.II矩阵和向量，所以我们开始替换PETSc和SLEPc头文件 

[1.x.114] 

替换成这些。

[1.x.115] 

ARPACK允许复杂的特征值，所以我们还需要 

[1.x.116] 



其次，我们换回主类中的deal.II矩阵和向量定义。

[1.x.117] 

并像往常一样在 [2.x.146] 中初始化它们。

[1.x.118] 



为了用ARPACK解决特征值问题，我们最后需要修改[2.x.147] 。

[1.x.119] 

注意我们是如何使用精确分解（使用SparseDirectUMFPACK）作为ARPACK的前置条件的。 [2.x.148] [1.x.120] [1.x.121] [2.x.149]。 

 [2.x.150] 
