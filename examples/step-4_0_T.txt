 [2.x.0] [2.x.1]。 

本教程取决于 [2.x.2] 。

[1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18] 

[1.x.19] [1.x.20][1.x.21]。


 [2.x.3]  

deal.II有一个独特的功能，我们称之为 "无维度编程"。你可能已经注意到在前面的例子中，许多类都有一个带角括号的数字后缀。这是为了表明，例如，二维和三维空间的三角形是不同的，但是相关的数据%类型。我们完全可以把它们称为[2.x.4]而不是[2.x.5]和[2.x.6 ]来命名这两个类，但这有一个重要的缺点：假设你有一个功能完全相同的函数，但在2D或3D三角形上，取决于我们目前想在哪个维度上求解方程（如果你不相信一个函数在所有维度上都做同样的事情是常见的情况，看看下面的代码就知道了，2D和3D之间几乎没有区别！）。我们将不得不把同一个函数写两次，一次在[2.x.7]上工作，一次在[2.x.8]上工作。这在编程中是一个不必要的障碍，并且导致了保持两个函数同步的麻烦（最好是），或者在两个版本不同步时难以发现错误（最坏的情况是；这可能是更常见的情况）。





这种障碍可以通过使用C++语言提供的一些模板魔法来规避：模板化的类和函数并不是真正的类或函数，而只是取决于一个尚未定义的数据类型参数或一个在定义时也未知的数值的模式。然而，如果你向它提供了所需的信息，编译器可以从这些模板中建立适当的类或函数。当然，模板的部分内容可以依赖于模板参数，它们将在编译时被解析为特定的模板参数。例如，考虑下面这段代码。

[1.x.22] 






在编译器看到这个函数的时候，它不知道任何关于 [2.x.9] 的实际值。编译器唯一拥有的是一个模板，也就是一个蓝图，用来生成函数 [2.x.10] 如果给定 [2.x.11] 的特定值为未知值，编译器暂时没有代码可以生成。




然而，如果以后下来编译器会遇到代码，例如，看起来像这样。

[1.x.23] 

那么编译器将推断出[2.x.12]是为[2.x.13]请求的函数，并将上面的模板编译成一个到处都用2代替dim的函数，也就是说，它将编译这个函数，就好像它被定义为 

[1.x.24] 






然而，值得注意的是，函数[2.x.14]也依赖于维度，所以在这种情况下，编译器将调用函数[2.x.15]，而如果dim是3，它将调用[2.x.16]，这可能是（而且实际上是）一个完全不相关的函数。




同样的情况也可以用成员变量来做。考虑以下函数，它可能会反过来调用上述函数。

[1.x.25] 

这个函数有一个类型为 [2.x.17] 的成员变量。同样的，编译器在知道为哪个维度调用这个函数之前，是不能编译的。如果你像上面那样为一个特定的维度调用这个函数，编译器将使用模板，用调用的维度替换所有出现的dim，并编译它。如果你为不同的维度多次调用该函数，它将多次编译，每次都调用正确的[2.x.18]函数，并为成员变量保留适当的内存量；注意，[2.x.19]的大小可能，事实上也确实取决于空间维度。




deal.II库是围绕这个维度无关的编程概念建立的，因此允许你以一种不需要区分空间维度的方式编程。应该注意的是，只有在极少数的地方才有必要使用[2.x.20]es来实际比较维度。然而，由于编译器必须为每个维度单独编译每个函数，即使在那里，它在编译时也知道[2.x.21]的值，因此将能够优化掉[2.x.22]语句和未使用的分支。




在这个例子程序中，我们将展示如何独立编程维度（事实上，这比你必须照顾到维度还要简单），我们将把上一个例子的拉普拉斯问题扩展到一个同时在二维和三维空间运行的程序。其他的扩展是使用非常数的右侧函数和非零的边界值。




 [2.x.23] 在使用模板时，C++施加了各种语法限制，有时会让人有点难以理解为什么到底要这样写。一个典型的例子是，在很多地方都需要使用关键字[2.x.24]。如果你已经不完全熟悉，那么在[1.x.26]中链接的deal.II常见问题解答（FAQ）中解释了其中的几个困难。

<！--我们需要一个空行来正确地结束上述区块。--> [1.x.27] [1.x.28] 。


[1.x.29] [1.x.30]。




前面几个（很多）include文件已经在前面的例子中使用过了，所以我们在这里不再解释它们的含义。

[1.x.31] 



不过这是新的：在前面的例子中，我们从线性求解器得到了一些不需要的输出。如果我们想抑制它，我们必须包括这个文件，并在程序的某个地方添加一行（见下面的main()函数）。

[1.x.32] 



最后一步，和以前的程序一样，是将所有deal.II的类和函数名导入全局命名空间。

[1.x.33] 




[1.x.34][1.x.35] 。




这又是与前面的例子中相同的[2.x.25]类。唯一不同的是，我们现在把它声明为一个带有模板参数的类，而模板参数当然是我们要解决拉普拉斯方程的空间维度。当然，几个成员变量也取决于这个维度，特别是Triangulation类，它必须分别表示四边形或六面体。除此以外，一切都和以前一样。

[1.x.36] 




[1.x.37] [1.x.38] 




在下文中，我们再声明两个类，表示右手边和非均质Dirichlet边界值。两者都是一个二维空间变量的函数，所以我们也将它们声明为模板。




这些类中的每一个都是从一个共同的、抽象的基类Function派生出来的，它声明了所有函数都必须遵循的共同接口。特别是，具体的类必须重载[2.x.26]函数，该函数将二维空间中的一个点作为参数，并将该点的值作为[2.x.27]变量返回。




[2.x.28]函数需要第二个参数，我们在这里将其命名为[2.x.29]：这只是为了矢量值函数，你可能想访问点[2.x.30]处的矢量的某个分量。然而，我们的函数是标量的，所以我们不需要担心这个参数，在函数的实现中也不会使用它。在库的头文件中，Function基类对[2.x.31]函数的声明中，分量的默认值为0，所以我们在访问右手边的[2.x.32]函数时，只有一个参数，即我们要评估函数的点。然后，对于标量函数，可以简单地省略分量的值。




函数对象在库中很多地方都有使用（例如，在[2.x.33]中，我们用[2.x.34]实例作为[2.x.35]的参数，这是第一个我们定义继承于Function的新类的教程。由于我们只调用[2.x.36]，我们可以只用一个普通的函数（这就是[2.x.37]中的做法），但由于这是一个教程，为了举例说明，我们继承了Function。

[1.x.39] 



如果你不熟悉上述函数声明中的关键字 "virtual "和 "override "是什么意思，你可能想看看你最喜欢的C++书籍或在线教程，如http://www.cplusplus.com/doc/tutorial/polymorphism/ 。从本质上讲，这里发生的事情是Function<dim>是一个 "抽象 "基类，它声明了某种 "接口"--一组可以在这类对象上调用的函数。但它实际上并没有*实现*这些函数：它只是说 "Function对象是这样的"，但它实际上是什么类型的函数，则留给实现`value()'函数的派生类。




从一个类派生出另一个类，通常被称为 "is-a "关系函数。在这里，`RightHandSide'类 "是一个 "函数类，因为它实现了函数基类所描述的接口。("value() "函数的实际实现在下面的代码块中)。那么`virtual`关键字意味着 "是的，这里的函数可以被派生类覆盖"，而`override`关键字意味着 "是的，这实际上是一个我们知道已经被声明为基类一部分的函数"。覆盖 "关键字不是严格必要的，但它是防止打字错误的一个保险。如果我们把函数的名字或一个参数的类型弄错了，编译器会警告我们说："你说这个函数覆盖了基类中的一个函数，但实际上我不知道有任何这样的函数有这个名字和这些参数。" 




但回到这里的具体案例。在本教程中，我们选择2D中的函数[2.x.38]，或3D中的[2.x.39]作为右手边。我们可以用空间维度上的if语句来写这个区别，但这里有一个简单的方法，它也允许我们在一维（或四维，如果你想这样做）中使用相同的函数，通过使用一个短循环。 幸运的是，编译器在编译时就知道循环的大小（记住，在你定义模板时，编译器不知道[2.x.40]的值，但当它后来遇到语句或声明[2.x.41]时，它将采取模板，用2替换所有出现的dim，并编译出结果函数）。 换句话说，在编译这个函数的时候，主体将被执行的次数是已知的，编译器可以将循环所需的开销降到最低；结果将和我们马上使用上面的公式一样快。




最后要注意的是，[2.x.42]表示二维空间中的一个点，它的各个组成部分（即[2.x.43]，[2.x.44]，...坐标）可以像C和C++中一样使用（）运算符访问（事实上，[]运算符也同样有效），索引从零开始。

[1.x.40] 



作为边界值，我们选择二维的[2.x.45]，三维的[2.x.46]。这恰好等于从原点到我们想评估函数的点的矢量的平方，而不考虑维度。因此，这就是我们的回报。

[1.x.41] 




[1.x.42] [1.x.43] 




接下来是使用上述函数的类模板的实现。和以前一样，我们将把所有东西写成模板，这些模板有一个形式参数[2.x.47]，在我们定义模板函数的时候，我们假设这个参数是未知的。只有在以后，编译器才会发现[2.x.48]函数的声明，实际上）并在编译整个类的时候用2替换[2.x.49]，这个过程被称为 "模板的实例化"。这样做时，它还会用[2.x.51]替换[2.x.50]的实例，并从类模板中实例化后一个类。




事实上，编译器也会在[2.x.53]中发现一个声明[2.x.52]。这将导致它再次回到一般的[2.x.54]模板，替换所有出现的[2.x.55]，这次是3，并第二次编译这个类。请注意，[2.x.56]和[2.x.57]这两个实例是完全独立的类；它们唯一的共同特征是它们都是从同一个通用模板中实例化出来的，但它们不能相互转换，例如，不能共享任何代码（两个实例都是完全独立编译的）。










[1.x.44] [1.x.45]。




在这个介绍之后，这里是[2.x.58]类的构造函数。它指定了所需的有限元素的多项式程度，并将DoFHandler与三角形关联起来，就像在前面的例子程序中一样， [2.x.59] 。

[1.x.46] 




[1.x.47] [1.x.48] 。




网格的创建在本质上是依赖于维度的东西。然而，只要领域在二维或三维中足够相似，库就可以为你抽象。在我们的例子中，我们想再次在二维的正方形[2.x.60]上求解，或者在三维的立方体[2.x.61]上求解；两者都可以被称为[2.x.62]，因此我们可以在任何维度上使用同一个函数。当然，在二维和三维中创建超立方体的函数有很大的不同，但这是你不需要关心的事情。让库来处理这些困难的事情。

[1.x.49] 




[1.x.50][1.x.51] 。




这个函数看起来和前面的例子一模一样，尽管它执行的动作在细节上有很大不同，如果[2.x.63]刚好是3的话。从用户的角度来看，唯一显著的区别是所产生的单元格数量，在三个空间维度中比在两个空间维度中要高得多! 

[1.x.52] 




[1.x.53][1.x.54] 。




与之前的例子不同，我们现在想使用非恒定的右手函数和非零边界值。这两个任务都很容易实现，只需在矩阵和右手边的组合中增加几行代码。




不过，更有趣的是我们独立组装矩阵和右手边向量维度的方式：与二维的情况根本没有区别。由于这个函数中使用的重要对象（正交公式、FEValues）也通过模板参数的方式依赖于维度，它们可以为这个函数所编译的维度正确设置一切。通过使用模板参数声明所有可能依赖维度的类，库可以为你完成几乎所有的工作，你不必关心大多数事情。

[1.x.55] 



我们希望有一个非恒定的右手边，所以我们使用上面声明的类的一个对象来生成必要的数据。由于这个右手对象只在本函数中局部使用，所以我们在此将其声明为局部变量。

[1.x.56] 



与之前的例子相比，为了评估非恒定右侧函数，我们现在还需要目前所在单元上的正交点（之前，我们只需要FEValues对象中的形状函数的值和梯度，以及正交权重，[2.x.64]）。我们可以通过给FEValues对象添加#update_quadrature_points标志来告诉它为我们做什么。

[1.x.57] 



然后我们再次定义与前面程序中相同的缩写。这个变量的值当然取决于我们现在使用的维度，但是FiniteElement类为你做了所有必要的工作，你不需要关心与维度有关的部分。

[1.x.58] 



接下来，我们又要在所有的单元中进行循环，并将局部贡献集合起来。 注意，一个单元在两个空间维度上是一个四边形，但在三维上是一个六面体。事实上，[2.x.65]的数据类型是不同的，这取决于我们所处的维度，但对外界来说，它们看起来是一样的，你可能永远不会看到区别。在任何情况下，真正的类型是通过使用 "自动 "来隐藏的。

[1.x.59] 



现在我们要组装本地矩阵和右手边。这个过程和前面的例子完全一样，但是现在我们改变了循环的顺序（我们可以安全地这样做，因为它们是相互独立的），并且尽可能地合并本地矩阵和本地向量的循环，使事情变得更快。       


组装右手边与我们在[2.x.66]中所做的事情有唯一显著的不同：我们没有使用值为1的常数右手边，而是使用代表右手边的对象并在正交点对其进行评估。

[1.x.60] 



作为对这些循环的最后说明：当我们将局部贡献集合到[2.x.67]时，我们必须在点号q_index处将形状函数[2.x.68]和[2.x.69]的梯度相乘并与标量权重JxW相乘。这就是实际发生的情况。 [2.x.70]返回一个[2.x.71]维向量，由[2.x.72]对象表示，将其与[2.x.73]的结果相乘的运算器*确保两个向量的[2.x.74]分量被适当收缩，其结果是一个标量浮点数，然后与权重相乘。在内部，这个运算符*确保对向量的所有[2.x.75]分量都能正确发生，无论[2.x.76]是2、3还是其他空间维度；从用户的角度来看，这并不值得费心，然而，如果想独立编写代码维度，事情就会变得简单很多。




随着局部系统的组装，转移到全局矩阵和右手边的工作与之前完全一样，但在这里我们再次合并了一些循环以提高效率。

[1.x.61] 



作为这个函数的最后一步，我们希望在这个例子中拥有非均质的边界值，与之前的例子不同。这是一个简单的任务，我们只需要用一个描述我们想使用的边界值的类的对象（即上面声明的[2.x.78]类）来取代那里使用的[2.x.77]。   


函数[2.x.79]只对标有边界指标0的面起作用（因为这就是我们在下面的第二个参数中所说的函数应该起作用）。如果有的面的边界指标不是0，那么函数interpolate_boundary_values将对这些面不起作用。对于拉普拉斯方程来说，什么都不做相当于假设在边界的这些部分，零诺伊曼边界条件成立。

[1.x.62] 




[1.x.63][1.x.64] 




解决线性方程组是大多数程序中看起来几乎相同的事情。特别是，它与维度无关，所以这个函数是从前面的例子中逐字复制的。

[1.x.65] 



不过我们做了一个补充：由于我们抑制了线性求解器的输出，我们必须手工打印迭代次数。

[1.x.66] 




[1.x.67][1.x.68] 。




这个函数也做了在 [2.x.80] 中各自做的事情。这里也没有改变尺寸的独立性。




由于程序将同时运行2d和3d版本的拉普拉斯求解器，我们使用文件名中的维度为每次运行生成不同的文件名（在一个更好的程序中，可以检查[2.x.81]是否可以有2或3以外的其他值，但为了简洁起见，我们在这里忽略了这一点）。

[1.x.69] 




[1.x.70] [1.x.71]。




这是一个对一切都有顶层控制的函数。除了一行额外的输出外，它与前面的例子相同。

[1.x.72] 




[1.x.73][1.x.74] 。




这就是主函数。它看起来也大多像在[2.x.82]，但如果你看下面的代码，注意我们如何首先创建一个[2.x.83]类型的变量（迫使编译器用[2.x.84]编译类模板）并运行一个2d模拟，然后我们用3d做整个事情。




在实践中，这可能不是你经常做的事情（你可能要么想解决一个2D问题，要么想解决一个3D问题，但不会同时解决这两个问题）。然而，它展示了一种机制，我们可以在一个地方简单地改变我们想要的维度，从而迫使编译器为我们要求的维度重新编译独立的类模板。这里的重点在于，我们只需要改变一个地方。这使得在计算速度较快的2D中调试程序变得非常简单，然后将一个地方切换到3，在3D中运行计算量更大的程序，进行 "真实 "计算。




这两个区块中的每一个都用大括号括起来，以确保[2.x.85]这个变量在我们继续为3D情况分配内存之前就已经超出了范围（并释放了它所持有的内存）。如果没有额外的大括号，[2.x.86]变量只会在函数结束时被销毁，也就是在运行3d问题之后，并且会在3d运行时不必要地占用内存。

[1.x.75] 

[1.x.76][1.x.77] 。




程序的输出看起来如下（迭代次数可能会有一到两次的变化，这取决于你的电脑，因为这通常取决于浮点运算的舍入精度，这在不同的处理器中是不同的）。

[1.x.78] 

很明显，在三个空间维度中，单元格的数量以及自由度的数量要高得多。这里看不到的是，除了矩阵中更多的行和列之外，在三个空间维度中，矩阵的每一行也有明显更多的条目。这就导致了解方程组的数值工作量大大增加，当你实际运行程序时，你可以从两个求解步骤的运行时间中感受到这一点。




该程序产生两个文件。 [2.x.87]和[2.x.88]，可以用VisIt或Paraview程序查看（如果你没有这些程序，你可以很容易地改变程序的输出格式，使你更容易查看）。解决方案的可视化是一门艺术，但它也可以很有趣，所以你应该玩一玩你最喜欢的可视化工具，熟悉它的功能。下面是我想出的2d解决方案的内容。

 [2.x.89]  

( [2.x.90] 图中显示了正在考虑的问题的解决方案，是一个三维图。可以看出，该解在域的内部几乎是平的，在边界附近有较高的曲率。当然，这是因为对于拉普拉斯方程来说，解的曲率等于右手边，而右手边被选为四次多项式，在内部几乎为零，只有在接近域的边界时才急剧上升；右手边函数的最大值在域的角落，在那里解的移动也最迅速。很高兴看到解沿着域的边界遵循理想的二次边界值。将计算出的解与分析出的解进行验证也是很有用的。关于这一技术的解释，见[2.x.91] 。

另一方面，尽管图片中没有明确显示网格线，但你可以看到它们在解中的小结点。这清楚地表明，解没有被计算到非常高的精度，为了得到更好的解，我们可能要在更细的网格上进行计算。

在三个空间维度上，可视化就比较困难了。左图显示了解决方案和它在域的表面上计算的网格。这很好，但它的缺点是完全掩盖了内部的情况。右图是通过显示解的恒定值的表面（如左上角的图例所示），试图将内部的情况也可视化。如果我们把各个表面弄得稍微透明一些，这样就有可能透过它们看到后面的东西，那么等值面图片看起来就最好了。

 [2.x.92]  

 [2.x.93] 关于可视化的最后一句话：可视化的想法是提供洞察力，这与显示信息不同。特别是，在一张图片上很容易显示过多的信息，但在显示更多的信息的同时，也使人们更难收集到洞察力。举个例子，我用来生成这些图片的程序，VisIt，默认情况下在每个轴上都有刻度线，在[2.x.94]轴上贴上一个大胖标签 "X轴"，其他轴也是如此，在左上方显示提取数据的文件名，在右下方显示用户的名字以及时间和日期。这些在这里都不重要：轴同样容易辨认，因为左下方的三脚架仍然可见，而且我们从程序中知道域是[2.x.95]，所以不需要刻度线。因此，我关掉了图片中所有不相干的东西：可视化的艺术在于把图片缩减到那些对看到自己想看的东西很重要的部分，而不是更多。




[1.x.79] [1.x.80][1.x.81] 。




从本质上讲，使用该程序的可能性与前一个程序相同，只是它们现在也适用于3D情况。为了获得灵感，请阅读[1.x.82]。[1.x.83] [1.x.84] [2.x.96]。 

 [2.x.97] 
